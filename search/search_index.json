{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#kbs-knowledge-based-systems-for-ruby","title":"KBS - Knowledge-Based Systems for Ruby","text":"<p>A Ruby implementation of the RETE algorithm for building intelligent, rule-based systems with persistent memory.</p> <p> </p>"},{"location":"#what-is-kbs","title":"What is KBS?","text":"<p>KBS (Knowledge-Based Systems) is a powerful Ruby gem that brings production rule systems to your applications. At its core is the RETE algorithm, a highly optimized pattern-matching engine originally developed for expert systems and now used in modern applications ranging from trading systems to IoT automation.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 RETE Algorithm: State-of-the-art pattern matching with unlinking optimization</li> <li>\ud83d\udcbe Persistent Blackboard Memory: SQLite, Redis, or hybrid storage for facts and audit trails</li> <li>\ud83c\udfaf Declarative DSL: Write rules in natural, readable Ruby syntax</li> <li>\ud83d\udd04 Incremental Matching: Process only changes, not entire fact sets</li> <li>\ud83d\udeab Negation Support: Express \"absence of pattern\" conditions naturally</li> <li>\ud83d\udcca Multi-Agent Systems: Build collaborative systems with message passing</li> <li>\ud83d\udd0d Full Auditability: Complete history of fact changes and rule firings</li> <li>\u26a1 High Performance: Handle millions of facts with sub-millisecond updates</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>require 'kbs'\n\n# Create a rule-based trading system\nkb = KBS.knowledge_base do\n  # Define a rule using the DSL\n  rule \"buy_signal\" do\n    # Stock price is below threshold\n    on :stock, symbol: :symbol?, price: :price?\n    on :threshold, symbol: :symbol?, buy_below: :threshold?\n\n    # No pending order exists (negation)\n    without :order, symbol: :symbol?\n\n    perform do |facts, bindings|\n      if bindings[:price?] &lt; bindings[:threshold?]\n        puts \"BUY #{bindings[:symbol?]} at #{bindings[:price?]}\"\n      end\n    end\n  end\n\n  # Add facts to working memory\n  fact :stock, symbol: \"AAPL\", price: 145.50\n  fact :threshold, symbol: \"AAPL\", buy_below: 150.0\n\n  # Fire matching rules\n  run  # =&gt; BUY AAPL at 145.5\nend\n</code></pre>"},{"location":"#why-rete","title":"Why RETE?","text":"<p>Traditional rule engines re-evaluate all rules against all facts on every change\u2014extremely inefficient. RETE solves this through:</p> <ol> <li>Network Compilation: Rules are compiled into a discrimination network that shares common patterns</li> <li>State Preservation: Partial matches are cached between cycles</li> <li>Incremental Updates: Only changed facts propagate through the network</li> <li>Unlinking Optimization (RETE): Empty nodes automatically disconnect to skip unnecessary work</li> </ol> <p>Result: Near-constant time per fact change, regardless of rule set size.</p>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#algorithmic-trading","title":"\ud83d\udcb9 Algorithmic Trading","text":"<p>Real-time market analysis, signal detection, and automated order execution with complex multi-condition rules.</p>"},{"location":"#industrial-automation","title":"\ud83c\udfed Industrial Automation","text":"<p>IoT sensor monitoring, predictive maintenance, and automated control systems with temporal reasoning.</p>"},{"location":"#expert-systems","title":"\ud83c\udfe5 Expert Systems","text":"<p>Medical diagnosis, troubleshooting assistants, and decision support systems with knowledge representation.</p>"},{"location":"#multi-agent-systems","title":"\ud83e\udd16 Multi-Agent Systems","text":"<p>Collaborative agents with shared blackboard memory for distributed problem-solving.</p>"},{"location":"#business-rules-engines","title":"\ud83d\udce7 Business Rules Engines","text":"<p>Policy enforcement, workflow automation, and compliance checking with auditable decision trails.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>KBS consists of several integrated components:</p> <ul> <li>RETE Engine: Core pattern matching and rule execution</li> <li>Working Memory: Transient in-memory fact storage</li> <li>Blackboard System: Persistent memory with SQLite/Redis backends</li> <li>DSL: Natural language rule definition syntax</li> <li>Message Queue: Priority-based inter-agent communication</li> <li>Audit Log: Complete history for compliance and debugging</li> </ul> <p>See Architecture Overview for details.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Installation - Add KBS to your project</li> <li>Quick Start - Build your first rule-based system in 5 minutes</li> <li>RETE Algorithm - Deep dive into how it works</li> <li>Writing Rules - Master the DSL and pattern matching</li> <li>Examples - Learn from real-world applications</li> </ol>"},{"location":"#performance","title":"Performance","text":"<p>KBS is built for production workloads:</p> <ul> <li>Fact Addition: O(N) where N = activated nodes (typically &lt;&lt; total nodes)</li> <li>Rule Firing: O(M) where M = matched tokens</li> <li>Memory Efficient: Network sharing reduces redundant storage</li> <li>Scalable: Tested with millions of facts, thousands of rules</li> </ul> <p>Benchmarks on M2 Max: - Add 100,000 facts: ~500ms - Match complex 5-condition rule: &lt;1ms per fact - Redis backend: 100x faster than SQLite for high-frequency updates</p>"},{"location":"#project-status","title":"Project Status","text":"<p>KBS is actively maintained:</p> <ul> <li>\u2705 Core RETE implementation complete</li> <li>\u2705 Persistent blackboard with multiple backends</li> <li>\u2705 Full DSL support with negation</li> <li>\u2705 Comprehensive test coverage</li> <li>\u2705 Real-world usage in trading systems</li> <li>\ud83d\udea7 Additional examples and guides in progress</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: madbomber/kbs</li> <li>RubyGems: kbs</li> <li>Issues: Report bugs or request features</li> <li>Discussions: Ask questions</li> </ul>"},{"location":"#license","title":"License","text":"<p>KBS is released under the MIT License.</p> <p>Copyright \u00a9 2024 Dewayne VanHoozer</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>The RETE algorithm was invented by Charles Forgy in 1979. This implementation draws inspiration from:</p> <ul> <li>Forgy, C. (1982). \"Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem\"</li> <li>Doorenbos, R. (1995). \"Production Matching for Large Learning Systems\" (RETE/UL)</li> <li>Modern production rule systems: Drools, Jess, CLIPS</li> </ul> <p>Ready to build intelligent systems? Start with the Quick Start Guide!</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Ruby: 2.7 or higher</li> <li>SQLite3: For persistent blackboard memory (optional)</li> <li>Redis: For high-performance persistence (optional)</li> </ul>"},{"location":"installation/#installing-the-gem","title":"Installing the Gem","text":""},{"location":"installation/#from-rubygems","title":"From RubyGems","text":"<pre><code>gem install kbs\n</code></pre>"},{"location":"installation/#using-bundler","title":"Using Bundler","text":"<p>Add to your <code>Gemfile</code>:</p> <pre><code>gem 'kbs'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/madbomber/kbs.git\ncd kbs\nbundle install\nrake install\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"installation/#sqlite3-default-blackboard-backend","title":"SQLite3 (Default Blackboard Backend)","text":"<pre><code>gem install sqlite3\n</code></pre> <p>Or in your <code>Gemfile</code>:</p> <pre><code>gem 'sqlite3'\n</code></pre>"},{"location":"installation/#redis-high-performance-backend","title":"Redis (High-Performance Backend)","text":"<p>Install Redis server:</p> <pre><code># macOS\nbrew install redis\nbrew services start redis\n\n# Ubuntu/Debian\nsudo apt-get install redis-server\nsudo systemctl start redis\n\n# Docker\ndocker run -d -p 6379:6379 redis:latest\n</code></pre> <p>Install Ruby Redis gem:</p> <pre><code>gem install redis\n</code></pre> <p>Or in your <code>Gemfile</code>:</p> <pre><code>gem 'redis'\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify the installation:</p> <pre><code>require 'kbs'\n\nputs \"KBS version: #{KBS::VERSION}\"\n# =&gt; KBS version: 0.1.0\n\n# Test basic functionality\nengine = KBS::Engine.new\nengine.add_fact(:test, value: 42)\nputs \"\u2713 KBS is working!\"\n</code></pre>"},{"location":"installation/#development-setup","title":"Development Setup","text":"<p>For contributing or running tests:</p> <pre><code>git clone https://github.com/madbomber/kbs.git\ncd kbs\nbundle install\n\n# Run tests\nbundle exec rake test\n\n# Run examples\nbundle exec ruby examples/working_demo.rb\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#sqlite3-installation-issues","title":"SQLite3 Installation Issues","text":"<p>On macOS with M1/M2:</p> <pre><code>gem install sqlite3 -- --with-sqlite3-include=/opt/homebrew/opt/sqlite/include \\\n  --with-sqlite3-lib=/opt/homebrew/opt/sqlite/lib\n</code></pre> <p>On Ubuntu/Debian:</p> <pre><code>sudo apt-get install libsqlite3-dev\ngem install sqlite3\n</code></pre>"},{"location":"installation/#redis-connection-issues","title":"Redis Connection Issues","text":"<p>Check Redis is running:</p> <pre><code>redis-cli ping\n# =&gt; PONG\n</code></pre> <p>Test connection from Ruby:</p> <pre><code>require 'redis'\nredis = Redis.new(url: 'redis://localhost:6379/0')\nredis.ping\n# =&gt; \"PONG\"\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first rule-based system</li> <li>RETE Algorithm - Understand the engine</li> <li>Writing Rules - Master the DSL</li> <li>Examples - See real-world applications</li> </ul>"},{"location":"quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with KBS in 5 minutes.</p>"},{"location":"quick-start/#your-first-rule-based-system","title":"Your First Rule-Based System","text":"<p>Let's build a simple temperature monitoring system that alerts when readings are abnormal.</p>"},{"location":"quick-start/#step-1-create-a-knowledge-base-and-define-rules","title":"Step 1: Create a Knowledge Base and Define Rules","text":"<pre><code>require 'kbs'\n\nkb = KBS.knowledge_base do\n  # Rule 1: Alert on high temperature\n  rule \"high_temperature_alert\" do\n    on :sensor, id: :id?, temp: :temp?\n\n    perform do |facts, bindings|\n      if bindings[:temp?] &gt; 75\n        puts \"\u26a0\ufe0f  HIGH TEMP Alert: Sensor #{bindings[:id?]} at #{bindings[:temp?]}\u00b0F\"\n      end\n    end\n  end\n\n  # Rule 2: Alert when cooling system is offline AND temp is high\n  rule \"critical_condition\", priority: 10 do\n    on :sensor, id: :id?, temp: :temp?\n    on :cooling, id: :id?, status: \"offline\"\n\n    perform do |facts, bindings|\n      if bindings[:temp?] &gt; 75\n        puts \"\ud83d\udea8 CRITICAL: Sensor #{bindings[:id?]} at #{bindings[:temp?]}\u00b0F with cooling OFFLINE!\"\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"quick-start/#step-2-add-facts","title":"Step 2: Add Facts","text":"<pre><code># Add sensor readings\nkb.fact :sensor, id: \"room_101\", temp: 72\nkb.fact :sensor, id: \"server_rack\", temp: 82\nkb.fact :sensor, id: \"storage\", temp: 65\n\n# Add cooling system status\nkb.fact :cooling, id: \"server_rack\", status: \"offline\"\n</code></pre>"},{"location":"quick-start/#step-3-run-rules","title":"Step 3: Run Rules","text":"<pre><code>kb.run\n# Output:\n# =&gt; \u26a0\ufe0f  HIGH TEMP Alert: Sensor server_rack at 82\u00b0F\n# =&gt; \ud83d\udea8 CRITICAL: Sensor server_rack at 82\u00b0F with cooling OFFLINE!\n</code></pre>"},{"location":"quick-start/#understanding-what-happened","title":"Understanding What Happened","text":"<ol> <li>Knowledge Base Creation: <code>KBS.knowledge_base do...end</code> creates the RETE network and defines rules</li> <li>Rule Definition: Rules are compiled into the discrimination network using the DSL</li> <li>Fact Assertion: <code>kb.fact</code> adds facts that propagate through the network, creating partial matches</li> <li>Rule Firing: <code>kb.run</code> executes actions for all complete matches</li> </ol> <p>The critical rule fires because: - Sensor \"server_rack\" temp (82\u00b0F) &gt; 75 - Cooling system for \"server_rack\" is offline - Both conditions are joined on the same <code>:id?</code> variable</p>"},{"location":"quick-start/#using-negation","title":"Using Negation","text":"<p>Rules can match on the absence of facts:</p> <pre><code>kb = KBS.knowledge_base do\n  # Alert when sensor has NO recent reading\n  rule \"stale_sensor\" do\n    on :sensor_registered, id: :id?\n    # No recent reading exists (negation!)\n    without :sensor, id: :id?\n\n    perform do |facts, bindings|\n      puts \"\u26a0\ufe0f  No reading from sensor #{bindings[:id?]}\"\n    end\n  end\n\n  # Register sensors\n  fact :sensor_registered, id: \"room_101\"\n  fact :sensor_registered, id: \"room_102\"\n\n  # Only add reading for room_101\n  fact :sensor, id: \"room_101\", temp: 70\n\n  run\n  # =&gt; \u26a0\ufe0f  No reading from sensor room_102\nend\n</code></pre>"},{"location":"quick-start/#persistent-blackboard-memory","title":"Persistent Blackboard Memory","text":"<p>For production systems, use persistent storage:</p> <pre><code>require 'kbs/blackboard'\n\n# SQLite backend (default)\nengine = KBS::Blackboard::Engine.new(db_path: 'monitoring.db')\n\nkb = KBS.knowledge_base(engine: engine) do\n  rule \"temperature_monitor\" do\n    on :sensor, temp: greater_than(75)\n    perform do |facts|\n      puts \"High temp alert!\"\n    end\n  end\n\n  # Facts survive restarts\n  fact :sensor, id: \"room_101\", temp: 72\n\n  run\nend\n\n# Query historical data\naudit = engine.blackboard.get_history(limit: 10)\n</code></pre>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":""},{"location":"quick-start/#learn-the-fundamentals","title":"Learn the Fundamentals","text":"<ul> <li>Writing Rules - Master rule syntax and patterns</li> <li>Pattern Matching - Understand how facts match conditions</li> <li>Variable Binding - Use variables to join conditions</li> <li>Negation - Express \"absence\" conditions</li> </ul>"},{"location":"quick-start/#explore-examples","title":"Explore Examples","text":"<ul> <li>Stock Trading Examples - Build a trading signal system</li> <li>Expert System Examples - Diagnostic and decision support</li> <li>Blackboard &amp; Multi-Agent Examples - Collaborative problem-solving</li> </ul>"},{"location":"quick-start/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Blackboard Memory - Persistent storage and audit trails</li> <li>Performance Tuning - Optimize for production workloads</li> <li>Debugging - Trace rule execution and network state</li> </ul>"},{"location":"quick-start/#understand-the-engine","title":"Understand the Engine","text":"<ul> <li>RETE Algorithm - Deep dive into pattern matching</li> <li>Network Structure - How rules are compiled</li> <li>API Reference - Complete class documentation</li> </ul>"},{"location":"quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"quick-start/#time-based-rules","title":"Time-Based Rules","text":"<pre><code>kb = KBS.knowledge_base do\n  rule \"recent_spike\" do\n    on :reading,\n       sensor: :id?,\n       temp: :temp?,\n       timestamp: -&gt;(ts) { Time.now - ts &lt; 300 }  # Within 5 minutes\n\n    perform do |facts, bindings|\n      puts \"Recent spike: #{bindings[:temp?]}\u00b0F\"\n    end\n  end\nend\n</code></pre>"},{"location":"quick-start/#threshold-comparison","title":"Threshold Comparison","text":"<pre><code>kb = KBS.knowledge_base do\n  rule \"above_threshold\" do\n    on :reading, sensor: :id?, value: :val?\n    on :threshold, sensor: :id?, max: :max?\n\n    perform do |facts, bindings|\n      if bindings[:val?] &gt; bindings[:max?]\n        puts \"Threshold exceeded!\"\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"quick-start/#state-machine","title":"State Machine","text":"<pre><code>kb = KBS.knowledge_base do\n  # Transition from \"init\" to \"ready\"\n  rule \"init_to_ready\" do\n    on :state, current: \"init\"\n    on :sensor, initialized: true\n    # No \"ready\" state exists yet\n    without :state, current: \"ready\"\n\n    perform do |facts|\n      # Note: For state transitions, you'd typically use engine methods\n      # This is a simplified example\n      puts \"Transitioning to ready state\"\n    end\n  end\nend\n</code></pre>"},{"location":"quick-start/#tips","title":"Tips","text":"<ol> <li>Use descriptive rule names: Makes debugging easier</li> <li>Set priorities: Higher priority rules fire first</li> <li>Call <code>run()</code> explicitly: Rules don't fire automatically</li> <li>Leverage negation: Express \"when X is absent\" naturally</li> <li>Profile performance: Use <code>advanced/debugging.md</code> techniques</li> </ol> <p>Ready to dive deeper? Check out the Writing Rules Guide!</p>"},{"location":"what-is-a-fact/","title":"What is a Fact?","text":"<p>A fact is the fundamental unit of knowledge in KBS - a piece of information about your domain that the system can reason about. Facts are the \"data\" on which rules operate.</p>"},{"location":"what-is-a-fact/#core-concept","title":"Core Concept","text":"<p>Think of a fact as a typed data record that represents something true at a particular moment:</p> <ul> <li>\"The temperature in the server room is 85\u00b0F\"</li> <li>\"Stock AAPL is trading at $150.25 with volume 1.2M\"</li> <li>\"Sensor #42 is active\"</li> <li>\"Order #123 is pending\"</li> </ul> <p>Each fact has:</p> <ol> <li>Type - What kind of thing this is (<code>:temperature</code>, <code>:stock</code>, <code>:sensor</code>, <code>:order</code>)</li> <li>Attributes - Key-value pairs describing it (<code>location: \"server_room\"</code>, <code>value: 85</code>)</li> </ol>"},{"location":"what-is-a-fact/#anatomy-of-a-fact","title":"Anatomy of a Fact","text":""},{"location":"what-is-a-fact/#structure","title":"Structure","text":"<pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\nfact.type        # =&gt; :temperature\nfact.attributes  # =&gt; {:location =&gt; \"server_room\", :value =&gt; 85}\nfact[:location]  # =&gt; \"server_room\"\nfact[:value]     # =&gt; 85\n</code></pre>"},{"location":"what-is-a-fact/#visual-representation","title":"Visual Representation","text":"<p>A fact consists of a type symbol and a hash of attribute key-value pairs.</p>"},{"location":"what-is-a-fact/#how-facts-differ-from-other-data-structures","title":"How Facts Differ from Other Data Structures","text":"Aspect Fact Plain Hash Database Row Object Type Explicit (<code>:temperature</code>) None Table name Class Pattern Matching Built-in Manual SQL WHERE Manual Identity By content &amp; type By reference By primary key By reference Purpose Reasoning &amp; inference General storage Persistent storage Behavior + data Lifecycle Add/retract from KB Create/destroy Insert/delete New/GC <p>Example Comparison:</p> <pre><code># Plain Hash\ndata = { location: \"server_room\", value: 85 }\n# What kind of data is this? No way to tell.\n\n# Database Row\n# SELECT * FROM temperatures WHERE location = 'server_room'\n# Requires SQL, separate from logic\n\n# Object\nclass Temperature\n  attr_accessor :location, :value\nend\ntemp = Temperature.new\n# Has behavior but no built-in pattern matching\n\n# Fact\nfact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n# Self-describing, pattern-matchable, inference-ready\n</code></pre>"},{"location":"what-is-a-fact/#fact-lifecycle","title":"Fact Lifecycle","text":""},{"location":"what-is-a-fact/#1-creation","title":"1. Creation","text":"<p>Facts are created and added to a knowledge base:</p> <pre><code># In-memory knowledge base\nkb = KBS.knowledge_base do\n  fact :temperature, location: \"server_room\", value: 85\nend\n\n# Blackboard (persistent)\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nfact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\n</code></pre>"},{"location":"what-is-a-fact/#2-pattern-matching","title":"2. Pattern Matching","text":"<p>Once added, facts are automatically matched against rule patterns:</p> <pre><code>rule \"high_temperature\" do\n  # This pattern matches our fact above\n  on :temperature, location: \"server_room\", value: greater_than(80)\n  perform { puts \"Alert!\" }\nend\n</code></pre>"},{"location":"what-is-a-fact/#3-rule-firing","title":"3. Rule Firing","text":"<p>When all conditions of a rule match, the rule fires:</p> <pre><code>kb.run  # \u2192 \"Alert!\" (rule fires because fact matches)\n</code></pre>"},{"location":"what-is-a-fact/#4-updates-blackboard-only","title":"4. Updates (Blackboard Only)","text":"<p>Persistent facts can be updated:</p> <pre><code>fact[:value] = 90  # Update persisted immediately\nfact.update(value: 90, timestamp: Time.now)  # Bulk update\n</code></pre> <p>Note: Updates do NOT trigger rule re-evaluation. To re-trigger rules, retract and re-add.</p>"},{"location":"what-is-a-fact/#5-retraction","title":"5. Retraction","text":"<p>Facts can be removed from working memory:</p> <pre><code># DSL\nretract fact\n\n# Blackboard - fact can retract itself\nfact.retract\n</code></pre>"},{"location":"what-is-a-fact/#fact-types-implementations","title":"Fact Types (Implementations)","text":"<p>KBS provides two fact implementations:</p>"},{"location":"what-is-a-fact/#1-transient-facts-kbsfact","title":"1. Transient Facts (<code>KBS::Fact</code>)","text":"<ul> <li>Used by: In-memory knowledge bases</li> <li>Identity: Ruby object ID</li> <li>Persistence: None (lost on process exit)</li> <li>Performance: Fast (no I/O)</li> </ul> <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\nputs fact.id  # =&gt; 70123456789012 (Ruby object ID)\n\n# Lightweight, perfect for short-lived reasoning\nkb = KBS.knowledge_base do\n  fact :stock, symbol: \"AAPL\", price: 150\n  run\nend\n# Facts disappear when kb goes out of scope\n</code></pre> <p>Best for:</p> <ul> <li>Event stream processing</li> <li>Short-lived analyses</li> <li>Prototyping and testing</li> <li>When restart durability isn't needed</li> </ul>"},{"location":"what-is-a-fact/#2-persistent-facts-kbsblackboardfact","title":"2. Persistent Facts (<code>KBS::Blackboard::Fact</code>)","text":"<ul> <li>Used by: Blackboard knowledge bases</li> <li>Identity: UUID (stable across restarts)</li> <li>Persistence: SQLite, Redis, or Hybrid storage</li> <li>Audit Trail: Complete change history</li> <li>Performance: Slower (I/O overhead)</li> </ul> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nfact = engine.add_fact(:temperature, value: 85)\n\nputs fact.uuid  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Update persists\nfact[:value] = 90\n\n# Restart process\nengine2 = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nreloaded = engine2.blackboard.get_facts_by_type(:temperature).first\nputs reloaded[:value]  # =&gt; 90 (persisted)\n</code></pre> <p>Best for:</p> <ul> <li>Long-running systems</li> <li>Multi-agent coordination</li> <li>Audit requirements</li> <li>Systems that must survive restarts</li> <li>Distributed reasoning</li> </ul>"},{"location":"what-is-a-fact/#pattern-matching","title":"Pattern Matching","text":"<p>Facts excel at pattern matching\u2014the ability to find facts that satisfy specific criteria.</p>"},{"location":"what-is-a-fact/#literal-matching","title":"Literal Matching","text":"<p>Match exact values:</p> <pre><code>fact = KBS::Fact.new(:stock, symbol: \"AAPL\", price: 150.25)\n\n# Matches\nfact.matches?(type: :stock, symbol: \"AAPL\")  # =&gt; true\n\n# Doesn't match\nfact.matches?(type: :stock, symbol: \"GOOGL\")  # =&gt; false\n</code></pre>"},{"location":"what-is-a-fact/#predicate-matching","title":"Predicate Matching","text":"<p>Match with lambda conditions:</p> <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\n\n# Matches\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 80 })  # =&gt; true\nfact.matches?(type: :temperature, value: -&gt;(v) { v &lt; 100 }) # =&gt; true\n\n# Doesn't match\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 90 })  # =&gt; false\n</code></pre>"},{"location":"what-is-a-fact/#variable-binding","title":"Variable Binding","text":"<p>Capture values for use in rule actions:</p> <pre><code>rule \"report_temperature\" do\n  on :temperature, location: :loc?, value: :temp?\n  #                         ^^^^^^         ^^^^^^\n  #                    Variables (end with ?)\n\n  perform do |facts, bindings|\n    # bindings contains captured values\n    puts \"#{bindings[:loc?]}: #{bindings[:temp?]}\u00b0F\"\n  end\nend\n\n# Add fact\nfact :temperature, location: \"server_room\", value: 85\n\nrun  # \u2192 \"server_room: 85\u00b0F\"\n</code></pre>"},{"location":"what-is-a-fact/#join-tests","title":"Join Tests","text":"<p>Variables create joins across multiple facts:</p> <pre><code>rule \"inventory_check\" do\n  on :order, product_id: :pid?, quantity: :qty?\n  on :inventory, product_id: :pid?, available: :avail?\n  #                          ^^^^^^\n  #                   Same variable = JOIN condition\n\n  perform do |facts, bindings|\n    # Only fires when BOTH facts have same product_id\n    if bindings[:avail?] &lt; bindings[:qty?]\n      puts \"Insufficient inventory for #{bindings[:pid?]}\"\n    end\n  end\nend\n</code></pre>"},{"location":"what-is-a-fact/#common-fact-patterns","title":"Common Fact Patterns","text":""},{"location":"what-is-a-fact/#1-entity-facts","title":"1. Entity Facts","text":"<p>Represent domain objects:</p> <pre><code>fact :customer, id: 12345, name: \"Acme Corp\", tier: \"gold\"\nfact :product, sku: \"ABC-123\", price: 49.99, in_stock: true\nfact :order, id: 789, customer_id: 12345, total: 499.90\n</code></pre>"},{"location":"what-is-a-fact/#2-event-facts","title":"2. Event Facts","text":"<p>Represent things that happened:</p> <pre><code>fact :order_placed, order_id: 789, timestamp: Time.now\nfact :payment_received, order_id: 789, amount: 499.90\nfact :item_shipped, tracking: \"1Z999\", order_id: 789\n</code></pre>"},{"location":"what-is-a-fact/#3-sensor-facts","title":"3. Sensor Facts","text":"<p>Real-time measurements:</p> <pre><code>fact :temperature, sensor_id: 42, value: 85, timestamp: Time.now\nfact :pressure, sensor_id: 43, value: 14.7, unit: \"psi\"\nfact :motion_detected, camera_id: 5, location: \"entrance\"\n</code></pre>"},{"location":"what-is-a-fact/#4-state-facts","title":"4. State Facts","text":"<p>Current system state:</p> <pre><code>fact :connection, server: \"db-1\", status: \"active\"\nfact :worker, id: 3, status: \"busy\", task_id: 456\nfact :cache, key: \"user:123\", valid_until: Time.now + 3600\n</code></pre>"},{"location":"what-is-a-fact/#5-derived-facts","title":"5. Derived Facts","text":"<p>Facts inferred from other facts:</p> <pre><code>rule \"derive_alert\" do\n  on :temperature, value: greater_than(80), location: :loc?\n  without :alert, location: :loc?  # No existing alert\n\n  perform do |facts, bindings|\n    # Add derived fact\n    fact :alert,\n         location: bindings[:loc?],\n         level: \"high\",\n         source: \"temperature_monitor\"\n  end\nend\n</code></pre>"},{"location":"what-is-a-fact/#6-flag-facts","title":"6. Flag Facts","text":"<p>Boolean markers (attributes optional):</p> <pre><code>fact :system_ready\nfact :maintenance_mode\nfact :debug_enabled\nfact :cache_warmed\n\n# Used in rules\nrule \"process_requests\" do\n  on :system_ready\n  without :maintenance_mode\n  on :request, id: :req_id?\n  perform { |facts, b| handle_request(b[:req_id?]) }\nend\n</code></pre>"},{"location":"what-is-a-fact/#fact-vs-rule-relationship","title":"Fact vs. Rule Relationship","text":"<p>Facts and rules work together in a symbiotic relationship:</p> <p></p> <p>Facts (data) and rules (logic) interact through pattern matching: rules match facts, execute actions, and may create new facts, continuing the inference cycle.</p> <p>Example:</p> <pre><code># FACTS represent the current state\nfact :stock, symbol: \"AAPL\", price: 150, volume: 1_000_000\nfact :portfolio, cash: 10_000, max_position: 5_000\n\n# RULES define logic\nrule \"momentum_buy\" do\n  # IF these facts exist with these patterns...\n  on :stock, symbol: :sym?, price: :price?, volume: greater_than(500_000)\n  on :portfolio, cash: :cash?, max_position: :max?\n\n  # THEN execute this action\n  perform do |facts, bindings|\n    position_size = [bindings[:max?], bindings[:cash?] * 0.1].min\n    shares = (position_size / bindings[:price?]).floor\n\n    if shares &gt; 0\n      # Action may create new facts\n      fact :order,\n           symbol: bindings[:sym?],\n           shares: shares,\n           type: \"market_buy\"\n    end\n  end\nend\n</code></pre>"},{"location":"what-is-a-fact/#fact-semantics","title":"Fact Semantics","text":""},{"location":"what-is-a-fact/#open-world-assumption","title":"Open World Assumption","text":"<p>Facts can have any attributes. Patterns only constrain what they mention:</p> <pre><code># Fact has 4 attributes\nfact = KBS::Fact.new(:stock,\n  symbol: \"AAPL\",\n  price: 150,\n  volume: 1_000_000,\n  exchange: \"NASDAQ\"\n)\n\n# Pattern only constrains 2 - still matches!\nfact.matches?(type: :stock, symbol: \"AAPL\")  # =&gt; true\n</code></pre>"},{"location":"what-is-a-fact/#closed-attribute-assumption","title":"Closed Attribute Assumption","text":"<p>If a pattern requires an attribute, the fact must have it:</p> <pre><code>fact = KBS::Fact.new(:stock, symbol: \"AAPL\", price: 150)\n# No :volume attribute\n\n# Fails - fact missing required :volume\nfact.matches?(type: :stock, volume: greater_than(1000))  # =&gt; false\n</code></pre>"},{"location":"what-is-a-fact/#type-safety","title":"Type Safety","text":"<p>Type is always checked first:</p> <pre><code>fact = KBS::Fact.new(:stock, symbol: \"AAPL\")\n\n# Fails immediately - wrong type\nfact.matches?(type: :temperature)  # =&gt; false\n\n# Succeeds - right type\nfact.matches?(type: :stock)  # =&gt; true\n</code></pre>"},{"location":"what-is-a-fact/#value-immutability-transient-facts","title":"Value Immutability (Transient Facts)","text":"<p>Transient facts should be treated as immutable. Changing attributes doesn't trigger re-evaluation:</p> <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\nengine.add_fact(fact)\n\n# Don't do this - change not tracked\nfact[:value] = 90  # Rules won't re-fire\n\n# Instead, retract and re-add\nengine.remove_fact(fact)\nnew_fact = KBS::Fact.new(:temperature, value: 90)\nengine.add_fact(new_fact)\n</code></pre>"},{"location":"what-is-a-fact/#value-mutability-persistent-facts","title":"Value Mutability (Persistent Facts)","text":"<p>Persistent facts track updates but don't re-trigger rules:</p> <pre><code>fact = engine.add_fact(:temperature, value: 85)\n\n# This persists but doesn't re-fire rules\nfact[:value] = 90\n\n# To re-trigger rules, retract and re-add\nfact.retract\nnew_fact = engine.add_fact(:temperature, value: 90)\n</code></pre>"},{"location":"what-is-a-fact/#performance-considerations","title":"Performance Considerations","text":""},{"location":"what-is-a-fact/#fact-count-impact","title":"Fact Count Impact","text":"<ul> <li>RETE strength: Efficient with many facts and stable rules</li> <li>Alpha memories: Facts indexed by type</li> <li>Beta network: Partial matches cached as tokens</li> <li>Unlinking: Empty nodes deactivated automatically</li> </ul> <p>Scaling characteristics:</p> <ul> <li>10-1,000 facts: Excellent performance</li> <li>1,000-10,000 facts: Very good (alpha memory indexing helps)</li> <li>10,000-100,000 facts: Good (consider indexing strategies)</li> <li>100,000+ facts: Consider domain-specific optimizations</li> </ul>"},{"location":"what-is-a-fact/#attribute-count-impact","title":"Attribute Count Impact","text":"<p>Facts can have any number of attributes:</p> <pre><code># Small fact (fast)\nfact :flag, active: true\n\n# Medium fact (typical)\nfact :order,\n  id: 123,\n  customer_id: 456,\n  total: 99.99,\n  status: \"pending\"\n\n# Large fact (fine, but consider if all attributes needed)\nfact :trade,\n  symbol: \"AAPL\",\n  price: 150.25,\n  volume: 1000,\n  timestamp: Time.now,\n  order_id: 789,\n  account_id: 456,\n  commission: 1.50,\n  exchange: \"NASDAQ\",\n  # ... 20 more attributes\n</code></pre> <p>Guideline: Include attributes you'll pattern match on. Store auxiliary data in external systems if not needed for rules.</p>"},{"location":"what-is-a-fact/#pattern-complexity-impact","title":"Pattern Complexity Impact","text":"<pre><code># Fast - literal match (hash equality)\non :stock, symbol: \"AAPL\"\n\n# Medium - simple predicate\non :stock, price: -&gt;(p) { p &gt; 100 }\n\n# Slow - complex predicate (runs on every match attempt)\non :stock, price: -&gt;(p) {\n  historical_data = fetch_history(p)  # External call!\n  calculate_volatility(historical_data) &gt; threshold\n}\n</code></pre> <p>Guideline: Keep predicates simple. Do expensive checks in rule actions, not patterns.</p>"},{"location":"what-is-a-fact/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"what-is-a-fact/#1-forgetting-fact-type","title":"1. Forgetting Fact Type","text":"<pre><code># Wrong - no type\nfact = { location: \"server_room\", value: 85 }\n\n# Right - always include type\nfact :temperature, location: \"server_room\", value: 85\n</code></pre>"},{"location":"what-is-a-fact/#2-expecting-updates-to-re-trigger-rules","title":"2. Expecting Updates to Re-trigger Rules","text":"<pre><code>fact = engine.add_fact(:temperature, value: 85)\n\n# This rule fires\nrule \"high_temp\" do\n  on :temperature, value: greater_than(80)\n  perform { puts \"High!\" }\nend\n\n# Update doesn't re-fire rule\nfact[:value] = 90  # Rule doesn't fire again\n\n# Must retract and re-add to re-trigger\nfact.retract\nengine.add_fact(:temperature, value: 90)\nengine.run  # Now rule fires\n</code></pre>"},{"location":"what-is-a-fact/#3-side-effects-in-predicates","title":"3. Side Effects in Predicates","text":"<pre><code># Wrong - side effects\ncounter = 0\non :stock, price: -&gt;(p) {\n  counter += 1  # Bad! Runs on every match attempt\n  p &gt; 100\n}\n\n# Right - pure predicate\nthreshold = 100\non :stock, price: -&gt;(p) { p &gt; threshold }\n</code></pre>"},{"location":"what-is-a-fact/#4-missing-attributes-in-predicates","title":"4. Missing Attributes in Predicates","text":"<pre><code>fact = KBS::Fact.new(:stock, symbol: \"AAPL\")  # No :price\n\n# Fails - predicate can't evaluate nil\nfact.matches?(type: :stock, price: -&gt;(p) { p &gt; 100 })  # =&gt; false\n\n# Use variable to capture nil\nfact.matches?(type: :stock, price: :price?)  # =&gt; true (binds :price? =&gt; nil)\n</code></pre>"},{"location":"what-is-a-fact/#5-confusing-negation","title":"5. Confusing Negation","text":"<pre><code># Matches when NO critical alert EXISTS\nwithout :alert, level: \"critical\"\n\n# NOT the same as: Match alerts that aren't critical\n# For that, use:\non :alert, level: -&gt;(l) { l != \"critical\" }\n</code></pre>"},{"location":"what-is-a-fact/#best-practices","title":"Best Practices","text":""},{"location":"what-is-a-fact/#1-use-descriptive-fact-types","title":"1. Use Descriptive Fact Types","text":"<pre><code># Good - clear semantic meaning\nfact :temperature_reading, sensor_id: 42, value: 85\nfact :order_placed, order_id: 123, timestamp: Time.now\nfact :inventory_shortage, product_id: \"ABC\", deficit: 50\n\n# Avoid - vague types\nfact :data, type: \"temp\", id: 42, val: 85\nfact :event, kind: \"order\", timestamp: Time.now\n</code></pre>"},{"location":"what-is-a-fact/#2-include-identifying-attributes","title":"2. Include Identifying Attributes","text":"<pre><code># Good - can query and match specifically\nfact :sensor, id: 42, status: \"active\", location: \"room_1\"\nfact :order, id: 123, customer_id: 456, total: 99.99\n\n# Harder to work with - no unique identifier\nfact :sensor, status: \"active\"\n</code></pre>"},{"location":"what-is-a-fact/#3-add-timestamps-for-time-based-reasoning","title":"3. Add Timestamps for Time-Based Reasoning","text":"<pre><code>fact :temperature,\n  sensor_id: 42,\n  value: 85,\n  timestamp: Time.now\n\n# Enables rules like:\nrule \"stale_data\" do\n  on :temperature,\n    timestamp: -&gt;(ts) { Time.now - ts &gt; 300 }\n  perform { puts \"Stale data!\" }\nend\n</code></pre>"},{"location":"what-is-a-fact/#4-use-fact-types-to-model-domain","title":"4. Use Fact Types to Model Domain","text":"<p>Organize facts around your domain concepts:</p> <p>Stock Trading: <pre><code>fact :stock, symbol: \"AAPL\", price: 150, volume: 1_000_000\nfact :order, id: 123, type: \"buy\", shares: 100\nfact :position, symbol: \"AAPL\", shares: 500, cost_basis: 145\nfact :alert, level: \"high\", message: \"Price spike detected\"\n</code></pre></p> <p>IoT Monitoring: <pre><code>fact :sensor, id: 42, type: \"temperature\", location: \"server_1\"\nfact :reading, sensor_id: 42, value: 85, timestamp: Time.now\nfact :threshold, sensor_id: 42, max: 80, min: 60\nfact :alert, sensor_id: 42, severity: \"warning\"\n</code></pre></p>"},{"location":"what-is-a-fact/#5-keep-facts-focused","title":"5. Keep Facts Focused","text":"<p>One fact = one piece of knowledge</p> <pre><code># Good - focused facts\nfact :order, id: 123, status: \"pending\"\nfact :customer, id: 456, name: \"Acme\"\nfact :payment, order_id: 123, amount: 99.99\n\n# Avoid - bloated fact with everything\nfact :transaction,\n  order_id: 123,\n  customer_id: 456,\n  customer_name: \"Acme\",\n  payment_method: \"credit\",\n  # ... 30 more fields\n</code></pre>"},{"location":"what-is-a-fact/#further-reading","title":"Further Reading","text":"<ul> <li>Facts API Reference - Complete method documentation</li> <li>Pattern Matching Guide - Detailed matching semantics</li> <li>Variable Binding Guide - Join tests and captures</li> <li>Knowledge Base - How facts fit into knowledge bases</li> <li>RETE Algorithm - How facts are matched efficiently</li> </ul>"},{"location":"what-is-a-fact/#summary","title":"Summary","text":"<p>A fact is:</p> <ul> <li>The fundamental unit of knowledge in KBS</li> <li>A typed record with attributes (<code>:type</code> + <code>{key: value}</code>)</li> <li>Pattern-matchable using literals, predicates, and variables</li> <li>Available in both transient (fast, volatile) and persistent (durable, auditable) forms</li> <li>The \"data\" that rules reason about</li> </ul> <p>Think of facts as statements of truth that the knowledge base can automatically reason about and act upon.</p>"},{"location":"what-is-a-knowledge-base/","title":"What is a Knowledge Base?","text":"<p>A knowledge base in KBS is a container that holds facts (what you know) and rules (how to reason about what you know), providing automated inference and decision-making capabilities.</p>"},{"location":"what-is-a-knowledge-base/#core-concept","title":"Core Concept","text":"<p>Think of a knowledge base as a reasoning system that:</p> <ol> <li>Stores facts - Pieces of information about your domain (e.g., \"temperature is 85\u00b0F\", \"stock price is $150\")</li> <li>Defines rules - Patterns that trigger actions when facts match (e.g., \"IF temperature &gt; 80\u00b0F THEN alert\")</li> <li>Performs inference - Automatically detects when rules should fire and executes their actions</li> <li>Maintains consistency - Keeps track of what's true and propagates changes efficiently</li> </ol>"},{"location":"what-is-a-knowledge-base/#anatomy-of-a-knowledge-base","title":"Anatomy of a Knowledge Base","text":"<p>A knowledge base consists of three main components:</p>"},{"location":"what-is-a-knowledge-base/#1-facts-data","title":"1. Facts (Data)","text":"<p>Facts represent knowledge about your domain. Each fact has: - Type - Category of information (e.g., <code>:temperature</code>, <code>:stock</code>, <code>:sensor</code>) - Attributes - Key-value pairs describing the fact (e.g., <code>value: 85, location: \"server_room\"</code>)</p> <pre><code>kb.fact :temperature, value: 85, location: \"server_room\"\nkb.fact :stock, symbol: \"AAPL\", price: 150.25, volume: 1_200_000\nkb.fact :sensor, id: 42, status: \"active\"\n</code></pre>"},{"location":"what-is-a-knowledge-base/#2-rules-logic","title":"2. Rules (Logic)","text":"<p>Rules define IF-THEN patterns that trigger actions when facts match conditions:</p> <pre><code>rule \"high_temperature_alert\" do\n  # IF these conditions match...\n  on :temperature, value: greater_than(80), location: :loc?\n\n  # THEN execute this action\n  perform do |facts, bindings|\n    puts \"\u26a0\ufe0f  High temperature at #{bindings[:loc?]}\"\n    send_alert(bindings[:loc?])\n  end\nend\n</code></pre>"},{"location":"what-is-a-knowledge-base/#3-working-memory-state","title":"3. Working Memory (State)","text":"<p>Working memory holds the current set of active facts. As facts are added/removed, the RETE engine automatically:</p> <ul> <li>Matches facts against rule conditions</li> <li>Tracks partial matches</li> <li>Fires rules when all conditions are satisfied</li> </ul>"},{"location":"what-is-a-knowledge-base/#how-knowledge-bases-work","title":"How Knowledge Bases Work","text":""},{"location":"what-is-a-knowledge-base/#the-inference-cycle","title":"The Inference Cycle","text":"<p>The inference cycle continuously processes facts through pattern matching and rule firing until no more rules can fire.</p>"},{"location":"what-is-a-knowledge-base/#example-flow","title":"Example Flow","text":"<pre><code>kb = KBS.knowledge_base do\n  # Define rule\n  rule \"stock_alert\" do\n    on :stock, symbol: :sym?, price: greater_than(100)\n    perform do |facts, bindings|\n      puts \"#{bindings[:sym?]} is expensive!\"\n    end\n  end\n\n  # Add fact (triggers pattern matching)\n  fact :stock, symbol: \"AAPL\", price: 150\n\n  # Execute inference\n  run  # \u2192 Outputs: \"AAPL is expensive!\"\nend\n</code></pre>"},{"location":"what-is-a-knowledge-base/#knowledge-base-types","title":"Knowledge Base Types","text":"<p>KBS provides two implementations:</p>"},{"location":"what-is-a-knowledge-base/#1-in-memory-knowledge-base","title":"1. In-Memory Knowledge Base","text":"<p>Class: <code>KBS::DSL::KnowledgeBase</code> Created via: <code>KBS.knowledge_base do ... end</code></p> <p>Characteristics:</p> <ul> <li>\u2705 Fast - All data in RAM</li> <li>\u2705 Simple - No configuration needed</li> <li>\u2705 Perfect for: Short-lived processes, prototyping, testing</li> <li>\u26a0\ufe0f Volatile - Data lost when process ends</li> </ul> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  rule \"momentum_buy\" do\n    on :stock, price_change: greater_than(5)\n    perform { puts \"Strong momentum detected!\" }\n  end\n\n  fact :stock, symbol: \"NVDA\", price_change: 7.2\n  run\nend\n</code></pre></p>"},{"location":"what-is-a-knowledge-base/#2-blackboard-knowledge-base","title":"2. Blackboard Knowledge Base","text":"<p>Class: <code>KBS::Blackboard::Engine</code> Created via: <code>KBS::Blackboard::Engine.new</code></p> <p>Characteristics:</p> <ul> <li>\u2705 Persistent - Facts survive restarts</li> <li>\u2705 Auditable - Complete history of changes</li> <li>\u2705 Multi-agent - Supports concurrent reasoning</li> <li>\u2705 Flexible storage - SQLite, Redis, or Hybrid</li> <li>\u26a0\ufe0f Slower - I/O overhead</li> </ul> <p>Example: <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\nengine.add_rule(rule)\nengine.add_fact(:stock, symbol: \"AAPL\", price: 150)\nengine.run\n\n# Facts persist even after restart\n</code></pre></p>"},{"location":"what-is-a-knowledge-base/#key-differences-from-databases","title":"Key Differences from Databases","text":"Aspect Knowledge Base Database Purpose Reasoning &amp; inference Storage &amp; retrieval Operation Automatic rule firing Manual queries Logic Declarative rules Procedural code Updates Propagate through network Independent transactions Focus \"What should happen when...\" \"What data exists...\" <p>Example Comparison:</p> <pre><code># Database approach (manual logic)\nstocks = db.query(\"SELECT * FROM stocks WHERE price_change &gt; 5\")\nstocks.each do |stock|\n  if stock.volume &gt; 1_000_000\n    send_alert(stock.symbol)\n  end\nend\n\n# Knowledge base approach (declarative rules)\nkb.rule \"momentum_alert\" do\n  on :stock, price_change: greater_than(5), volume: greater_than(1_000_000)\n  perform { |facts, b| send_alert(b[:symbol?]) }\nend\nkb.run  # Automatically fires for all matching facts\n</code></pre>"},{"location":"what-is-a-knowledge-base/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"what-is-a-knowledge-base/#1-event-processing","title":"1. Event Processing","text":"<p>Monitor streams of events and trigger actions:</p> <pre><code>kb = KBS.knowledge_base do\n  rule \"sensor_timeout\" do\n    on :sensor, id: :sid?, expected: true\n    without :reading, sensor_id: :sid?  # No recent reading\n    perform { |facts, b| alert_timeout(b[:sid?]) }\n  end\n\n  # Events flow in\n  fact :sensor, id: 1, expected: true\n  fact :reading, sensor_id: 2, value: 42  # Sensor 1 has no reading!\n  run\nend\n</code></pre>"},{"location":"what-is-a-knowledge-base/#2-decision-support","title":"2. Decision Support","text":"<p>Encode business rules and compliance checks:</p> <pre><code>kb = KBS.knowledge_base do\n  rule \"approve_loan\" do\n    on :applicant, credit_score: greater_than(700), income: :income?\n    on :loan, amount: :amount?\n    perform do |facts, b|\n      if b[:income?] &gt; b[:amount?] * 0.3\n        approve_loan!\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"what-is-a-knowledge-base/#3-complex-event-detection","title":"3. Complex Event Detection","text":"<p>Find patterns across multiple related facts:</p> <pre><code>kb = KBS.knowledge_base do\n  rule \"golden_cross\" do\n    on :ma_50, value: :fast?\n    on :ma_200, value: :slow?\n    perform do |facts, b|\n      if b[:fast?] &gt; b[:slow?]\n        puts \"Golden cross detected - bullish signal\"\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"what-is-a-knowledge-base/#4-state-machine-management","title":"4. State Machine Management","text":"<p>Model workflows and state transitions:</p> <pre><code>kb = KBS.knowledge_base do\n  rule \"order_to_shipping\" do\n    on :order, id: :oid?, status: \"paid\"\n    on :inventory, available: greater_than(0)\n\n    perform do |facts, b|\n      order = query(:order, id: b[:oid?]).first\n      retract order\n      fact :order, id: b[:oid?], status: \"shipping\"\n    end\n  end\nend\n</code></pre>"},{"location":"what-is-a-knowledge-base/#relationship-to-other-components","title":"Relationship to Other Components","text":"<p>A knowledge base integrates several KBS components:</p> <p></p> <p>A knowledge base is composed of three layers: the DSL provides the user interface, working memory stores facts, and the RETE engine performs pattern matching and inference.</p>"},{"location":"what-is-a-knowledge-base/#when-to-use-a-knowledge-base","title":"When to Use a Knowledge Base","text":"<p>\u2705 Good fit:</p> <ul> <li>Complex business rules that change frequently</li> <li>Multi-condition pattern matching</li> <li>Event correlation and monitoring</li> <li>Expert systems and decision support</li> <li>Workflow and state machine management</li> <li>Real-time stream processing</li> </ul> <p>\u274c Not ideal for:</p> <ul> <li>Simple CRUD operations</li> <li>Pure data storage without logic</li> <li>High-throughput data pipelines (use specialized tools)</li> <li>When performance is more critical than maintainability</li> </ul>"},{"location":"what-is-a-knowledge-base/#advanced-concepts","title":"Advanced Concepts","text":""},{"location":"what-is-a-knowledge-base/#variable-binding-join-tests","title":"Variable Binding (Join Tests)","text":"<p>Variables link facts across multiple conditions:</p> <pre><code>rule \"order_fulfillment\" do\n  on :order, product_id: :pid?, quantity: :qty?\n  on :inventory, product_id: :pid?, available: :avail?\n  # :pid? creates a join - both facts must have same product_id\n\n  perform do |facts, b|\n    if b[:avail?] &gt;= b[:qty?]\n      ship_order(b[:pid?])\n    end\n  end\nend\n</code></pre>"},{"location":"what-is-a-knowledge-base/#negation-absence-testing","title":"Negation (Absence Testing)","text":"<p>Rules can fire based on missing facts:</p> <pre><code>rule \"missing_config\" do\n  on :system, initialized: true\n  without :config, loaded: true  # No config fact exists\n  perform { raise \"Configuration missing!\" }\nend\n</code></pre>"},{"location":"what-is-a-knowledge-base/#priority-control","title":"Priority Control","text":"<p>Control rule firing order (Blackboard only):</p> <pre><code>rule \"critical_alert\" do\n  priority 100  # High priority fires first\n  on :alert, level: \"critical\"\n  perform { shutdown_system! }\nend\n\nrule \"log_alert\" do\n  priority 1  # Low priority fires last\n  on :alert, level: :level?\n  perform { |facts, b| log(b[:level?]) }\nend\n</code></pre>"},{"location":"what-is-a-knowledge-base/#performance-considerations","title":"Performance Considerations","text":"<p>Knowledge bases excel when:</p> <ul> <li>Rules are stable (compiled once)</li> <li>Facts change frequently (efficient incremental matching)</li> <li>Multiple rules share patterns (network node sharing)</li> </ul> <p>Optimization Tips:</p> <ol> <li>Order conditions by selectivity - Most restrictive first</li> <li>Use specific patterns - <code>value: 85</code> better than <code>value: greater_than(0)</code></li> <li>Limit negations - Each negation adds overhead</li> <li>Batch fact additions - Add all facts, then call <code>run</code> once</li> <li>Use indices - Blackboard stores support indexed queries</li> </ol>"},{"location":"what-is-a-knowledge-base/#further-reading","title":"Further Reading","text":"<ul> <li>DSL Reference - Complete guide to defining rules</li> <li>RETE Algorithm - How pattern matching works</li> <li>Blackboard Architecture - Persistent knowledge bases</li> <li>Getting Started - Practical examples</li> <li>API Documentation - Class and method reference</li> </ul>"},{"location":"what-is-a-knowledge-base/#summary","title":"Summary","text":"<p>A knowledge base is:</p> <ul> <li>A container for facts (data) and rules (logic)</li> <li>An inference engine that automatically detects when rules should fire</li> <li>A declarative way to express \"IF these patterns exist THEN take this action\"</li> <li>Available in both in-memory (fast, volatile) and blackboard (persistent, auditable) implementations</li> </ul> <p>Think of it as a database that actively reasons about its contents rather than passively storing them.</p>"},{"location":"what-is-a-rule/","title":"What is a Rule?","text":"<p>A rule is a declarative IF-THEN statement that defines what action to take when certain patterns of facts exist in the knowledge base. Rules are the \"logic\" that operates on facts (the \"data\").</p>"},{"location":"what-is-a-rule/#core-concept","title":"Core Concept","text":"<p>Think of a rule as an automated detector and responder:</p> <ul> <li>IF these patterns exist in the knowledge base (conditions)</li> <li>THEN execute this action (perform block)</li> </ul> <p>Unlike procedural code that you explicitly call, rules automatically fire when their conditions are satisfied.</p>"},{"location":"what-is-a-rule/#anatomy-of-a-rule","title":"Anatomy of a Rule","text":""},{"location":"what-is-a-rule/#basic-structure","title":"Basic Structure","text":"<pre><code>rule \"high_temperature_alert\" do\n  # 1. METADATA (optional)\n  desc \"Alert when server room temperature exceeds safe threshold\"\n  priority 10\n\n  # 2. CONDITIONS (the IF part)\n  on :temperature, location: \"server_room\", value: greater_than(80)\n  on :sensor, location: \"server_room\", status: \"active\"\n\n  # 3. ACTION (the THEN part)\n  perform do |facts, bindings|\n    send_alert(\"High temperature: #{bindings[:value?]}\u00b0F\")\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#visual-representation","title":"Visual Representation","text":"<p>A rule consists of three parts: metadata (name, description, priority), conditions that must ALL match, and an action that executes when conditions are satisfied.</p>"},{"location":"what-is-a-rule/#how-rules-differ-from-other-programming-constructs","title":"How Rules Differ from Other Programming Constructs","text":"Aspect Rule Function/Method IF Statement Event Handler Invocation Automatic (pattern match) Manual (explicit call) Manual (in code flow) Event-driven (explicit bind) When When patterns exist When called When executed When event fires Conditions Declarative patterns Imperative checks Imperative checks Event type Ordering By priority/RETE Call sequence Code sequence Event sequence Scope All facts in KB Parameters passed Local variables Event payload <p>Example Comparison:</p> <pre><code># Function - Manual invocation\ndef check_temperature(temp)\n  if temp &gt; 80\n    send_alert(\"High temp: #{temp}\")\n  end\nend\ncheck_temperature(85)  # Must explicitly call\n\n# IF Statement - Part of code flow\ntemperature = sensor.read\nif temperature &gt; 80 &amp;&amp; sensor.active?\n  send_alert(\"High temp: #{temperature}\")\nend\n\n# Event Handler - Event binding\nsensor.on(:reading) do |temp|\n  if temp &gt; 80\n    send_alert(\"High temp: #{temp}\")\n  end\nend\n\n# Rule - Declarative, automatic\nrule \"high_temperature\" do\n  on :temperature, value: greater_than(80)\n  on :sensor, status: \"active\"\n  perform do |facts, bindings|\n    send_alert(\"High temp: #{bindings[:value?]}\")\n  end\nend\n# Fires automatically when facts match!\n</code></pre>"},{"location":"what-is-a-rule/#rule-lifecycle","title":"Rule Lifecycle","text":""},{"location":"what-is-a-rule/#1-definition","title":"1. Definition","text":"<p>Rules are defined using the DSL:</p> <pre><code>kb = KBS.knowledge_base do\n  rule \"golden_cross_signal\" do\n    on :ma_50, value: :fast?\n    on :ma_200, value: :slow?\n    perform do |facts, bindings|\n      if bindings[:fast?] &gt; bindings[:slow?]\n        puts \"Buy signal: Golden cross detected\"\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#2-compilation","title":"2. Compilation","text":"<p>When added to an engine, rules are compiled into a RETE network:</p> <pre><code>engine.add_rule(rule)\n# Rule compiled into discrimination network\n# - Alpha nodes for each pattern\n# - Join nodes to combine patterns\n# - Production node for action\n</code></pre>"},{"location":"what-is-a-rule/#3-activation","title":"3. Activation","text":"<p>As facts are added, the rule's conditions are evaluated:</p> <pre><code>engine.add_fact(:ma_50, value: 52.3)\nengine.add_fact(:ma_200, value: 51.8)\n# Conditions now satisfied - rule activated\n</code></pre>"},{"location":"what-is-a-rule/#4-firing","title":"4. Firing","text":"<p>During <code>engine.run</code>, activated rules fire:</p> <pre><code>engine.run\n# \u2192 \"Buy signal: Golden cross detected\"\n</code></pre>"},{"location":"what-is-a-rule/#5-completion","title":"5. Completion","text":"<p>Actions execute, potentially creating new facts:</p> <pre><code>perform do |facts, bindings|\n  # Can add derived facts\n  fact :signal, type: \"golden_cross\", timestamp: Time.now\n  # Can retract facts\n  retract old_signal\n  # Can call external code\n  execute_trade(bindings[:symbol?])\nend\n</code></pre>"},{"location":"what-is-a-rule/#rule-components-in-detail","title":"Rule Components in Detail","text":""},{"location":"what-is-a-rule/#metadata","title":"Metadata","text":"<p>Optional information about the rule:</p> <pre><code>rule \"fraud_detection\" do\n  desc \"Flag transactions with suspicious patterns\"\n  priority 100  # Higher priority = fires first (blackboard only)\n  # ... conditions and action\nend\n</code></pre> <p>Name - Unique identifier</p> <ul> <li>Should be descriptive and actionable</li> <li>Use snake_case</li> <li>Example: <code>\"reorder_low_inventory\"</code>, <code>\"escalate_critical_alert\"</code></li> </ul> <p>Description\u2014Human-readable explanation</p> <ul> <li>Documents the rule's purpose</li> <li>Helpful for debugging and maintenance</li> <li>Example: <code>\"Reorders products when inventory falls below minimum threshold\"</code></li> </ul> <p>Priority\u2014Execution order (0-100 typical)</p> <ul> <li>Only affects <code>KBS::Blackboard::Engine</code></li> <li>Higher numbers fire first</li> <li>Default: 0</li> </ul>"},{"location":"what-is-a-rule/#conditions-the-if-part","title":"Conditions (The IF Part)","text":"<p>Patterns that must ALL match for the rule to fire:</p> <pre><code>rule \"order_fulfillment\" do\n  # Condition 1: Must have pending order\n  on :order, status: \"pending\", product_id: :pid?, quantity: :qty?\n\n  # Condition 2: Must have inventory for same product\n  on :inventory, product_id: :pid?, available: :avail?\n  #                         ^^^^^^\n  #                    Join test - must match!\n\n  # Condition 3: Must NOT have existing shipment\n  without :shipment, order_id: :oid?\n\n  perform do |facts, bindings|\n    # Fires when ALL conditions satisfied\n  end\nend\n</code></pre> <p>Condition Types:</p> <ol> <li>Positive - Pattern must exist: <code>on :temperature, value: &gt; 80</code></li> <li>Negative - Pattern must NOT exist: <code>without :alert</code></li> <li>Join - Variables link conditions: <code>:pid?</code> in both conditions above</li> </ol>"},{"location":"what-is-a-rule/#action-the-then-part","title":"Action (The THEN Part)","text":"<p>Code executed when all conditions match:</p> <pre><code>perform do |facts, bindings|\n  # facts - Array of matched facts (in condition order)\n  # bindings - Hash of variable captures {:pid? =&gt; 123, :qty? =&gt; 5}\n\n  # Can access facts\n  order = facts[0]\n  inventory = facts[1]\n\n  # Can access bindings\n  product_id = bindings[:pid?]\n  quantity = bindings[:qty?]\n  available = bindings[:avail?]\n\n  # Can make decisions\n  if available &gt;= quantity\n    ship_order(order)\n  else\n    backorder(order)\n  end\n\n  # Can add facts\n  fact :shipment, order_id: order[:id], shipped_at: Time.now\n\n  # Can retract facts\n  retract order\n\n  # Can call external code\n  notify_customer(order[:customer_id])\nend\n</code></pre>"},{"location":"what-is-a-rule/#how-rules-work-the-inference-cycle","title":"How Rules Work: The Inference Cycle","text":"<p>Rules participate in an automatic reasoning loop:</p> <p></p> <p>Rules execute within a continuous inference cycle: facts are added, the RETE network matches patterns, activated rules fire and potentially create new facts, triggering another cycle. Inference completes when no new facts are generated.</p> <p>Example:</p> <pre><code>kb = KBS.knowledge_base do\n  # Rule 1: Detect high temperature\n  rule \"detect_high_temp\" do\n    on :temperature, value: greater_than(80), sensor_id: :sid?\n    without :alert, sensor_id: :sid?\n    perform do |facts, bindings|\n      # Add alert fact (triggers Rule 2)\n      fact :alert, sensor_id: bindings[:sid?], level: \"high\"\n    end\n  end\n\n  # Rule 2: Escalate alerts\n  rule \"escalate_alert\" do\n    on :alert, level: \"high\", sensor_id: :sid?\n    on :sensor, id: :sid?, critical: true\n    perform do |facts, bindings|\n      notify_ops(bindings[:sid?])\n    end\n  end\n\n  # Add facts\n  fact :temperature, value: 85, sensor_id: 42\n  fact :sensor, id: 42, critical: true\n\n  # Run inference\n  run\n  # \u2192 Rule 1 fires, creates :alert fact\n  # \u2192 Rule 2 fires (activated by new alert), notifies ops\nend\n</code></pre>"},{"location":"what-is-a-rule/#types-of-rules","title":"Types of Rules","text":""},{"location":"what-is-a-rule/#1-detection-rules","title":"1. Detection Rules","text":"<p>Identify patterns and generate alerts:</p> <pre><code>rule \"detect_fraud\" do\n  on :transaction, amount: greater_than(10_000)\n  on :account, new_account: true\n  perform { flag_for_review }\nend\n</code></pre>"},{"location":"what-is-a-rule/#2-derivation-rules","title":"2. Derivation Rules","text":"<p>Infer new facts from existing facts:</p> <pre><code>rule \"derive_momentum\" do\n  on :price, current: :curr?, previous: :prev?\n  perform do |facts, bindings|\n    change_pct = ((bindings[:curr?] - bindings[:prev?]) / bindings[:prev?]) * 100\n    fact :momentum, change_pct: change_pct\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#3-reaction-rules","title":"3. Reaction Rules","text":"<p>Take action when conditions arise:</p> <pre><code>rule \"reorder_inventory\" do\n  on :inventory, product_id: :pid?, quantity: less_than(10)\n  perform do |facts, bindings|\n    create_purchase_order(bindings[:pid?], quantity: 100)\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#4-state-machine-rules","title":"4. State Machine Rules","text":"<p>Manage transitions between states:</p> <pre><code>rule \"pending_to_processing\" do\n  on :order, id: :oid?, status: \"pending\"\n  on :worker, status: \"available\", id: :wid?\n  perform do |facts, bindings|\n    order = query(:order, id: bindings[:oid?]).first\n    retract order\n    fact :order, id: bindings[:oid?], status: \"processing\", worker_id: bindings[:wid?]\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#5-guard-rules","title":"5. Guard Rules","text":"<p>Prevent invalid states:</p> <pre><code>rule \"prevent_duplicate_orders\" do\n  on :order, customer_id: :cid?, product_id: :pid?, status: \"pending\"\n  on :order, customer_id: :cid?, product_id: :pid?, status: \"processing\"\n  perform do |facts, bindings|\n    cancel_duplicate_order(facts[0])\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#6-cleanup-rules","title":"6. Cleanup Rules","text":"<p>Remove obsolete facts:</p> <pre><code>rule \"expire_old_alerts\" do\n  on :alert, timestamp: -&gt;(ts) { Time.now - ts &gt; 3600 }\n  perform do |facts, bindings|\n    retract facts[0]\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#rule-patterns-and-best-practices","title":"Rule Patterns and Best Practices","text":""},{"location":"what-is-a-rule/#pattern-rule-chaining","title":"Pattern: Rule Chaining","text":"<p>Rules can trigger other rules:</p> <pre><code># Rule 1 creates fact that activates Rule 2\nrule \"detect_anomaly\" do\n  on :sensor, value: :val?\n  perform { fact :anomaly, value: bindings[:val?] }\nend\n\nrule \"escalate_anomaly\" do\n  on :anomaly, value: greater_than(100)\n  perform { send_alert }\nend\n</code></pre>"},{"location":"what-is-a-rule/#pattern-multi-condition-filtering","title":"Pattern: Multi-Condition Filtering","text":"<p>Combine multiple conditions to narrow matches:</p> <pre><code>rule \"qualified_lead\" do\n  on :customer, revenue: greater_than(100_000)\n  on :interaction, customer_id: :cid?, type: \"demo_request\"\n  on :product_fit, customer_id: :cid?, score: greater_than(80)\n  without :opportunity, customer_id: :cid?\n  perform { create_opportunity }\nend\n</code></pre>"},{"location":"what-is-a-rule/#pattern-exception-handling","title":"Pattern: Exception Handling","text":"<p>Use negation to ensure preconditions:</p> <pre><code>rule \"process_payment\" do\n  on :order, status: \"confirmed\"\n  without :payment, order_id: :oid?  # No payment yet\n  without :error, order_id: :oid?     # No errors\n  perform { charge_customer }\nend\n</code></pre>"},{"location":"what-is-a-rule/#pattern-temporal-rules","title":"Pattern: Temporal Rules","text":"<p>Time-aware reasoning:</p> <pre><code>rule \"stale_data_warning\" do\n  on :reading, timestamp: -&gt;(ts) { Time.now - ts &gt; 300 }, sensor_id: :sid?\n  perform do |facts, bindings|\n    alert(\"Stale data from sensor #{bindings[:sid?]}\")\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#pattern-aggregation","title":"Pattern: Aggregation","text":"<p>Collect and analyze multiple facts:</p> <pre><code>rule \"daily_summary\" do\n  on :trigger, event: \"end_of_day\"\n  perform do\n    temps = query(:temperature).map { |f| f[:value] }\n    avg = temps.sum / temps.size.to_f\n    fact :summary, avg_temp: avg, date: Date.today\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#rule-ordering-and-priority","title":"Rule Ordering and Priority","text":""},{"location":"what-is-a-rule/#priority-in-kbsblackboardengine","title":"Priority in KBS::Blackboard::Engine","text":"<p>Controls which rules fire first when multiple are activated:</p> <pre><code>rule \"critical_shutdown\", priority: 100 do\n  on :temperature, value: greater_than(120)\n  perform { emergency_shutdown! }\nend\n\nrule \"send_warning\", priority: 50 do\n  on :temperature, value: greater_than(80)\n  perform { send_warning_email }\nend\n\nrule \"log_reading\", priority: 10 do\n  on :temperature, value: :val?\n  perform { log(bindings[:val?]) }\nend\n\n# With temp = 125, fires in order:\n# 1. critical_shutdown (priority 100)\n# 2. send_warning (priority 50)\n# 3. log_reading (priority 10)\n</code></pre>"},{"location":"what-is-a-rule/#priority-in-kbsengine","title":"Priority in KBS::Engine","text":"<p>Priority is stored but not used for ordering - rules fire in arbitrary order.</p>"},{"location":"what-is-a-rule/#when-priority-matters","title":"When Priority Matters","text":"<p>Use priority for:</p> <ul> <li>Critical safety checks (priority 100)</li> <li>System integrity rules (priority 75)</li> <li>Business logic (priority 50)</li> <li>Logging and monitoring (priority 10)</li> </ul> <p>Don't rely on priority for:</p> <ul> <li>Sequencing actions (use fact dependencies instead)</li> <li>Enforcing order between independent rules</li> <li>Complex orchestration (use state machines)</li> </ul>"},{"location":"what-is-a-rule/#rules-vs-queries","title":"Rules vs. Queries","text":"<p>Rules are reactive (fire automatically), queries are proactive (you call them):</p> <pre><code># Rule - Automatic\nrule \"alert_on_high_temp\" do\n  on :temperature, value: greater_than(80)\n  perform { send_alert }  # Fires automatically\nend\n\n# Query - Manual\ntemps = query(:temperature, value: greater_than(80))\ntemps.each { |t| send_alert }  # You must iterate\n</code></pre> <p>When to use rules:</p> <ul> <li>Continuous monitoring</li> <li>Event-driven reactions</li> <li>Complex multi-condition patterns</li> <li>Automatic inference</li> </ul> <p>When to use queries:</p> <ul> <li>One-time lookups</li> <li>Reporting and analysis</li> <li>Interactive exploration</li> <li>When you need explicit control</li> </ul>"},{"location":"what-is-a-rule/#performance-considerations","title":"Performance Considerations","text":""},{"location":"what-is-a-rule/#rule-count","title":"Rule Count","text":"<ul> <li>10-100 rules: Excellent</li> <li>100-1,000 rules: Very good (network sharing helps)</li> <li>1,000+ rules: Good (consider grouping by domain)</li> </ul>"},{"location":"what-is-a-rule/#condition-count","title":"Condition Count","text":"<pre><code># Fast - 1-2 conditions\nrule \"simple\" do\n  on :stock, symbol: \"AAPL\"\n  perform { ... }\nend\n\n# Typical - 2-4 conditions\nrule \"moderate\" do\n  on :order, status: \"pending\"\n  on :inventory, available: greater_than(0)\n  on :customer, verified: true\n  perform { ... }\nend\n\n# Slower - 5+ conditions (but still efficient with RETE)\nrule \"complex\" do\n  on :order, ...\n  on :customer, ...\n  on :inventory, ...\n  on :pricing, ...\n  on :shipping, ...\n  perform { ... }\nend\n</code></pre>"},{"location":"what-is-a-rule/#condition-ordering-impact","title":"Condition Ordering Impact","text":"<p>Huge impact - order by selectivity:</p> <pre><code># Bad - general first (creates many partial matches)\non :sensor  # 1000 facts\non :alert, level: \"critical\"  # 1 fact\n# \u2192 1000 tokens created\n\n# Good - specific first (creates few partial matches)\non :alert, level: \"critical\"  # 1 fact\non :sensor  # 1000 facts\n# \u2192 1 token created\n</code></pre>"},{"location":"what-is-a-rule/#action-complexity","title":"Action Complexity","text":"<p>Keep actions lightweight:</p> <pre><code># Good - fast action\nperform do |facts, bindings|\n  fact :alert, level: \"high\"\nend\n\n# Acceptable - moderate work\nperform do |facts, bindings|\n  send_notification(bindings[:user_id?])\nend\n\n# Avoid - heavy work in action\nperform do |facts, bindings|\n  # Don't do this in action:\n  complex_calculation()\n  database_batch_update()\n  api_call_with_retry()\n  # Instead, add a fact to trigger async processing\n  fact :work_item, type: \"heavy_task\", data: bindings\nend\n</code></pre>"},{"location":"what-is-a-rule/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"what-is-a-rule/#1-forgetting-all-conditions-must-match","title":"1. Forgetting \"All Conditions Must Match\"","text":"<pre><code># This rule NEVER fires if there's no :inventory fact\nrule \"process_order\" do\n  on :order, status: \"pending\"\n  on :inventory, available: greater_than(0)  # What if no inventory fact?\n  perform { ship_order }\nend\n\n# Fix: Use negation or optional patterns\nrule \"process_order\" do\n  on :order, status: \"pending\"\n  without :inventory, available: less_than(1)  # OK if no inventory fact\n  perform { ship_order }\nend\n</code></pre>"},{"location":"what-is-a-rule/#2-expecting-sequential-execution","title":"2. Expecting Sequential Execution","text":"<pre><code># Rules don't execute in definition order\nrule \"step1\" do ... end\nrule \"step2\" do ... end  # NOT guaranteed to fire after step1\n\n# Use fact dependencies instead\nrule \"step1\" do\n  perform { fact :step1_complete }\nend\n\nrule \"step2\" do\n  on :step1_complete  # Depends on step1\n  perform { ... }\nend\n</code></pre>"},{"location":"what-is-a-rule/#3-infinite-loops","title":"3. Infinite Loops","text":"<pre><code># Bad - creates infinite loop\nrule \"loop\" do\n  on :counter, value: :val?\n  perform do |facts, bindings|\n    # Retracts and re-adds fact \u2192 rule fires again \u2192 infinite loop!\n    retract facts[0]\n    fact :counter, value: bindings[:val?] + 1\n  end\nend\n\n# Fix: Add termination condition\nrule \"loop\" do\n  on :counter, value: less_than(10)\n  perform do |facts, bindings|\n    retract facts[0]\n    fact :counter, value: bindings[:val?] + 1\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#4-side-effects-in-conditions","title":"4. Side Effects in Conditions","text":"<pre><code># Wrong - side effects in predicate\ncounter = 0\non :stock, price: -&gt;(p) {\n  counter += 1  # Bad! Runs many times\n  p &gt; 100\n}\n\n# Right - side effects in action\non :stock, price: greater_than(100)\nperform { counter += 1 }\n</code></pre>"},{"location":"what-is-a-rule/#5-modifying-facts-instead-of-retracting","title":"5. Modifying Facts Instead of Retracting","text":"<pre><code># Wrong - changes don't trigger rules\nfact = engine.facts.first\nfact[:status] = \"processed\"  # No rules fire\n\n# Right - retract and re-add\nretract old_fact\nfact :order, status: \"processed\"  # Rules fire\n</code></pre>"},{"location":"what-is-a-rule/#testing-rules","title":"Testing Rules","text":""},{"location":"what-is-a-rule/#unit-testing","title":"Unit Testing","text":"<p>Test rules in isolation:</p> <pre><code>def test_high_temp_alert\n  kb = KBS.knowledge_base do\n    rule \"alert\" do\n      on :temperature, value: greater_than(80)\n      perform { fact :alert, level: \"high\" }\n    end\n\n    fact :temperature, value: 85\n    run\n  end\n\n  alerts = kb.query(:alert)\n  assert_equal 1, alerts.size\n  assert_equal \"high\", alerts.first[:level]\nend\n</code></pre>"},{"location":"what-is-a-rule/#integration-testing","title":"Integration Testing","text":"<p>Test rule interactions:</p> <pre><code>def test_alert_escalation\n  kb = KBS.knowledge_base do\n    rule \"create_alert\" do\n      on :temperature, value: greater_than(80)\n      perform { fact :alert, level: \"high\" }\n    end\n\n    rule \"escalate_alert\" do\n      on :alert, level: \"high\"\n      on :sensor, critical: true\n      perform { fact :escalation, priority: \"urgent\" }\n    end\n\n    fact :temperature, value: 85\n    fact :sensor, critical: true\n    run\n  end\n\n  assert kb.query(:alert).any?\n  assert kb.query(:escalation).any?\nend\n</code></pre>"},{"location":"what-is-a-rule/#rule-design-principles","title":"Rule Design Principles","text":""},{"location":"what-is-a-rule/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>One rule, one purpose:</p> <pre><code># Good\u2014focused\nrule \"reorder_low_inventory\" do\n  on :inventory, quantity: less_than(10)\n  perform { create_purchase_order }\nend\n\n# Bad\u2014does too much\nrule \"inventory_management\" do\n  on :inventory\n  perform do\n    check_quantity\n    update_forecasts\n    notify_suppliers\n    generate_reports\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#2-declarative-over-imperative","title":"2. Declarative Over Imperative","text":"<p>Express what, not how:</p> <pre><code># Good\u2014declarative\nrule \"qualified_customer\" do\n  on :customer, revenue: greater_than(100_000)\n  on :engagement, score: greater_than(80)\n  perform { create_opportunity }\nend\n\n# Less ideal\u2014imperative\nrule \"check_customer\" do\n  on :customer\n  perform do |facts|\n    if facts[0][:revenue] &gt; 100_000\n      engagement = query(:engagement, customer_id: facts[0][:id]).first\n      if engagement &amp;&amp; engagement[:score] &gt; 80\n        create_opportunity\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"what-is-a-rule/#3-explicit-over-implicit","title":"3. Explicit Over Implicit","text":"<p>Make conditions explicit:</p> <pre><code># Good\u2014clear dependencies\nrule \"ship_order\" do\n  on :order, status: \"paid\"\n  on :inventory, available: greater_than(0)\n  without :shipment  # Explicit: no existing shipment\n  perform { ship }\nend\n\n# Bad\u2014hidden assumptions\nrule \"ship_order\" do\n  on :order, status: \"paid\"\n  perform { ship }  # Implicitly assumes inventory exists\nend\n</code></pre>"},{"location":"what-is-a-rule/#further-reading","title":"Further Reading","text":"<ul> <li>Writing Rules Guide - Detailed best practices</li> <li>Rules API Reference - Complete method documentation</li> <li>DSL Reference - Rule definition syntax</li> <li>Pattern Matching - Condition patterns</li> <li>RETE Algorithm - How rules are compiled and executed</li> </ul>"},{"location":"what-is-a-rule/#summary","title":"Summary","text":"<p>A rule is:</p> <ul> <li>A declarative IF-THEN statement that automatically fires when patterns match</li> <li>Composed of conditions (patterns to match) and action (code to execute)</li> <li>Automatically activated by the RETE engine when facts satisfy conditions</li> <li>The \"logic\" that operates on facts (the \"data\") in a knowledge base</li> <li>Available with optional priority for execution ordering (blackboard only)</li> </ul> <p>Think of rules as automated sentinels that continuously watch for specific patterns and react instantly when those patterns appear.</p>"},{"location":"advanced/","title":"Advanced Topics","text":"<p>techniques and optimizations.</p> <ul> <li>Performance Tuning - Optimize for production</li> <li>Custom Persistence - Build your own backend</li> <li>Debugging - Network inspection and tracing</li> <li>Testing Rules - Test strategies for rule-based systems</li> </ul>"},{"location":"advanced/custom-persistence/","title":"Custom Persistence","text":"<p>Implement custom storage backends for KBS by extending the <code>Store</code> interface. This guide covers implementing, testing, and optimizing custom persistence layers for PostgreSQL, MongoDB, or other databases.</p>"},{"location":"advanced/custom-persistence/#store-interface","title":"Store Interface","text":"<p>Custom stores must implement the <code>KBS::Blackboard::Persistence::Store</code> interface:</p> <pre><code>module KBS\n  module Blackboard\n    module Persistence\n      class Store\n        # Fact Operations\n        def save_fact(fact)\n          raise NotImplementedError\n        end\n\n        def load_facts(type = nil)\n          raise NotImplementedError\n        end\n\n        def update_fact(fact_id, attributes)\n          raise NotImplementedError\n        end\n\n        def delete_fact(fact_id)\n          raise NotImplementedError\n        end\n\n        # Message Queue Operations\n        def send_message(topic, content, priority:)\n          raise NotImplementedError\n        end\n\n        def pop_message(topic)\n          raise NotImplementedError\n        end\n\n        # Audit Operations\n        def log_fact_change(operation, fact, attributes = {})\n          raise NotImplementedError\n        end\n\n        def fact_history(fact_id)\n          raise NotImplementedError\n        end\n\n        def log_rule_firing(rule_name, fact_ids, bindings)\n          raise NotImplementedError\n        end\n\n        def rule_firings(rule_name: nil, limit: 100)\n          raise NotImplementedError\n        end\n\n        # Transaction Operations (optional)\n        def transaction\n          yield\n        end\n\n        def close\n          # Cleanup resources\n        end\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#postgresql-store","title":"PostgreSQL Store","text":""},{"location":"advanced/custom-persistence/#implementation","title":"Implementation","text":"<pre><code>require 'pg'\nrequire 'json'\n\nclass PostgresStore &lt; KBS::Blackboard::Persistence::Store\n  def initialize(connection_string:)\n    @conn = PG.connect(connection_string)\n    setup_tables\n  end\n\n  def setup_tables\n    @conn.exec &lt;&lt;~SQL\n      CREATE TABLE IF NOT EXISTS facts (\n        id UUID PRIMARY KEY,\n        fact_type VARCHAR(255) NOT NULL,\n        attributes JSONB NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW(),\n        updated_at TIMESTAMP DEFAULT NOW()\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_facts_type ON facts(fact_type);\n      CREATE INDEX IF NOT EXISTS idx_facts_attributes ON facts USING gin(attributes);\n\n      CREATE TABLE IF NOT EXISTS messages (\n        id SERIAL PRIMARY KEY,\n        topic VARCHAR(255) NOT NULL,\n        content JSONB NOT NULL,\n        priority INTEGER NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW()\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_messages_topic_priority\n        ON messages(topic, priority DESC);\n\n      CREATE TABLE IF NOT EXISTS audit_log (\n        id SERIAL PRIMARY KEY,\n        fact_id UUID NOT NULL,\n        operation VARCHAR(50) NOT NULL,\n        attributes JSONB,\n        timestamp TIMESTAMP DEFAULT NOW()\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_audit_fact_id ON audit_log(fact_id);\n\n      CREATE TABLE IF NOT EXISTS rule_firings (\n        id SERIAL PRIMARY KEY,\n        rule_name VARCHAR(255) NOT NULL,\n        fact_ids UUID[] NOT NULL,\n        bindings JSONB NOT NULL,\n        timestamp TIMESTAMP DEFAULT NOW()\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_rule_firings_name ON rule_firings(rule_name);\n    SQL\n  end\n\n  # Fact Operations\n\n  def save_fact(fact)\n    @conn.exec_params(\n      \"INSERT INTO facts (id, fact_type, attributes) VALUES ($1, $2, $3)\",\n      [fact.id, fact.type.to_s, fact.attributes.to_json]\n    )\n\n    log_fact_change('add', fact, fact.attributes)\n    fact\n  end\n\n  def load_facts(type = nil)\n    query = if type\n      @conn.exec_params(\n        \"SELECT id, fact_type, attributes, created_at FROM facts WHERE fact_type = $1\",\n        [type.to_s]\n      )\n    else\n      @conn.exec(\"SELECT id, fact_type, attributes, created_at FROM facts\")\n    end\n\n    query.map do |row|\n      KBS::Blackboard::Fact.new(\n        row['fact_type'].to_sym,\n        JSON.parse(row['attributes'], symbolize_names: true),\n        id: row['id'],\n        created_at: Time.parse(row['created_at'])\n      )\n    end\n  end\n\n  def update_fact(fact_id, attributes)\n    @conn.exec_params(\n      \"UPDATE facts SET attributes = $1, updated_at = NOW() WHERE id = $2\",\n      [attributes.to_json, fact_id]\n    )\n\n    log_fact_change('update', fact_id, attributes)\n  end\n\n  def delete_fact(fact_id)\n    result = @conn.exec_params(\n      \"DELETE FROM facts WHERE id = $1 RETURNING attributes\",\n      [fact_id]\n    )\n\n    if result.ntuples &gt; 0\n      attrs = JSON.parse(result[0]['attributes'], symbolize_names: true)\n      log_fact_change('delete', fact_id, attrs)\n    end\n  end\n\n  # Message Queue Operations\n\n  def send_message(topic, content, priority:)\n    @conn.exec_params(\n      \"INSERT INTO messages (topic, content, priority) VALUES ($1, $2, $3)\",\n      [topic.to_s, content.to_json, priority]\n    )\n  end\n\n  def pop_message(topic)\n    # Atomic pop using DELETE RETURNING\n    result = @conn.exec_params(&lt;&lt;~SQL, [topic.to_s])\n      DELETE FROM messages\n      WHERE id = (\n        SELECT id FROM messages\n        WHERE topic = $1\n        ORDER BY priority DESC, created_at ASC\n        LIMIT 1\n        FOR UPDATE SKIP LOCKED\n      )\n      RETURNING content, priority\n    SQL\n\n    return nil if result.ntuples == 0\n\n    {\n      content: JSON.parse(result[0]['content'], symbolize_names: true),\n      priority: result[0]['priority'].to_i\n    }\n  end\n\n  # Audit Operations\n\n  def log_fact_change(operation, fact_or_id, attributes)\n    fact_id = fact_or_id.is_a?(String) ? fact_or_id : fact_or_id.id\n\n    @conn.exec_params(\n      \"INSERT INTO audit_log (fact_id, operation, attributes) VALUES ($1, $2, $3)\",\n      [fact_id, operation, attributes.to_json]\n    )\n  end\n\n  def fact_history(fact_id)\n    result = @conn.exec_params(\n      \"SELECT operation, attributes, timestamp FROM audit_log WHERE fact_id = $1 ORDER BY timestamp\",\n      [fact_id]\n    )\n\n    result.map do |row|\n      {\n        operation: row['operation'],\n        attributes: JSON.parse(row['attributes'], symbolize_names: true),\n        timestamp: Time.parse(row['timestamp'])\n      }\n    end\n  end\n\n  def log_rule_firing(rule_name, fact_ids, bindings)\n    @conn.exec_params(\n      \"INSERT INTO rule_firings (rule_name, fact_ids, bindings) VALUES ($1, $2, $3)\",\n      [rule_name, \"{#{fact_ids.join(',')}}\", bindings.to_json]\n    )\n  end\n\n  def rule_firings(rule_name: nil, limit: 100)\n    query = if rule_name\n      @conn.exec_params(\n        \"SELECT rule_name, fact_ids, bindings, timestamp FROM rule_firings WHERE rule_name = $1 ORDER BY timestamp DESC LIMIT $2\",\n        [rule_name, limit]\n      )\n    else\n      @conn.exec_params(\n        \"SELECT rule_name, fact_ids, bindings, timestamp FROM rule_firings ORDER BY timestamp DESC LIMIT $1\",\n        [limit]\n      )\n    end\n\n    query.map do |row|\n      {\n        rule_name: row['rule_name'],\n        fact_ids: row['fact_ids'].gsub(/[{}]/, '').split(','),\n        bindings: JSON.parse(row['bindings'], symbolize_names: true),\n        timestamp: Time.parse(row['timestamp'])\n      }\n    end\n  end\n\n  # Transaction Support\n\n  def transaction\n    @conn.exec(\"BEGIN\")\n    yield\n    @conn.exec(\"COMMIT\")\n  rescue =&gt; e\n    @conn.exec(\"ROLLBACK\")\n    raise e\n  end\n\n  def close\n    @conn.close if @conn\n  end\nend\n\n# Usage\nstore = PostgresStore.new(\n  connection_string: \"postgresql://localhost/kbs_production\"\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre>"},{"location":"advanced/custom-persistence/#mongodb-store","title":"MongoDB Store","text":""},{"location":"advanced/custom-persistence/#implementation_1","title":"Implementation","text":"<pre><code>require 'mongo'\nrequire 'securerandom'\n\nclass MongoStore &lt; KBS::Blackboard::Persistence::Store\n  def initialize(url:, database: 'kbs')\n    @client = Mongo::Client.new(url)\n    @db = @client.use(database)\n    setup_collections\n  end\n\n  def setup_collections\n    # Facts collection\n    @facts = @db[:facts]\n    @facts.indexes.create_one({ fact_type: 1 })\n    @facts.indexes.create_one({ created_at: 1 })\n\n    # Messages collection\n    @messages = @db[:messages]\n    @messages.indexes.create_one({ topic: 1, priority: -1, created_at: 1 })\n\n    # Audit log\n    @audit = @db[:audit_log]\n    @audit.indexes.create_one({ fact_id: 1, timestamp: 1 })\n\n    # Rule firings\n    @rule_firings = @db[:rule_firings]\n    @rule_firings.indexes.create_one({ rule_name: 1, timestamp: -1 })\n  end\n\n  # Fact Operations\n\n  def save_fact(fact)\n    doc = {\n      _id: fact.id,\n      fact_type: fact.type.to_s,\n      attributes: fact.attributes,\n      created_at: Time.now,\n      updated_at: Time.now\n    }\n\n    @facts.insert_one(doc)\n\n    log_fact_change('add', fact, fact.attributes)\n    fact\n  end\n\n  def load_facts(type = nil)\n    query = type ? { fact_type: type.to_s } : {}\n\n    @facts.find(query).map do |doc|\n      KBS::Blackboard::Fact.new(\n        doc['fact_type'].to_sym,\n        doc['attributes'].transform_keys(&amp;:to_sym),\n        id: doc['_id'],\n        created_at: doc['created_at']\n      )\n    end\n  end\n\n  def update_fact(fact_id, attributes)\n    @facts.update_one(\n      { _id: fact_id },\n      { '$set' =&gt; { attributes: attributes, updated_at: Time.now } }\n    )\n\n    log_fact_change('update', fact_id, attributes)\n  end\n\n  def delete_fact(fact_id)\n    doc = @facts.find_one_and_delete({ _id: fact_id })\n\n    if doc\n      log_fact_change('delete', fact_id, doc['attributes'])\n    end\n  end\n\n  # Message Queue Operations\n\n  def send_message(topic, content, priority:)\n    @messages.insert_one({\n      topic: topic.to_s,\n      content: content,\n      priority: priority,\n      created_at: Time.now\n    })\n  end\n\n  def pop_message(topic)\n    # Find highest priority message\n    doc = @messages.find_one_and_delete(\n      { topic: topic.to_s },\n      sort: { priority: -1, created_at: 1 }\n    )\n\n    return nil unless doc\n\n    {\n      content: doc['content'].transform_keys(&amp;:to_sym),\n      priority: doc['priority']\n    }\n  end\n\n  # Audit Operations\n\n  def log_fact_change(operation, fact_or_id, attributes)\n    fact_id = fact_or_id.is_a?(String) ? fact_or_id : fact_or_id.id\n\n    @audit.insert_one({\n      fact_id: fact_id,\n      operation: operation,\n      attributes: attributes,\n      timestamp: Time.now\n    })\n  end\n\n  def fact_history(fact_id)\n    @audit.find({ fact_id: fact_id })\n          .sort(timestamp: 1)\n          .map do |doc|\n      {\n        operation: doc['operation'],\n        attributes: doc['attributes'].transform_keys(&amp;:to_sym),\n        timestamp: doc['timestamp']\n      }\n    end\n  end\n\n  def log_rule_firing(rule_name, fact_ids, bindings)\n    @rule_firings.insert_one({\n      rule_name: rule_name,\n      fact_ids: fact_ids,\n      bindings: bindings,\n      timestamp: Time.now\n    })\n  end\n\n  def rule_firings(rule_name: nil, limit: 100)\n    query = rule_name ? { rule_name: rule_name } : {}\n\n    @rule_firings.find(query)\n                 .sort(timestamp: -1)\n                 .limit(limit)\n                 .map do |doc|\n      {\n        rule_name: doc['rule_name'],\n        fact_ids: doc['fact_ids'],\n        bindings: doc['bindings'].transform_keys(&amp;:to_sym),\n        timestamp: doc['timestamp']\n      }\n    end\n  end\n\n  # Transaction Support (MongoDB 4.0+)\n\n  def transaction\n    session = @client.start_session\n\n    session.with_transaction do\n      yield\n    end\n  ensure\n    session.end_session if session\n  end\n\n  def close\n    @client.close if @client\n  end\nend\n\n# Usage\nstore = MongoStore.new(\n  url: 'mongodb://localhost:27017',\n  database: 'kbs_production'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre>"},{"location":"advanced/custom-persistence/#testing-custom-stores","title":"Testing Custom Stores","text":""},{"location":"advanced/custom-persistence/#test-suite","title":"Test Suite","text":"<pre><code>require 'minitest/autorun'\n\nclass TestCustomStore &lt; Minitest::Test\n  def setup\n    @store = MyCustomStore.new\n  end\n\n  def teardown\n    @store.close\n  end\n\n  def test_save_and_load_facts\n    fact = KBS::Blackboard::Fact.new(:test, { value: 42 })\n\n    @store.save_fact(fact)\n    loaded = @store.load_facts(:test)\n\n    assert_equal 1, loaded.size\n    assert_equal 42, loaded.first[:value]\n  end\n\n  def test_load_facts_by_type\n    @store.save_fact(KBS::Blackboard::Fact.new(:type_a, { value: 1 }))\n    @store.save_fact(KBS::Blackboard::Fact.new(:type_b, { value: 2 }))\n\n    type_a_facts = @store.load_facts(:type_a)\n\n    assert_equal 1, type_a_facts.size\n    assert_equal :type_a, type_a_facts.first.type\n  end\n\n  def test_update_fact\n    fact = KBS::Blackboard::Fact.new(:test, { value: 1 })\n    @store.save_fact(fact)\n\n    @store.update_fact(fact.id, { value: 2 })\n\n    loaded = @store.load_facts(:test)\n    assert_equal 2, loaded.first[:value]\n  end\n\n  def test_delete_fact\n    fact = KBS::Blackboard::Fact.new(:test, { value: 1 })\n    @store.save_fact(fact)\n\n    @store.delete_fact(fact.id)\n\n    loaded = @store.load_facts(:test)\n    assert_empty loaded\n  end\n\n  def test_message_queue\n    @store.send_message(:alerts, { text: \"High priority\" }, priority: 100)\n    @store.send_message(:alerts, { text: \"Low priority\" }, priority: 10)\n\n    # Pop should return highest priority\n    msg = @store.pop_message(:alerts)\n\n    assert_equal \"High priority\", msg[:content][:text]\n    assert_equal 100, msg[:priority]\n\n    # Next pop gets lower priority\n    msg = @store.pop_message(:alerts)\n    assert_equal \"Low priority\", msg[:content][:text]\n  end\n\n  def test_message_queue_empty\n    msg = @store.pop_message(:nonexistent)\n    assert_nil msg\n  end\n\n  def test_fact_audit_trail\n    fact = KBS::Blackboard::Fact.new(:test, { value: 1 })\n\n    @store.save_fact(fact)\n    @store.update_fact(fact.id, { value: 2 })\n    @store.delete_fact(fact.id)\n\n    history = @store.fact_history(fact.id)\n\n    assert_equal 3, history.size\n    assert_equal \"add\", history[0][:operation]\n    assert_equal \"update\", history[1][:operation]\n    assert_equal \"delete\", history[2][:operation]\n  end\n\n  def test_rule_firing_log\n    @store.log_rule_firing(\"test_rule\", [\"fact1\", \"fact2\"], { var: :value })\n\n    firings = @store.rule_firings(rule_name: \"test_rule\")\n\n    assert_equal 1, firings.size\n    assert_equal \"test_rule\", firings.first[:rule_name]\n    assert_equal [\"fact1\", \"fact2\"], firings.first[:fact_ids]\n  end\n\n  def test_transactions\n    fact1 = KBS::Blackboard::Fact.new(:test, { value: 1 })\n    fact2 = KBS::Blackboard::Fact.new(:test, { value: 2 })\n\n    # Successful transaction\n    @store.transaction do\n      @store.save_fact(fact1)\n      @store.save_fact(fact2)\n    end\n\n    assert_equal 2, @store.load_facts(:test).size\n\n    # Failed transaction\n    begin\n      @store.transaction do\n        @store.save_fact(KBS::Blackboard::Fact.new(:test, { value: 3 }))\n        raise \"Rollback!\"\n      end\n    rescue\n      # Expected\n    end\n\n    # Should still be 2 facts (transaction rolled back)\n    assert_equal 2, @store.load_facts(:test).size\n  end\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/custom-persistence/#1-connection-pooling","title":"1. Connection Pooling","text":"<pre><code>class PooledPostgresStore &lt; PostgresStore\n  def initialize(connection_string:, pool_size: 10)\n    @pool = ConnectionPool.new(size: pool_size) do\n      PG.connect(connection_string)\n    end\n\n    # Setup using one connection\n    @pool.with { |conn| setup_tables_with_conn(conn) }\n  end\n\n  def save_fact(fact)\n    @pool.with do |conn|\n      conn.exec_params(\n        \"INSERT INTO facts (id, fact_type, attributes) VALUES ($1, $2, $3)\",\n        [fact.id, fact.type.to_s, fact.attributes.to_json]\n      )\n    end\n\n    fact\n  end\n\n  # ... other methods using @pool.with { |conn| ... }\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>def save_facts(facts)\n  @conn.exec(\"BEGIN\")\n\n  facts.each do |fact|\n    save_fact(fact)\n  end\n\n  @conn.exec(\"COMMIT\")\nrescue =&gt; e\n  @conn.exec(\"ROLLBACK\")\n  raise e\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#3-indexing","title":"3. Indexing","text":"<pre><code>def optimize_indexes\n  # Add indexes for common queries\n  @conn.exec(&lt;&lt;~SQL)\n    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_facts_created\n      ON facts(created_at DESC);\n\n    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_messages_topic_priority\n      ON messages(topic, priority DESC)\n      WHERE topic IN ('alerts', 'critical');\n\n    -- JSONB indexes for attribute queries\n    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_facts_value\n      ON facts((attributes-&gt;&gt;'value'));\n  SQL\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#4-caching","title":"4. Caching","text":"<pre><code>class CachedStore &lt; KBS::Blackboard::Persistence::Store\n  def initialize(underlying_store, cache_ttl: 300)\n    @store = underlying_store\n    @cache = {}\n    @cache_ttl = cache_ttl\n  end\n\n  def load_facts(type = nil)\n    cache_key = \"facts:#{type}\"\n\n    if cached = @cache[cache_key]\n      return cached[:data] if Time.now - cached[:timestamp] &lt; @cache_ttl\n    end\n\n    facts = @store.load_facts(type)\n\n    @cache[cache_key] = {\n      data: facts,\n      timestamp: Time.now\n    }\n\n    facts\n  end\n\n  def save_fact(fact)\n    result = @store.save_fact(fact)\n\n    # Invalidate cache\n    @cache.delete(\"facts:#{fact.type}\")\n    @cache.delete(\"facts:\")\n\n    result\n  end\n\n  # Delegate other methods\n  def method_missing(method, *args, &amp;block)\n    @store.send(method, *args, &amp;block)\n  end\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-persistence/#1-handle-errors-gracefully","title":"1. Handle Errors Gracefully","text":"<pre><code>def save_fact(fact)\n  retries = 0\n\n  begin\n    @conn.exec_params(...)\n  rescue PG::ConnectionBad =&gt; e\n    retries += 1\n\n    if retries &lt; 3\n      reconnect\n      retry\n    else\n      raise e\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#2-use-prepared-statements","title":"2. Use Prepared Statements","text":"<pre><code>def initialize(connection_string:)\n  super\n  @conn.prepare('save_fact',\n    \"INSERT INTO facts (id, fact_type, attributes) VALUES ($1, $2, $3)\")\nend\n\ndef save_fact(fact)\n  @conn.exec_prepared('save_fact', [fact.id, fact.type.to_s, fact.attributes.to_json])\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#3-implement-health-checks","title":"3. Implement Health Checks","text":"<pre><code>def healthy?\n  @conn.exec(\"SELECT 1\")\n  true\nrescue =&gt; e\n  false\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#next-steps","title":"Next Steps","text":"<ul> <li>Persistence Guide - Choosing backends</li> <li>Testing Guide - Testing custom stores</li> <li>Performance Guide - Optimizing queries</li> <li>API Reference - Complete API documentation</li> </ul> <p>Custom stores enable KBS to work with any database. Implement the Store interface and test thoroughly.</p>"},{"location":"advanced/debugging/","title":"Debugging","text":"<p>Debug KBS applications using network visualization, token tracing, fact inspection, and rule execution logging. This guide provides tools and techniques to understand rule behavior and diagnose issues.</p>"},{"location":"advanced/debugging/#debugging-overview","title":"Debugging Overview","text":"<p>Common debugging scenarios:</p> <ol> <li>Rules not firing - Conditions don't match expected facts</li> <li>Unexpected rule firing - Rules fire when they shouldn't</li> <li>Performance issues - Slow rule execution</li> <li>Incorrect bindings - Variables bound to wrong values</li> <li>Network structure - Understanding compilation</li> </ol>"},{"location":"advanced/debugging/#enable-debug-output","title":"Enable Debug Output","text":""},{"location":"advanced/debugging/#basic-logging","title":"Basic Logging","text":"<pre><code>require 'kbs'\n\nengine = KBS::Engine.new\n\n# Enable debug output\nengine.instance_variable_set(:@debug, true)\n\n# Or create debug wrapper\nclass DebugEngine &lt; KBS::Engine\n  def add_fact(type, attributes = {})\n    fact = super\n    puts \"[FACT ADDED] #{fact.type}: #{fact.attributes.inspect}\"\n    fact\n  end\n\n  def remove_fact(fact)\n    puts \"[FACT REMOVED] #{fact.type}: #{fact.attributes.inspect}\"\n    super\n  end\nend\n</code></pre>"},{"location":"advanced/debugging/#rule-execution-logging","title":"Rule Execution Logging","text":"<pre><code>class LoggingEngine &lt; KBS::Engine\n  def initialize\n    super\n    @rule_log = []\n  end\n\n  def run\n    puts \"\\n=== Engine Run Started ===\"\n    puts \"Facts: #{facts.size}\"\n    puts \"Rules: #{@rules.size}\"\n\n    result = super\n\n    puts \"\\n=== Engine Run Completed ===\"\n    puts \"Rules fired: #{@rule_log.size}\"\n    @rule_log.each_with_index do |entry, i|\n      puts \"  #{i + 1}. #{entry[:rule]} (#{entry[:timestamp]})\"\n    end\n\n    result\n  end\n\n  attr_reader :rule_log\nend\n</code></pre>"},{"location":"advanced/debugging/#fact-inspection","title":"Fact Inspection","text":""},{"location":"advanced/debugging/#inspect-current-facts","title":"Inspect Current Facts","text":"<pre><code>def inspect_facts(engine)\n  puts \"\\n=== Current Facts ===\"\n\n  # Group by type\n  facts_by_type = engine.facts.group_by(&amp;:type)\n\n  facts_by_type.each do |type, facts|\n    puts \"\\n#{type} (#{facts.size}):\"\n    facts.each_with_index do |fact, i|\n      puts \"  #{i + 1}. #{fact.attributes.inspect}\"\n      if fact.is_a?(KBS::Blackboard::Fact)\n        puts \"     ID: #{fact.id}\"\n        puts \"     Created: #{fact.created_at}\"\n      end\n    end\n  end\n\n  puts \"\\nTotal facts: #{engine.facts.size}\"\nend\n\n# Usage\ninspect_facts(engine)\n</code></pre>"},{"location":"advanced/debugging/#query-fact-history-blackboard","title":"Query Fact History (Blackboard)","text":"<pre><code>def inspect_fact_history(engine, fact_id)\n  return unless engine.is_a?(KBS::Blackboard::Engine)\n\n  puts \"\\n=== Fact History: #{fact_id} ===\"\n\n  history = engine.fact_history(fact_id)\n\n  history.each do |entry|\n    puts \"\\n#{entry[:timestamp]}\"\n    puts \"  Operation: #{entry[:operation]}\"\n    puts \"  Attributes: #{entry[:attributes].inspect}\"\n  end\nend\n</code></pre>"},{"location":"advanced/debugging/#find-facts-by-criteria","title":"Find Facts by Criteria","text":"<pre><code>def find_facts(engine, **criteria)\n  results = engine.facts.select do |fact|\n    criteria.all? do |key, value|\n      case key\n      when :type\n        fact.type == value\n      else\n        fact[key] == value\n      end\n    end\n  end\n\n  puts \"\\n=== Found #{results.size} facts ===\"\n  results.each do |fact|\n    puts \"#{fact.type}: #{fact.attributes.inspect}\"\n  end\n\n  results\nend\n\n# Usage\nfind_facts(engine, type: :sensor, location: \"bedroom\")\nfind_facts(engine, type: :alert, severity: \"critical\")\n</code></pre>"},{"location":"advanced/debugging/#rule-debugging","title":"Rule Debugging","text":""},{"location":"advanced/debugging/#trace-rule-execution","title":"Trace Rule Execution","text":"<pre><code>class RuleTracer\n  def initialize(engine)\n    @engine = engine\n    @traces = []\n  end\n\n  def wrap_rules\n    @engine.instance_variable_get(:@rules).each do |rule|\n      wrap_rule(rule)\n    end\n  end\n\n  def wrap_rule(rule)\n    original_action = rule.action\n\n    rule.action = lambda do |facts, bindings|\n      trace = {\n        rule: rule.name,\n        timestamp: Time.now,\n        facts: facts.map { |f| { type: f.type, attrs: f.attributes } },\n        bindings: bindings.dup\n      }\n\n      puts \"\\n[RULE FIRING] #{rule.name}\"\n      puts \"  Facts: #{facts.map(&amp;:type).join(', ')}\"\n      puts \"  Bindings: #{bindings.inspect}\"\n\n      result = original_action.call(facts, bindings)\n\n      trace[:duration] = (Time.now - trace[:timestamp])\n      @traces &lt;&lt; trace\n\n      puts \"  Duration: #{trace[:duration]}s\"\n\n      result\n    end\n  end\n\n  attr_reader :traces\nend\n\n# Usage\ntracer = RuleTracer.new(engine)\ntracer.wrap_rules\nengine.run\nputs \"\\nTotal rule firings: #{tracer.traces.size}\"\n</code></pre>"},{"location":"advanced/debugging/#test-individual-conditions","title":"Test Individual Conditions","text":"<pre><code>def test_condition(engine, condition)\n  puts \"\\n=== Testing Condition ===\"\n  puts \"Type: #{condition.pattern[:type]}\"\n  puts \"Pattern: #{condition.pattern.inspect}\"\n\n  # Find matching facts\n  matches = engine.facts.select do |fact|\n    fact.matches?(condition.pattern)\n  end\n\n  puts \"\\nMatching facts: #{matches.size}\"\n  matches.each do |fact|\n    puts \"  #{fact.attributes.inspect}\"\n\n    # Test predicate if present\n    if condition.predicate\n      predicate_result = condition.predicate.call(fact)\n      puts \"  Predicate: #{predicate_result}\"\n    end\n  end\n\n  matches\nend\n\n# Usage\ncondition = KBS::Condition.new(:sensor, {\n  type: \"temperature\",\n  value: :v?\n}, predicate: lambda { |f| f[:value] &gt; 25 })\n\ntest_condition(engine, condition)\n</code></pre>"},{"location":"advanced/debugging/#why-did-rule-fire","title":"Why Did Rule Fire?","text":"<pre><code>def why_rule_fired(engine, rule_name)\n  rule = engine.instance_variable_get(:@rules).find { |r| r.name == rule_name }\n\n  return unless rule\n\n  puts \"\\n=== Why '#{rule_name}' Fired ===\"\n\n  # Check each condition\n  rule.conditions.each_with_index do |condition, i|\n    puts \"\\nCondition #{i + 1}: #{condition.pattern[:type]}\"\n    puts \"  Pattern: #{condition.pattern.inspect}\"\n    puts \"  Negated: #{condition.negated?}\"\n\n    matches = engine.facts.select { |f| f.matches?(condition.pattern) }\n\n    if condition.predicate\n      matches = matches.select { |f| condition.predicate.call(f) }\n    end\n\n    puts \"  Matches: #{matches.size} facts\"\n    matches.each do |fact|\n      puts \"    - #{fact.attributes.inspect}\"\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/debugging/#why-didnt-rule-fire","title":"Why Didn't Rule Fire?","text":"<pre><code>def why_rule_didnt_fire(engine, rule_name)\n  rule = engine.instance_variable_get(:@rules).find { |r| r.name == rule_name }\n\n  return unless rule\n\n  puts \"\\n=== Why '#{rule_name}' Didn't Fire ===\"\n\n  # Check each condition\n  failing_condition = nil\n\n  rule.conditions.each_with_index do |condition, i|\n    puts \"\\nCondition #{i + 1}: #{condition.pattern[:type]}\"\n\n    matches = engine.facts.select { |f| f.matches?(condition.pattern) }\n\n    if condition.negated?\n      puts \"  Negated condition\"\n      if matches.empty?\n        puts \"  \u2713 PASSED (no matching facts)\"\n      else\n        puts \"  \u2717 FAILED (#{matches.size} matching facts found, but should be absent)\"\n        failing_condition = i\n        matches.each do |fact|\n          puts \"    Blocking fact: #{fact.attributes.inspect}\"\n        end\n      end\n    else\n      if matches.empty?\n        puts \"  \u2717 FAILED (no matching facts)\"\n        failing_condition = i\n\n        # Suggest similar facts\n        similar = engine.facts.select { |f| f.type == condition.pattern[:type] }\n        if similar.any?\n          puts \"  Similar facts (#{similar.size}):\"\n          similar.first(3).each do |fact|\n            puts \"    - #{fact.attributes.inspect}\"\n          end\n        end\n      else\n        # Check predicate\n        if condition.predicate\n          pred_matches = matches.select { |f| condition.predicate.call(f) }\n          if pred_matches.empty?\n            puts \"  \u2717 FAILED (#{matches.size} facts match pattern, but predicate failed)\"\n            failing_condition = i\n            matches.first(3).each do |fact|\n              puts \"    - #{fact.attributes.inspect} (predicate: false)\"\n            end\n          else\n            puts \"  \u2713 PASSED (#{pred_matches.size} facts)\"\n          end\n        else\n          puts \"  \u2713 PASSED (#{matches.size} facts)\"\n        end\n      end\n    end\n\n    break if failing_condition\n  end\n\n  if failing_condition\n    puts \"\\n\u26a0\ufe0f  Rule failed at condition #{failing_condition + 1}\"\n  else\n    puts \"\\n\u2713 All conditions passed (rule should fire on next run)\"\n  end\nend\n\n# Usage\nwhy_rule_didnt_fire(engine, \"detect_high_temperature\")\n</code></pre>"},{"location":"advanced/debugging/#network-visualization","title":"Network Visualization","text":""},{"location":"advanced/debugging/#print-network-structure","title":"Print Network Structure","text":"<pre><code>def visualize_network(engine)\n  puts \"\\n=== RETE Network Structure ===\"\n\n  # Alpha network\n  puts \"\\nALPHA NETWORK:\"\n  alpha_memories = []\n\n  engine.instance_eval do\n    @alpha_network.each do |pattern, memory|\n      puts \"  #{pattern.inspect}\"\n      puts \"    Items: #{memory.items.size}\"\n      alpha_memories &lt;&lt; memory\n    end\n  end\n\n  # Beta network\n  puts \"\\nBETA NETWORK:\"\n  # Simplified - actual inspection depends on implementation\n\n  puts \"\\nSTATISTICS:\"\n  puts \"  Alpha memories: #{alpha_memories.size}\"\n  puts \"  Total facts: #{engine.facts.size}\"\n  puts \"  Rules: #{engine.instance_variable_get(:@rules).size}\"\nend\n</code></pre>"},{"location":"advanced/debugging/#graphviz-export","title":"Graphviz Export","text":"<pre><code>def export_to_graphviz(engine, filename = \"network.dot\")\n  File.open(filename, 'w') do |f|\n    f.puts \"digraph RETE {\"\n    f.puts \"  rankdir=TB;\"\n    f.puts \"  node [shape=box];\"\n\n    # Alpha nodes\n    f.puts \"\\n  // Alpha Network\"\n    engine.instance_eval do\n      @alpha_network.each_with_index do |(pattern, memory), i|\n        node_id = \"alpha_#{i}\"\n        label = \"#{pattern[:type]}\\\\n#{memory.items.size} facts\"\n        f.puts \"  #{node_id} [label=\\\"#{label}\\\", style=filled, fillcolor=lightblue];\"\n      end\n    end\n\n    # Production nodes\n    f.puts \"\\n  // Production Nodes\"\n    engine.instance_variable_get(:@rules).each_with_index do |rule, i|\n      node_id = \"rule_#{i}\"\n      label = \"#{rule.name}\\\\n#{rule.priority}\"\n      f.puts \"  #{node_id} [label=\\\"#{label}\\\", style=filled, fillcolor=lightgreen];\"\n    end\n\n    # Edges (simplified)\n    # ...\n\n    f.puts \"}\"\n  end\n\n  puts \"Network exported to #{filename}\"\n  puts \"Render with: dot -Tpng #{filename} -o network.png\"\nend\n\n# Usage\nexport_to_graphviz(engine)\n</code></pre>"},{"location":"advanced/debugging/#token-tracing","title":"Token Tracing","text":""},{"location":"advanced/debugging/#trace-token-propagation","title":"Trace Token Propagation","text":"<pre><code>class TokenTracer\n  def initialize\n    @trace = []\n  end\n\n  def log_activation(node_type, node_id, token)\n    @trace &lt;&lt; {\n      timestamp: Time.now,\n      node_type: node_type,\n      node_id: node_id,\n      token: token.inspect\n    }\n\n    puts \"[#{node_type}] #{node_id}: #{token.inspect}\"\n  end\n\n  def print_trace\n    puts \"\\n=== Token Trace ===\"\n    @trace.each_with_index do |entry, i|\n      puts \"\\n#{i + 1}. [#{entry[:node_type]}] #{entry[:node_id]}\"\n      puts \"   Time: #{entry[:timestamp]}\"\n      puts \"   Token: #{entry[:token]}\"\n    end\n  end\n\n  attr_reader :trace\nend\n\n# Usage: Instrument nodes\ntracer = TokenTracer.new\n\n# Wrap alpha activation\nalpha_memory.define_singleton_method(:right_activate) do |fact|\n  tracer.log_activation(\"AlphaMemory\", object_id, fact)\n  super(fact)\nend\n</code></pre>"},{"location":"advanced/debugging/#interactive-debugging","title":"Interactive Debugging","text":""},{"location":"advanced/debugging/#debug-console","title":"Debug Console","text":"<pre><code>class DebugConsole\n  def initialize(engine)\n    @engine = engine\n  end\n\n  def start\n    loop do\n      print \"\\nkbs&gt; \"\n      input = gets.chomp\n\n      break if input == \"exit\"\n\n      case input\n      when \"facts\"\n        inspect_facts(@engine)\n      when \"rules\"\n        list_rules\n      when \"run\"\n        @engine.run\n        puts \"Engine ran successfully\"\n      when /^add (\\w+) (.+)$/\n        type = $1.to_sym\n        attrs = eval($2)  # UNSAFE: eval user input (for demo only)\n        @engine.add_fact(type, attrs)\n        puts \"Fact added\"\n      when /^remove (\\d+)$/\n        fact = @engine.facts[$1.to_i]\n        @engine.remove_fact(fact) if fact\n        puts \"Fact removed\"\n      when /^why (.+)$/\n        why_rule_didnt_fire(@engine, $1)\n      when \"help\"\n        print_help\n      else\n        puts \"Unknown command: #{input}\"\n        print_help\n      end\n    end\n  end\n\n  def list_rules\n    puts \"\\n=== Rules ===\"\n    @engine.instance_variable_get(:@rules).each_with_index do |rule, i|\n      puts \"#{i}. #{rule.name} (priority: #{rule.priority}, conditions: #{rule.conditions.size})\"\n    end\n  end\n\n  def print_help\n    puts &lt;&lt;~HELP\n\n      Commands:\n        facts              - List all facts\n        rules              - List all rules\n        run                - Run engine\n        add TYPE {ATTRS}   - Add fact\n        remove INDEX       - Remove fact\n        why RULE_NAME      - Explain why rule didn't fire\n        exit               - Exit console\n        help               - Show this help\n\n    HELP\n  end\nend\n\n# Usage\nconsole = DebugConsole.new(engine)\nconsole.start\n</code></pre>"},{"location":"advanced/debugging/#step-through-debugger","title":"Step-Through Debugger","text":"<pre><code>class StepDebugger\n  def initialize(engine)\n    @engine = engine\n    @breakpoints = []\n    @step_mode = false\n  end\n\n  def add_breakpoint(rule_name)\n    @breakpoints &lt;&lt; rule_name\n    puts \"Breakpoint added: #{rule_name}\"\n  end\n\n  def enable_step_mode\n    @step_mode = true\n\n    @engine.instance_variable_get(:@rules).each do |rule|\n      wrap_rule_with_breakpoint(rule)\n    end\n  end\n\n  def wrap_rule_with_breakpoint(rule)\n    original_action = rule.action\n\n    rule.action = lambda do |facts, bindings|\n      if @breakpoints.include?(rule.name) || @step_mode\n        puts \"\\n\ud83d\udd34 BREAKPOINT: #{rule.name}\"\n        puts \"Facts: #{facts.map { |f| { type: f.type, attrs: f.attributes } }}\"\n        puts \"Bindings: #{bindings.inspect}\"\n\n        print \"Continue? [y/n/i(nspect)] \"\n        response = gets.chomp\n\n        case response\n        when 'n'\n          puts \"Skipping rule\"\n          return\n        when 'i'\n          inspect_rule_context(facts, bindings)\n        end\n      end\n\n      original_action.call(facts, bindings)\n    end\n  end\n\n  def inspect_rule_context(facts, bindings)\n    puts \"\\n=== Rule Context ===\"\n    puts \"Facts (#{facts.size}):\"\n    facts.each_with_index do |fact, i|\n      puts \"  #{i}. #{fact.type}: #{fact.attributes.inspect}\"\n    end\n\n    puts \"\\nBindings:\"\n    bindings.each do |var, value|\n      puts \"  #{var} =&gt; #{value.inspect}\"\n    end\n\n    print \"\\nPress Enter to continue...\"\n    gets\n  end\nend\n\n# Usage\ndebugger = StepDebugger.new(engine)\ndebugger.add_breakpoint(\"high_temperature_alert\")\ndebugger.enable_step_mode\nengine.run\n</code></pre>"},{"location":"advanced/debugging/#common-debugging-patterns","title":"Common Debugging Patterns","text":""},{"location":"advanced/debugging/#verify-pattern-matching","title":"Verify Pattern Matching","text":"<pre><code>def verify_pattern_match(fact, pattern)\n  puts \"\\n=== Pattern Match Verification ===\"\n  puts \"Fact: #{fact.attributes.inspect}\"\n  puts \"Pattern: #{pattern.inspect}\"\n\n  result = fact.matches?(pattern)\n  puts \"Result: #{result}\"\n\n  # Detail each attribute\n  pattern.each do |key, expected|\n    next if key == :type\n\n    actual = fact[key]\n    match = (expected == actual || expected.is_a?(Symbol))\n\n    puts \"\\n  #{key}:\"\n    puts \"    Expected: #{expected.inspect}\"\n    puts \"    Actual: #{actual.inspect}\"\n    puts \"    Match: #{match ? '\u2713' : '\u2717'}\"\n  end\n\n  result\nend\n</code></pre>"},{"location":"advanced/debugging/#diagnose-join-issues","title":"Diagnose Join Issues","text":"<pre><code>def diagnose_join(engine, condition1, condition2)\n  puts \"\\n=== Join Diagnosis ===\"\n\n  # Find matches for each condition\n  matches1 = engine.facts.select { |f| f.matches?(condition1.pattern) }\n  matches2 = engine.facts.select { |f| f.matches?(condition2.pattern) }\n\n  puts \"\\nCondition 1 matches: #{matches1.size}\"\n  matches1.first(3).each { |f| puts \"  - #{f.attributes.inspect}\" }\n\n  puts \"\\nCondition 2 matches: #{matches2.size}\"\n  matches2.first(3).each { |f| puts \"  - #{f.attributes.inspect}\" }\n\n  # Find join variables\n  vars1 = condition1.pattern.values.select { |v| v.is_a?(Symbol) &amp;&amp; v.to_s.start_with?('?') }\n  vars2 = condition2.pattern.values.select { |v| v.is_a?(Symbol) &amp;&amp; v.to_s.start_with?('?') }\n  join_vars = vars1 &amp; vars2\n\n  puts \"\\nJoin variables: #{join_vars.inspect}\"\n\n  if join_vars.empty?\n    puts \"\u26a0\ufe0f  No shared variables - conditions are independent\"\n  else\n    # Check if any combinations match\n    combinations = 0\n    matches1.each do |f1|\n      matches2.each do |f2|\n        # Extract bindings\n        bindings1 = extract_bindings(f1, condition1.pattern)\n        bindings2 = extract_bindings(f2, condition2.pattern)\n\n        # Check join\n        if join_vars.all? { |v| bindings1[v] == bindings2[v] }\n          combinations += 1\n        end\n      end\n    end\n\n    puts \"Valid combinations: #{combinations}\"\n  end\nend\n</code></pre>"},{"location":"advanced/debugging/#track-memory-usage","title":"Track Memory Usage","text":"<pre><code>require 'objspace'\n\ndef track_memory_usage(engine)\n  puts \"\\n=== Memory Usage ===\"\n\n  # Facts\n  fact_size = engine.facts.sum { |f| ObjectSpace.memsize_of(f) }\n  puts \"Facts: #{(fact_size / 1024.0).round(2)} KB (#{engine.facts.size} facts)\"\n\n  # Alpha memories\n  alpha_size = 0\n  engine.instance_eval do\n    @alpha_network.each do |_, memory|\n      alpha_size += ObjectSpace.memsize_of(memory)\n      alpha_size += memory.items.sum { |f| ObjectSpace.memsize_of(f) }\n    end\n  end\n  puts \"Alpha network: #{(alpha_size / 1024.0).round(2)} KB\"\n\n  total = fact_size + alpha_size\n  puts \"\\nTotal: #{(total / 1024.0).round(2)} KB\"\nend\n</code></pre>"},{"location":"advanced/debugging/#debugging-checklist","title":"Debugging Checklist","text":"<ul> <li> Verify facts are added with correct types and attributes</li> <li> Check condition patterns match fact structure</li> <li> Test predicates independently</li> <li> Ensure variables are bound correctly across conditions</li> <li> Check negated conditions for blocking facts</li> <li> Verify rule priorities</li> <li> Inspect network structure</li> <li> Trace rule execution</li> <li> Monitor memory usage</li> <li> Check for infinite loops</li> </ul>"},{"location":"advanced/debugging/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Guide - Write tests to prevent bugs</li> <li>Performance Guide - Debug performance issues</li> <li>Architecture - Understand network internals</li> <li>API Reference - Engine API documentation</li> </ul> <p>Good debugging is about asking the right questions. Use these tools to understand what your rules are doing.</p>"},{"location":"advanced/performance/","title":"Performance Tuning","text":"<p>Optimize KBS applications for speed, scalability, and efficiency. This guide covers profiling, benchmarking, rule optimization, and storage backend selection.</p>"},{"location":"advanced/performance/#performance-overview","title":"Performance Overview","text":"<p>KBS performance depends on:</p> <ol> <li>Rule Complexity - Number of conditions, predicates, and joins</li> <li>Fact Volume - Size of working memory</li> <li>Network Structure - Shared nodes and network branching</li> <li>Storage Backend - SQLite, Redis, or in-memory</li> <li>Action Efficiency - Time spent in rule actions</li> </ol>"},{"location":"advanced/performance/#benchmarking","title":"Benchmarking","text":""},{"location":"advanced/performance/#basic-benchmark","title":"Basic Benchmark","text":"<pre><code>require 'benchmark'\nrequire 'kbs'\n\nkb = KBS.knowledge_base do\n  rule \"simple_rule\" do\n    on :fact, value: :v?\n    perform do |facts, bindings|\n      # Simple action\n    end\n  end\nend\n\n# Benchmark fact addition\ntime = Benchmark.measure do\n  10_000.times do |i|\n    kb.fact :fact, value: i\n  end\nend\n\nputs \"Added 10,000 facts in #{time.real} seconds\"\nputs \"#{(10_000 / time.real).round(2)} facts/second\"\n\n# Benchmark engine run\ntime = Benchmark.measure do\n  kb.run\nend\n\nputs \"Ran engine in #{time.real} seconds\"\n</code></pre>"},{"location":"advanced/performance/#comprehensive-benchmark","title":"Comprehensive Benchmark","text":"<pre><code>require 'benchmark'\n\nclass KBSBenchmark\n  def initialize(engine_type: :memory)\n    @engine_type = engine_type\n    @results = {}\n  end\n\n  def setup_engine\n    case @engine_type\n    when :memory\n      # Return a new knowledge base context\n      @kb_context = :memory\n    when :blackboard_sqlite\n      @kb_context = :blackboard_sqlite\n      @db_path = ':memory:'\n    when :blackboard_redis\n      require 'kbs/blackboard/persistence/redis_store'\n      @kb_context = :blackboard_redis\n      @store = KBS::Blackboard::Persistence::RedisStore.new(\n        url: 'redis://localhost:6379/15'  # Test database\n      )\n    end\n  end\n\n  def benchmark_fact_addition(count: 10_000)\n    setup_engine\n\n    kb = case @kb_context\n    when :memory\n      KBS.knowledge_base do\n        # Add facts in benchmark block\n      end\n    when :blackboard_sqlite\n      engine = KBS::Blackboard::Engine.new(db_path: @db_path)\n      KBS.knowledge_base(engine: engine)\n    when :blackboard_redis\n      engine = KBS::Blackboard::Engine.new(store: @store)\n      KBS.knowledge_base(engine: engine)\n    end\n\n    time = Benchmark.measure do\n      count.times do |i|\n        kb.fact :fact, id: i, value: rand(1000)\n      end\n    end\n\n    @results[:fact_addition] = {\n      count: count,\n      time: time.real,\n      rate: (count / time.real).round(2)\n    }\n  end\n\n  def benchmark_simple_rules(fact_count: 1000, rule_count: 10)\n    setup_engine\n\n    kb = case @kb_context\n    when :memory\n      KBS.knowledge_base do\n        # Add rules\n        rule_count.times do |i|\n          rule \"rule_#{i}\" do\n            on :fact, value: :v?\n            perform do |facts, bindings|\n              # Minimal action\n            end\n          end\n        end\n\n        # Add facts\n        fact_count.times do |i|\n          fact :fact, value: i\n        end\n      end\n    when :blackboard_sqlite\n      engine = KBS::Blackboard::Engine.new(db_path: @db_path)\n      kb = KBS.knowledge_base(engine: engine) do\n        rule_count.times do |i|\n          rule \"rule_#{i}\" do\n            on :fact, value: :v?\n            perform { }\n          end\n        end\n        fact_count.times do |i|\n          fact :fact, value: i\n        end\n      end\n    when :blackboard_redis\n      engine = KBS::Blackboard::Engine.new(store: @store)\n      kb = KBS.knowledge_base(engine: engine) do\n        rule_count.times do |i|\n          rule \"rule_#{i}\" do\n            on :fact, value: :v?\n            perform { }\n          end\n        end\n        fact_count.times do |i|\n          fact :fact, value: i\n        end\n      end\n    end\n\n    # Benchmark engine run\n    time = Benchmark.measure do\n      kb.run\n    end\n\n    @results[:simple_rules] = {\n      fact_count: fact_count,\n      rule_count: rule_count,\n      time: time.real\n    }\n  end\n\n  def benchmark_complex_joins(fact_count: 500)\n    setup_engine\n\n    kb = case @kb_context\n    when :memory\n      KBS.knowledge_base do\n        # Rule with 3-way join\n        rule \"complex_join\" do\n          on :a, id: :id?, value: :v?\n          on :b, a_id: :id?, score: :s?\n          on :c, b_score: :s?\n          perform do |facts, bindings|\n            # Action\n          end\n        end\n\n        # Add facts\n        fact_count.times do |i|\n          fact :a, id: i, value: rand(100)\n          fact :b, a_id: i, score: rand(100)\n          fact :c, b_score: i\n        end\n      end\n    end\n\n    # Benchmark\n    time = Benchmark.measure do\n      kb.run\n    end\n\n    @results[:complex_joins] = {\n      fact_count: fact_count * 3,\n      time: time.real\n    }\n  end\n\n  def benchmark_negation(fact_count: 1000)\n    setup_engine\n\n    kb = KBS.knowledge_base do\n      # Rule with negation\n      rule \"negation_rule\" do\n        on :positive, id: :id?\n        without :negative, id: :id?\n        perform do |facts, bindings|\n          # Action\n        end\n      end\n\n      # Add facts (50% will match)\n      fact_count.times do |i|\n        fact :positive, id: i\n        fact :negative, id: i if i.even?\n      end\n    end\n\n    # Benchmark\n    time = Benchmark.measure do\n      kb.run\n    end\n\n    @results[:negation] = {\n      fact_count: fact_count + (fact_count / 2),\n      time: time.real\n    }\n  end\n\n  def run_all\n    puts \"=== KBS Performance Benchmark (#{@engine_type}) ===\"\n\n    benchmark_fact_addition\n    puts \"\\nFact Addition:\"\n    puts \"  #{@results[:fact_addition][:count]} facts in #{@results[:fact_addition][:time].round(4)}s\"\n    puts \"  Rate: #{@results[:fact_addition][:rate]} facts/sec\"\n\n    benchmark_simple_rules\n    puts \"\\nSimple Rules:\"\n    puts \"  #{@results[:simple_rules][:rule_count]} rules, #{@results[:simple_rules][:fact_count]} facts\"\n    puts \"  Time: #{@results[:simple_rules][:time].round(4)}s\"\n\n    benchmark_complex_joins\n    puts \"\\nComplex Joins (3-way):\"\n    puts \"  #{@results[:complex_joins][:fact_count]} facts\"\n    puts \"  Time: #{@results[:complex_joins][:time].round(4)}s\"\n\n    benchmark_negation\n    puts \"\\nNegation:\"\n    puts \"  #{@results[:negation][:fact_count]} facts\"\n    puts \"  Time: #{@results[:negation][:time].round(4)}s\"\n\n    @results\n  end\nend\n\n# Run benchmarks\nmemory_bench = KBSBenchmark.new(engine_type: :memory)\nmemory_results = memory_bench.run_all\n\n# Compare with blackboard\nblackboard_bench = KBSBenchmark.new(engine_type: :blackboard_sqlite)\nblackboard_results = blackboard_bench.run_all\n\n# Compare\nputs \"\\n=== Performance Comparison ===\"\nputs \"Fact addition: Memory is #{(blackboard_results[:fact_addition][:time] / memory_results[:fact_addition][:time]).round(2)}x faster\"\n</code></pre>"},{"location":"advanced/performance/#rule-optimization","title":"Rule Optimization","text":""},{"location":"advanced/performance/#condition-ordering","title":"Condition Ordering","text":"<p>Order conditions from most to least selective:</p> <pre><code># Bad: Generic condition first\nKBS::Rule.new(\"inefficient\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:any_event, {}),  # Matches ALL events (large alpha memory)\n    KBS::Condition.new(:critical_error, { severity: \"critical\" })  # Selective\n  ]\nend\n\n# Good: Selective condition first\nKBS::Rule.new(\"efficient\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:critical_error, { severity: \"critical\" }),  # Selective\n    KBS::Condition.new(:any_event, { error_id: :id? })  # Filtered by join\n  ]\nend\n</code></pre> <p>Why it matters:</p> <pre><code>Bad ordering:\n  any_event alpha: 10,000 facts\n  Join produces 10,000 tokens\n  critical_error alpha: 5 facts\n  Join filters down to 5 final matches\n  \u2192 10,000 token propagations\n\nGood ordering:\n  critical_error alpha: 5 facts\n  Join produces 5 tokens\n  any_event alpha: 10,000 facts\n  Join filters to 5 final matches\n  \u2192 5 token propagations (2000x fewer!)\n</code></pre>"},{"location":"advanced/performance/#predicate-efficiency","title":"Predicate Efficiency","text":"<p>Use simple predicates:</p> <pre><code># Bad: Complex predicate\nKBS::Condition.new(:data, { value: :v? }, predicate: lambda { |f|\n  # Expensive operations\n  json = JSON.parse(f[:raw_data])\n  result = ComplexCalculation.new(json).process\n  result &gt; threshold\n})\n\n# Good: Pre-process data\nengine.add_fact(:data, {\n  value: calculate_value(raw_data),  # Pre-calculated\n  processed: true\n})\n\nKBS::Condition.new(:data, { value: :v? }, predicate: lambda { |f|\n  f[:value] &gt; threshold  # Simple comparison\n})\n</code></pre>"},{"location":"advanced/performance/#network-sharing","title":"Network Sharing","text":"<p>Leverage shared alpha and beta memories:</p> <pre><code># Inefficient: Duplicate alpha nodes\nrule1 = KBS::Rule.new(\"rule1\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { type: \"temperature\", value: :v1? })\n  ]\nend\n\nrule2 = KBS::Rule.new(\"rule2\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { type: \"temperature\", value: :v2? })  # SAME pattern\n  ]\nend\n\n# Engine automatically shares alpha memory for :sensor + type=\"temperature\"\n# Adding 1 temperature sensor fact activates BOTH rules efficiently\n</code></pre> <p>Sharing visualization:</p> <pre><code>Facts \u2192 AlphaMemory(:sensor, type=temperature) \u2500\u2500\u252c\u2500\u2192 Rule1\n                                                  \u2514\u2500\u2192 Rule2\n\nInstead of:\nFacts \u2192 AlphaMemory1(:sensor) \u2192 Rule1\n     \u2514\u2192 AlphaMemory2(:sensor) \u2192 Rule2  (duplicate work)\n</code></pre>"},{"location":"advanced/performance/#minimize-negations","title":"Minimize Negations","text":"<p>Negations are expensive:</p> <pre><code># Expensive: Multiple negations\nKBS::Rule.new(\"many_negations\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:a, {}),\n    KBS::Condition.new(:b, {}, negated: true),\n    KBS::Condition.new(:c, {}, negated: true),\n    KBS::Condition.new(:d, {}, negated: true)\n  ]\nend\n# Each negation checks alpha memory on every token\n\n# Better: Use positive logic\nengine.add_fact(:conditions_clear, {}) unless b_exists? || c_exists? || d_exists?\n\nKBS::Rule.new(\"positive_logic\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:a, {}),\n    KBS::Condition.new(:conditions_clear, {})\n  ]\nend\n</code></pre>"},{"location":"advanced/performance/#batch-operations","title":"Batch Operations","text":"<p>Group related operations:</p> <pre><code># Inefficient: Add facts one by one with run after each\n1000.times do |i|\n  engine.add_fact(:item, { id: i })\n  engine.run  # Run engine 1000 times!\nend\n\n# Efficient: Batch add, then run once\n1000.times do |i|\n  engine.add_fact(:item, { id: i })\nend\nengine.run  # Run engine once\n</code></pre>"},{"location":"advanced/performance/#storage-backend-selection","title":"Storage Backend Selection","text":""},{"location":"advanced/performance/#performance-characteristics","title":"Performance Characteristics","text":"<pre><code>require 'benchmark'\n\n# In-memory (fastest)\nmemory_engine = KBS::Engine.new\n\n# SQLite (persistent, slower)\nsqlite_engine = KBS::Blackboard::Engine.new(db_path: 'test.db')\n\n# Redis (persistent, fast)\nrequire 'kbs/blackboard/persistence/redis_store'\nredis_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nredis_engine = KBS::Blackboard::Engine.new(store: redis_store)\n\n# Benchmark\nengines = {\n  memory: memory_engine,\n  sqlite: sqlite_engine,\n  redis: redis_engine\n}\n\nengines.each do |name, engine|\n  time = Benchmark.measure do\n    10_000.times { |i| engine.add_fact(:test, { value: i }) }\n  end\n\n  puts \"#{name}: #{(10_000 / time.real).round(2)} facts/sec\"\nend\n\n# Typical results:\n# memory: 50,000 facts/sec\n# sqlite: 5,000 facts/sec\n# redis: 25,000 facts/sec\n</code></pre>"},{"location":"advanced/performance/#backend-decision-matrix","title":"Backend Decision Matrix","text":"<p>In-Memory (<code>KBS::Engine</code>): - \u2705 Fastest (no I/O) - \u2705 Simple (no setup) - \u274c No persistence - Use when: Prototyping, short-lived processes, pure computation</p> <p>SQLite (<code>KBS::Blackboard::Engine</code>): - \u2705 Persistent - \u2705 ACID transactions - \u2705 No dependencies - \u274c Slower writes (~5,000/sec) - Use when: Single process, moderate load, need durability</p> <p>Redis (<code>RedisStore</code>): - \u2705 Fast (~25,000/sec) - \u2705 Distributed - \u2705 Scalable - \u274c Requires Redis server - Use when: High throughput, multiple processes, real-time systems</p> <p>Hybrid (<code>HybridStore</code>): - \u2705 Fast (Redis) + durable (SQLite) - \u274c Most complex - Use when: Production, need both speed and audit trail</p>"},{"location":"advanced/performance/#sqlite-optimization","title":"SQLite Optimization","text":"<pre><code>engine = KBS::Blackboard::Engine.new(\n  db_path: 'optimized.db',\n  journal_mode: 'WAL',         # Write-Ahead Logging (better concurrency)\n  synchronous: 'NORMAL',       # Balance safety/speed\n  cache_size: -64000,          # 64MB cache\n  busy_timeout: 5000           # Wait 5s for locks\n)\n\n# Results: 2-3x faster than default settings\n</code></pre>"},{"location":"advanced/performance/#redis-optimization","title":"Redis Optimization","text":"<pre><code>store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  pool_size: 10,          # Connection pooling\n  pool_timeout: 5,        # Pool timeout\n  reconnect_attempts: 3   # Retry on failure\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n\n# Enable Redis persistence (optional)\n# In redis.conf:\n#   save 900 1\n#   appendonly yes\n</code></pre>"},{"location":"advanced/performance/#profiling","title":"Profiling","text":""},{"location":"advanced/performance/#ruby-profiler","title":"Ruby Profiler","text":"<pre><code>require 'ruby-prof'\n\nengine = KBS::Engine.new\n\n# Add rules and facts\n# ...\n\n# Profile engine run\nresult = RubyProf.profile do\n  engine.run\nend\n\n# Print results\nprinter = RubyProf::FlatPrinter.new(result)\nprinter.print(STDOUT, min_percent: 2)\n\n# Or use call graph\nprinter = RubyProf::CallTreePrinter.new(result)\nFile.open('profile.out', 'w') { |f| printer.print(f) }\n# View with kcachegrind or qcachegrind\n</code></pre>"},{"location":"advanced/performance/#stackprof-sampling-profiler","title":"Stackprof (Sampling Profiler)","text":"<pre><code>require 'stackprof'\n\nengine = KBS::Engine.new\n\n# Add rules and facts\n# ...\n\n# Profile\nStackProf.run(mode: :cpu, out: 'stackprof.dump') do\n  1000.times { engine.run }\nend\n\n# Analyze\n# $ stackprof stackprof.dump --text\n# $ stackprof stackprof.dump --method 'KBS::JoinNode#left_activate'\n</code></pre>"},{"location":"advanced/performance/#custom-instrumentation","title":"Custom Instrumentation","text":"<pre><code>class InstrumentedEngine &lt; KBS::Engine\n  def initialize\n    super\n    @metrics = {\n      fact_additions: 0,\n      rule_firings: 0,\n      alpha_activations: 0,\n      beta_activations: 0\n    }\n  end\n\n  def add_fact(type, attributes = {})\n    @metrics[:fact_additions] += 1\n    super\n  end\n\n  def run\n    start = Time.now\n    result = super\n    elapsed = Time.now - start\n\n    puts \"Engine run: #{elapsed}s\"\n    puts \"  Facts: #{facts.size}\"\n    puts \"  Rules fired: #{@metrics[:rule_firings]}\"\n\n    result\n  end\n\n  def report_metrics\n    @metrics\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#common-bottlenecks","title":"Common Bottlenecks","text":""},{"location":"advanced/performance/#1-large-alpha-memories","title":"1. Large Alpha Memories","text":"<p>Problem: Conditions matching many facts slow down joins</p> <pre><code># Slow: Matches ALL events\nKBS::Condition.new(:event, {})  # Alpha memory: 100,000 facts\n</code></pre> <p>Solution: Add constraints</p> <pre><code># Fast: Matches specific events\nKBS::Condition.new(:event, { type: \"error\", severity: \"critical\" })\n# Alpha memory: 50 facts\n</code></pre>"},{"location":"advanced/performance/#2-expensive-predicates","title":"2. Expensive Predicates","text":"<p>Problem: Complex predicates evaluated repeatedly</p> <pre><code># Slow: Expensive predicate called for every fact\nKBS::Condition.new(:data, {}, predicate: lambda { |f|\n  expensive_calculation(f[:raw_data])\n})\n</code></pre> <p>Solution: Pre-calculate</p> <pre><code># Fast: Calculate once when adding fact\nprocessed_value = expensive_calculation(raw_data)\nengine.add_fact(:data, { processed: processed_value })\n\nKBS::Condition.new(:data, { processed: :v? })\n</code></pre>"},{"location":"advanced/performance/#3-action-overhead","title":"3. Action Overhead","text":"<p>Problem: Slow actions block engine</p> <pre><code># Slow: Action makes API call\nr.action = lambda do |facts, bindings|\n  result = HTTParty.get(\"https://api.example.com/process\")  # Blocks!\n  engine.add_fact(:result, result)\nend\n</code></pre> <p>Solution: Async processing</p> <pre><code># Fast: Queue action, process asynchronously\nr.action = lambda do |facts, bindings|\n  engine.send_message(:api_queue, {\n    url: \"https://api.example.com/process\",\n    fact_id: facts[0].id\n  }, priority: 50)\nend\n\n# Separate worker processes messages\nworker = Thread.new do\n  loop do\n    msg = engine.pop_message(:api_queue)\n    break unless msg\n\n    result = HTTParty.get(msg[:content][:url])\n    engine.add_fact(:result, result)\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#4-memory-leaks","title":"4. Memory Leaks","text":"<p>Problem: Facts accumulate indefinitely</p> <pre><code># Memory grows unbounded\nloop do\n  engine.add_fact(:sensor_reading, {\n    value: read_sensor(),\n    timestamp: Time.now\n  })\n  engine.run\nend\n# After 1 hour: 360,000 facts in memory!\n</code></pre> <p>Solution: Clean up old facts</p> <pre><code># Cleanup rule\ncleanup_rule = KBS::Rule.new(\"cleanup_old_readings\", priority: 1) do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor_reading, {\n      timestamp: :time?\n    }, predicate: lambda { |f|\n      (Time.now - f[:timestamp]) &gt; 300  # 5 minutes old\n    })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.remove_fact(facts[0])\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#optimization-checklist","title":"Optimization Checklist","text":""},{"location":"advanced/performance/#rule-design","title":"Rule Design","text":"<ul> <li> Order conditions from most to least selective</li> <li> Minimize negations (use positive logic where possible)</li> <li> Keep predicates simple</li> <li> Pre-calculate expensive values</li> <li> Share patterns across rules</li> </ul>"},{"location":"advanced/performance/#fact-management","title":"Fact Management","text":"<ul> <li> Remove facts when no longer needed</li> <li> Batch fact additions</li> <li> Use specific fact types (not generic <code>:data</code>)</li> <li> Avoid duplicate facts</li> </ul>"},{"location":"advanced/performance/#actions","title":"Actions","text":"<ul> <li> Keep actions fast</li> <li> Avoid blocking I/O in actions</li> <li> Use message passing for async work</li> <li> Don't add/remove many facts in single action</li> </ul>"},{"location":"advanced/performance/#storage","title":"Storage","text":"<ul> <li> Choose backend based on requirements:</li> <li>In-memory for speed</li> <li>SQLite for persistence + moderate load</li> <li>Redis for persistence + high load</li> <li>Hybrid for production</li> <li> Optimize SQLite with WAL mode</li> <li> Use connection pooling for Redis</li> <li> Monitor database size</li> </ul>"},{"location":"advanced/performance/#monitoring","title":"Monitoring","text":"<ul> <li> Profile before optimizing</li> <li> Measure fact addition rate</li> <li> Track engine run time</li> <li> Monitor memory usage</li> <li> Log rule firing frequency</li> </ul>"},{"location":"advanced/performance/#performance-targets","title":"Performance Targets","text":""},{"location":"advanced/performance/#expected-performance-in-memory","title":"Expected Performance (In-Memory)","text":"Operation Target Notes Add fact 50,000/sec Simple facts, no rules Simple rule (1 condition) 10,000/sec Per fact Complex rule (3+ conditions) 1,000/sec Per fact Engine run (1000 facts, 10 rules) &lt; 100ms Total time Negation check 10,000/sec Per token"},{"location":"advanced/performance/#expected-performance-sqlite","title":"Expected Performance (SQLite)","text":"Operation Target Notes Add fact 5,000/sec With WAL mode Query facts 100,000/sec Indexed queries Transaction 1,000/sec Commit rate"},{"location":"advanced/performance/#expected-performance-redis","title":"Expected Performance (Redis)","text":"Operation Target Notes Add fact 25,000/sec Network overhead Query facts 50,000/sec Hash operations Message queue 50,000/sec Sorted set operations"},{"location":"advanced/performance/#scaling-strategies","title":"Scaling Strategies","text":""},{"location":"advanced/performance/#vertical-scaling","title":"Vertical Scaling","text":"<p>Increase single-process performance:</p> <pre><code># 1. Use faster backend\nstore = KBS::Blackboard::Persistence::RedisStore.new(...)\nengine = KBS::Blackboard::Engine.new(store: store)\n\n# 2. Optimize rules\n# - Order conditions\n# - Minimize negations\n# - Batch operations\n\n# 3. Pre-process data\n# - Calculate values before adding facts\n# - Index frequently queried attributes\n</code></pre>"},{"location":"advanced/performance/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>Multiple processes sharing Redis:</p> <pre><code># Process 1: Data collector\ncollector_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\ncollector = KBS::Blackboard::Engine.new(store: collector_store)\n\n# Collect data\nloop do\n  data = fetch_data()\n  collector.add_fact(:raw_data, data)\nend\n\n# Process 2: Rule processor\nprocessor_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'  # Same Redis!\n)\nprocessor = KBS::Blackboard::Engine.new(store: processor_store)\n\n# Add rules\nprocessor.add_rule(...)\n\n# Process data\nloop do\n  processor.run\n  sleep 1\nend\n</code></pre>"},{"location":"advanced/performance/#partitioning","title":"Partitioning","text":"<p>Split facts by domain:</p> <pre><code># Engine 1: Temperature monitoring\ntemp_engine = KBS::Blackboard::Engine.new(db_path: 'temp.db')\n# Handles :temperature_reading, :hvac_control\n\n# Engine 2: Security monitoring\nsecurity_engine = KBS::Blackboard::Engine.new(db_path: 'security.db')\n# Handles :motion_sensor, :door_sensor, :alarm\n\n# Coordinator: Coordinates between engines\ncoordinator_engine = KBS::Blackboard::Engine.new(db_path: 'coordinator.db')\n# Handles cross-domain rules\n</code></pre>"},{"location":"advanced/performance/#next-steps","title":"Next Steps","text":"<ul> <li>Debugging Guide - Debug performance issues</li> <li>Testing Guide - Performance testing strategies</li> <li>Custom Persistence - Optimize custom backends</li> <li>Architecture - Understand network structure</li> </ul> <p>Premature optimization is the root of all evil. Profile first, then optimize the bottlenecks.</p>"},{"location":"advanced/testing/","title":"Testing Rules","text":"<p>Comprehensive testing strategies for rule-based systems. This guide covers unit testing, integration testing, test fixtures, and coverage analysis for KBS applications.</p>"},{"location":"advanced/testing/#testing-overview","title":"Testing Overview","text":"<p>Rule-based systems require testing at multiple levels:</p> <ol> <li>Unit Tests - Test individual rules in isolation</li> <li>Integration Tests - Test rule interactions</li> <li>Fact Fixtures - Reusable test data</li> <li>Coverage - Ensure all rules and conditions are tested</li> <li>Performance Tests - Verify rule execution speed</li> </ol>"},{"location":"advanced/testing/#setup","title":"Setup","text":""},{"location":"advanced/testing/#test-framework","title":"Test Framework","text":"<pre><code># Gemfile\ngroup :test do\n  gem 'minitest', '~&gt; 5.0'\n  gem 'simplecov', require: false  # Coverage\nend\n</code></pre>"},{"location":"advanced/testing/#test-helper","title":"Test Helper","text":"<pre><code># test/test_helper.rb\nrequire 'simplecov'\nSimpleCov.start\n\nrequire 'minitest/autorun'\nrequire 'kbs'\n\nclass Minitest::Test\n  def assert_rule_fired(kb, rule_name)\n    # Check if rule action was executed\n    # Implementation depends on tracking mechanism\n  end\n\n  def refute_rule_fired(kb, rule_name)\n    # Check that rule did not fire\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#unit-testing-rules","title":"Unit Testing Rules","text":""},{"location":"advanced/testing/#test-single-rule","title":"Test Single Rule","text":"<pre><code>require 'test_helper'\n\nclass TestTemperatureRule &lt; Minitest::Test\n  def test_fires_when_temperature_high\n    fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_alert\", priority: 100 do\n        on :sensor,\n          type: \"temperature\",\n          value: :temp?,\n          predicate: greater_than(30)\n\n        perform do |facts, bindings|\n          fired = true\n          fact :alert,\n            type: \"high_temperature\",\n            temperature: bindings[:temp?]\n        end\n      end\n\n      fact :sensor, type: \"temperature\", value: 35\n      run\n    end\n\n    assert fired, \"Rule should fire for high temperature\"\n\n    alerts = kb.engine.facts.select { |f| f.type == :alert }\n    assert_equal 1, alerts.size\n    assert_equal 35, alerts.first[:temperature]\n  end\n\n  def test_does_not_fire_when_temperature_normal\n    fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_alert\", priority: 100 do\n        on :sensor,\n          type: \"temperature\",\n          value: :temp?,\n          predicate: greater_than(30)\n\n        perform do |facts, bindings|\n          fired = true\n          fact :alert,\n            type: \"high_temperature\",\n            temperature: bindings[:temp?]\n        end\n      end\n\n      fact :sensor, type: \"temperature\", value: 25\n      run\n    end\n\n    refute fired, \"Rule should not fire for normal temperature\"\n\n    alerts = kb.engine.facts.select { |f| f.type == :alert }\n    assert_empty alerts\n  end\n\n  def test_threshold_boundary\n    fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_alert\" do\n        on :sensor,\n          type: \"temperature\",\n          value: :temp?,\n          predicate: greater_than(30)\n\n        perform do |facts, bindings|\n          fired = true\n        end\n      end\n\n      # Test at exact threshold\n      fact :sensor, type: \"temperature\", value: 30\n      run\n    end\n\n    refute fired, \"Rule should not fire at exact threshold (&gt; not &gt;=)\"\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#test-rule-with-multiple-conditions","title":"Test Rule with Multiple Conditions","text":"<pre><code>class TestMultiConditionRule &lt; Minitest::Test\n  def test_fires_when_both_conditions_met\n    fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_and_low_humidity\" do\n        on :temperature,\n          location: :loc?,\n          value: :temp?,\n          predicate: greater_than(30)\n\n        on :humidity,\n          location: :loc?,\n          value: :hum?,\n          predicate: less_than(40)\n\n        perform do |facts, bindings|\n          fired = true\n        end\n      end\n\n      fact :temperature, location: \"room1\", value: 35\n      fact :humidity, location: \"room1\", value: 30\n      run\n    end\n\n    assert fired, \"Rule should fire when both conditions met\"\n  end\n\n  def test_does_not_fire_with_mismatched_locations\n    fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_and_low_humidity\" do\n        on :temperature,\n          location: :loc?,\n          value: :temp?,\n          predicate: greater_than(30)\n\n        on :humidity,\n          location: :loc?,\n          value: :hum?,\n          predicate: less_than(40)\n\n        perform do |facts, bindings|\n          fired = true\n        end\n      end\n\n      fact :temperature, location: \"room1\", value: 35\n      fact :humidity, location: \"room2\", value: 30\n      run\n    end\n\n    refute fired, \"Rule should not fire with different locations\"\n  end\n\n  def test_does_not_fire_when_only_temperature_high\n    fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_and_low_humidity\" do\n        on :temperature,\n          location: :loc?,\n          value: :temp?,\n          predicate: greater_than(30)\n\n        on :humidity,\n          location: :loc?,\n          value: :hum?,\n          predicate: less_than(40)\n\n        perform do |facts, bindings|\n          fired = true\n        end\n      end\n\n      fact :temperature, location: \"room1\", value: 35\n      # No humidity fact\n      run\n    end\n\n    refute fired, \"Rule should not fire without humidity fact\"\n  end\n\n  def test_does_not_fire_when_temperature_normal\n    fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_and_low_humidity\" do\n        on :temperature,\n          location: :loc?,\n          value: :temp?,\n          predicate: greater_than(30)\n\n        on :humidity,\n          location: :loc?,\n          value: :hum?,\n          predicate: less_than(40)\n\n        perform do |facts, bindings|\n          fired = true\n        end\n      end\n\n      fact :temperature, location: \"room1\", value: 25\n      fact :humidity, location: \"room1\", value: 30\n      run\n    end\n\n    refute fired, \"Rule should not fire with normal temperature\"\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#test-negated-conditions","title":"Test Negated Conditions","text":"<pre><code>class TestNegationRule &lt; Minitest::Test\n  def test_fires_when_error_not_acknowledged\n    fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"alert_if_no_acknowledgment\" do\n        on :error, id: :id?\n        without :acknowledged, error_id: :id?\n\n        perform do |facts, bindings|\n          fired = true\n        end\n      end\n\n      fact :error, id: 1\n      run\n    end\n\n    assert fired, \"Rule should fire when error not acknowledged\"\n  end\n\n  def test_does_not_fire_when_error_acknowledged\n    fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"alert_if_no_acknowledgment\" do\n        on :error, id: :id?\n        without :acknowledged, error_id: :id?\n\n        perform do |facts, bindings|\n          fired = true\n        end\n      end\n\n      fact :error, id: 1\n      fact :acknowledged, error_id: 1\n      run\n    end\n\n    refute fired, \"Rule should not fire when error acknowledged\"\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"advanced/testing/#test-rule-interactions","title":"Test Rule Interactions","text":"<pre><code>class TestRuleInteractions &lt; Minitest::Test\n  def test_cascading_rules\n    alerts = []\n\n    kb = KBS.knowledge_base do\n      # Rule 1: Detect high temperature\n      rule \"detect_high_temp\" do\n        on :sensor, value: :temp?, predicate: greater_than(30)\n\n        perform do |facts, bindings|\n          fact :temp_alert, severity: \"high\"\n        end\n      end\n\n      # Rule 2: Escalate to critical\n      rule \"escalate_critical\" do\n        on :temp_alert, severity: \"high\"\n        on :sensor, value: :temp?, predicate: greater_than(40)\n\n        perform do |facts, bindings|\n          fact :critical_alert, type: \"temperature\"\n          alerts &lt;&lt; :critical\n        end\n      end\n\n      # Add high temperature\n      fact :sensor, value: 45\n      run\n    end\n\n    # Both rules should fire\n    assert kb.engine.facts.any? { |f| f.type == :temp_alert }\n    assert kb.engine.facts.any? { |f| f.type == :critical_alert }\n    assert_includes alerts, :critical\n  end\n\n  def test_partial_cascade\n    alerts = []\n\n    kb = KBS.knowledge_base do\n      rule \"detect_high_temp\" do\n        on :sensor, value: :temp?, predicate: greater_than(30)\n        perform { fact :temp_alert, severity: \"high\" }\n      end\n\n      rule \"escalate_critical\" do\n        on :temp_alert, severity: \"high\"\n        on :sensor, value: :temp?, predicate: greater_than(40)\n        perform do |facts, bindings|\n          fact :critical_alert, type: \"temperature\"\n          alerts &lt;&lt; :critical\n        end\n      end\n\n      # Add moderately high temperature\n      fact :sensor, value: 35\n      run\n    end\n\n    # Only first rule fires\n    assert kb.engine.facts.any? { |f| f.type == :temp_alert }\n    refute kb.engine.facts.any? { |f| f.type == :critical_alert }\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#test-rule-priority","title":"Test Rule Priority","text":"<pre><code>class TestRulePriority &lt; Minitest::Test\n  def test_executes_in_priority_order\n    execution_order = []\n\n    kb = KBS.knowledge_base do\n      # High priority rule\n      rule \"high_priority\", priority: 100 do\n        on :trigger, {}\n        perform { execution_order &lt;&lt; :high }\n      end\n\n      # Low priority rule\n      rule \"low_priority\", priority: 10 do\n        on :trigger, {}\n        perform { execution_order &lt;&lt; :low }\n      end\n\n      fact :trigger, {}\n      run\n    end\n\n    assert_equal [:high, :low], execution_order\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#test-fixtures","title":"Test Fixtures","text":""},{"location":"advanced/testing/#fact-fixtures","title":"Fact Fixtures","text":"<pre><code>module FactFixtures\n  def sensor_facts(count: 10)\n    count.times.map do |i|\n      { type: :sensor, attributes: { id: i, value: rand(20..40) } }\n    end\n  end\n\n  def high_temp_scenario\n    [\n      { type: :sensor, attributes: { location: \"room1\", value: 35 } },\n      { type: :sensor, attributes: { location: \"room2\", value: 38 } },\n      { type: :threshold, attributes: { value: 30 } }\n    ]\n  end\n\n  def normal_scenario\n    [\n      { type: :sensor, attributes: { location: \"room1\", value: 22 } },\n      { type: :sensor, attributes: { location: \"room2\", value: 24 } },\n      { type: :threshold, attributes: { value: 30 } }\n    ]\n  end\n\n  def load_facts_into_kb(kb, facts)\n    facts.each do |fact_data|\n      kb.fact fact_data[:type], fact_data[:attributes]\n    end\n  end\nend\n\nclass TestWithFixtures &lt; Minitest::Test\n  include FactFixtures\n\n  def test_with_high_temp_scenario\n    kb = KBS.knowledge_base do\n      rule \"check_threshold\" do\n        on :sensor, value: :v?, predicate: greater_than(30)\n        perform { }\n      end\n    end\n\n    load_facts_into_kb(kb, high_temp_scenario)\n    kb.run\n\n    # Assertions...\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#rule-fixtures","title":"Rule Fixtures","text":"<pre><code>module RuleFixtures\n  # Note: Since DSL rules are defined in blocks,\n  # we provide factory methods instead of rule objects\n\n  def add_temperature_monitoring_rules(kb)\n    kb.instance_eval do\n      rule \"detect_high\" do\n        on :sensor, value: :v?, predicate: greater_than(30)\n        perform { |facts, bindings| facts[0][:alerted] = true }\n      end\n\n      rule \"detect_low\" do\n        on :sensor, value: :v?, predicate: less_than(15)\n        perform { |facts, bindings| facts[0][:alerted] = true }\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#coverage-strategies","title":"Coverage Strategies","text":""},{"location":"advanced/testing/#track-rule-firings","title":"Track Rule Firings","text":"<pre><code>class CoverageTracker\n  def initialize(kb)\n    @kb = kb\n    @rule_firings = Hash.new(0)\n  end\n\n  def wrap_rules\n    @kb.engine.instance_variable_get(:@rules).each do |rule|\n      original_action = rule.action\n\n      rule.action = lambda do |facts, bindings|\n        @rule_firings[rule.name] += 1\n        original_action.call(facts, bindings)\n      end\n    end\n  end\n\n  def report\n    puts \"\\n=== Coverage Report ===\"\n\n    total_rules = @kb.engine.instance_variable_get(:@rules).size\n    fired_rules = @rule_firings.keys.size\n    coverage = (fired_rules.to_f / total_rules * 100).round(2)\n\n    puts \"Rules: #{fired_rules}/#{total_rules} (#{coverage}%)\"\n\n    puts \"\\nRule Firings:\"\n    @rule_firings.each do |name, count|\n      puts \"  #{name}: #{count}\"\n    end\n\n    untested = @kb.engine.instance_variable_get(:@rules).map(&amp;:name) - @rule_firings.keys\n    if untested.any?\n      puts \"\\nUntested Rules:\"\n      untested.each { |name| puts \"  - #{name}\" }\n    end\n  end\n\n  attr_reader :rule_firings\nend\n\n# Usage\nclass TestWithCoverage &lt; Minitest::Test\n  def test_coverage\n    kb = KBS.knowledge_base do\n      rule \"rule1\" do\n        on :fact, {}\n        perform { }\n      end\n\n      rule \"rule2\" do\n        on :other, {}\n        perform { }\n      end\n    end\n\n    tracker = CoverageTracker.new(kb)\n    tracker.wrap_rules\n\n    # Add facts and run\n    kb.fact :fact, {}\n    kb.run\n\n    tracker.report\n\n    # Assert all rules fired\n    # (or check specific coverage requirements)\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#condition-coverage","title":"Condition Coverage","text":"<pre><code>def test_all_condition_paths\n  # Test path 1: All conditions pass\n  kb1 = KBS.knowledge_base do\n    rule \"multi_path\" do\n      on :a, {}\n      on :b, {}\n      without :c, {}\n      perform { }\n    end\n\n    fact :a, {}\n    fact :b, {}\n    # c absent\n    run\n  end\n  # Assert...\n\n  # Test path 2: Negation fails\n  kb2 = KBS.knowledge_base do\n    rule \"multi_path\" do\n      on :a, {}\n      on :b, {}\n      without :c, {}\n      perform { }\n    end\n\n    fact :a, {}\n    fact :b, {}\n    fact :c, {}  # Blocks negation\n    run\n  end\n  # Assert...\n\n  # Test path 3: Positive condition missing\n  kb3 = KBS.knowledge_base do\n    rule \"multi_path\" do\n      on :a, {}\n      on :b, {}\n      without :c, {}\n      perform { }\n    end\n\n    fact :a, {}\n    # b missing\n    run\n  end\n  # Assert...\nend\n</code></pre>"},{"location":"advanced/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"advanced/testing/#benchmark-rule-execution","title":"Benchmark Rule Execution","text":"<pre><code>require 'benchmark'\n\nclass PerformanceTest &lt; Minitest::Test\n  def test_rule_performance\n    time = Benchmark.measure do\n      kb = KBS.knowledge_base do\n        rule \"perf_test\" do\n          on :data, value: :v?\n          perform { }\n        end\n\n        # Add many facts\n        1000.times { |i| fact :data, value: i }\n        run\n      end\n    end\n\n    assert time.real &lt; 1.0, \"Engine should complete in under 1 second\"\n  end\n\n  def test_fact_addition_performance\n    kb = KBS.knowledge_base\n\n    time = Benchmark.measure do\n      10_000.times { |i| kb.fact :data, value: i }\n    end\n\n    rate = 10_000 / time.real\n    assert rate &gt; 10_000, \"Should add &gt;10k facts/sec, got #{rate.round(2)}\"\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#testing-blackboard-persistence","title":"Testing Blackboard Persistence","text":""},{"location":"advanced/testing/#test-with-sqlite","title":"Test with SQLite","text":"<pre><code>class TestBlackboardPersistence &lt; Minitest::Test\n  def test_facts_persist_across_sessions\n    # Session 1: Add facts\n    engine1 = KBS::Blackboard::Engine.new(db_path: 'test.db')\n    kb1 = KBS.knowledge_base(engine: engine1) do\n      fact :sensor, id: 1, value: 25\n    end\n    kb1.close\n\n    # Session 2: Load facts\n    engine2 = KBS::Blackboard::Engine.new(db_path: 'test.db')\n    assert_equal 1, engine2.facts.size\n    assert_equal 25, engine2.facts.first[:value]\n\n    engine2.close\n    File.delete('test.db') if File.exist?('test.db')\n  end\n\n  def test_audit_trail\n    engine = KBS::Blackboard::Engine.new(db_path: ':memory:')\n\n    fact = engine.add_fact(:data, value: 1)\n    engine.update_fact(fact.id, value: 2)\n    engine.delete_fact(fact.id)\n\n    history = engine.fact_history(fact.id)\n\n    assert_equal 3, history.size\n    assert_equal \"add\", history[0][:operation]\n    assert_equal \"update\", history[1][:operation]\n    assert_equal \"delete\", history[2][:operation]\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"advanced/testing/#1-isolate-rules","title":"1. Isolate Rules","text":"<pre><code>def test_single_rule_only\n  kb = KBS.knowledge_base do\n    # Add ONLY the rule being tested\n    rule \"my_test_rule\" do\n      on :trigger, {}\n      perform { }\n    end\n\n    # No other rules to interfere\n    fact :trigger, {}\n    run\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#2-test-edge-cases","title":"2. Test Edge Cases","text":"<pre><code>def test_edge_cases\n  # Empty facts\n  kb = KBS.knowledge_base do\n    rule \"check\" do\n      on :sensor, value: :v?\n      perform { }\n    end\n    run\n  end\n  assert_empty kb.engine.facts.select { |f| f.type == :alert }\n\n  # Exact threshold\n  kb = KBS.knowledge_base do\n    rule \"check\" do\n      on :sensor, value: :v?, predicate: greater_than(30)\n      perform { }\n    end\n    fact :sensor, value: 30\n    run\n  end\n\n  # Just below threshold\n  kb = KBS.knowledge_base do\n    rule \"check\" do\n      on :sensor, value: :v?, predicate: greater_than(30)\n      perform { }\n    end\n    fact :sensor, value: 29.99\n    run\n  end\n\n  # Just above threshold\n  kb = KBS.knowledge_base do\n    rule \"check\" do\n      on :sensor, value: :v?, predicate: greater_than(30)\n      perform { }\n    end\n    fact :sensor, value: 30.01\n    run\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#3-test-side-effects","title":"3. Test Side Effects","text":"<pre><code>def test_action_side_effects\n  added_facts = []\n\n  kb = KBS.knowledge_base do\n    rule \"test\" do\n      on :trigger, {}\n      perform do |facts, bindings|\n        new_fact = fact :result, value: 42\n        added_facts &lt;&lt; new_fact\n      end\n    end\n\n    fact :trigger, {}\n    run\n  end\n\n  assert_equal 1, added_facts.size\n  assert_equal 42, added_facts.first[:value]\nend\n</code></pre>"},{"location":"advanced/testing/#4-use-descriptive-test-names","title":"4. Use Descriptive Test Names","text":"<pre><code>def test_high_temperature_alert_fires_when_sensor_exceeds_threshold\n  # Clear what this tests\nend\n\ndef test_alert_not_sent_twice_for_same_sensor\n  # Explains the scenario\nend\n</code></pre>"},{"location":"advanced/testing/#5-setup-and-teardown","title":"5. Setup and Teardown","text":"<pre><code>class TestWithSetup &lt; Minitest::Test\n  def setup\n    @test_db = \"test_#{SecureRandom.hex(8)}.db\"\n  end\n\n  def teardown\n    File.delete(@test_db) if File.exist?(@test_db)\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#testing-checklist","title":"Testing Checklist","text":"<ul> <li> Test each rule fires with correct facts</li> <li> Test each rule doesn't fire without required facts</li> <li> Test boundary conditions</li> <li> Test negated conditions</li> <li> Test variable bindings</li> <li> Test rule priorities</li> <li> Test rule interactions</li> <li> Test action side effects</li> <li> Test persistence (if using blackboard)</li> <li> Measure performance</li> <li> Achieve high rule coverage</li> </ul>"},{"location":"advanced/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Debugging Guide - Debug failing tests</li> <li>Performance Guide - Optimize slow tests</li> <li>Architecture - Understand rule execution</li> <li>Examples - See tested examples</li> </ul> <p>Good tests make rule changes safe. Test each rule thoroughly.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete class documentation for KBS.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":"<ul> <li>Engine - Main RETE engine</li> <li>Facts &amp; Conditions - Pattern matching</li> <li>Rules - Production rules</li> <li>Blackboard - Persistent memory</li> </ul>"},{"location":"api/#architecture","title":"Architecture","text":"<p>See Architecture Overview for system design.</p>"},{"location":"api/blackboard/","title":"Blackboard API Reference","text":"<p>Complete API reference for blackboard memory classes.</p>"},{"location":"api/blackboard/#table-of-contents","title":"Table of Contents","text":"<ul> <li>KBS::Blackboard::Memory - Central blackboard workspace</li> <li>KBS::Blackboard::MessageQueue - Inter-agent communication</li> <li>KBS::Blackboard::AuditLog - Historical tracking</li> <li>Usage Patterns</li> </ul>"},{"location":"api/blackboard/#kbsblackboardmemory","title":"KBS::Blackboard::Memory","text":"<p>The central blackboard workspace that coordinates facts, messages, and audit logging.</p> <p>Architecture: Composes three components: 1. Store - Persistence layer (SQLite, Redis, or Hybrid) 2. MessageQueue - Priority-based inter-agent messaging 3. AuditLog - Complete history of fact changes and rule firings</p>"},{"location":"api/blackboard/#constructor","title":"Constructor","text":""},{"location":"api/blackboard/#initializedb_path-memory-store-nil","title":"<code>initialize(db_path: ':memory:', store: nil)</code>","text":"<p>Creates a new blackboard memory.</p> <p>Parameters: - <code>db_path</code> (String, optional) - Path to SQLite database (default: <code>:memory:</code>) - <code>store</code> (KBS::Blackboard::Persistence::Store, optional) - Custom store (default: <code>nil</code>, creates SQLiteStore)</p> <p>Returns: <code>KBS::Blackboard::Memory</code> instance</p> <p>Side Effects: - Generates session UUID - Creates or connects to persistence store - Initializes message queue and audit log - Sets up database tables/indexes</p> <p>Example - In-Memory: <pre><code>memory = KBS::Blackboard::Memory.new\n# Blackboard stored in RAM (lost on exit)\n</code></pre></p> <p>Example - SQLite Persistence: <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'knowledge_base.db')\n# Facts persisted to knowledge_base.db\n</code></pre></p> <p>Example - Redis Store: <pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(url: 'redis://localhost:6379/0')\nmemory = KBS::Blackboard::Memory.new(store: store)\n# Fast, distributed persistence\n</code></pre></p> <p>Example - Hybrid Store: <pre><code>require 'kbs/blackboard/persistence/hybrid_store'\n\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\nmemory = KBS::Blackboard::Memory.new(store: store)\n# Facts in Redis, audit trail in SQLite\n</code></pre></p>"},{"location":"api/blackboard/#public-attributes","title":"Public Attributes","text":""},{"location":"api/blackboard/#session_id","title":"<code>session_id</code>","text":"<p>Type: <code>String</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Unique session identifier (UUID)</p> <p>Example: <pre><code>memory = KBS::Blackboard::Memory.new\nputs memory.session_id  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre></p> <p>Use Cases: - Filter audit log by session - Separate facts from different runs - Debugging multi-session scenarios</p>"},{"location":"api/blackboard/#store","title":"<code>store</code>","text":"<p>Type: <code>KBS::Blackboard::Persistence::Store</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The underlying persistence store</p> <p>Example: <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'kb.db')\nputs memory.store.class  # =&gt; KBS::Blackboard::Persistence::SqliteStore\n</code></pre></p>"},{"location":"api/blackboard/#message_queue","title":"<code>message_queue</code>","text":"<p>Type: <code>KBS::Blackboard::MessageQueue</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The message queue for inter-agent communication</p> <p>Example: <pre><code>memory.message_queue.post(\"agent1\", \"alerts\", { level: \"critical\" })\n</code></pre></p>"},{"location":"api/blackboard/#audit_log","title":"<code>audit_log</code>","text":"<p>Type: <code>KBS::Blackboard::AuditLog</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The audit log for tracking all changes</p> <p>Example: <pre><code>history = memory.audit_log.fact_history(fact.uuid)\n</code></pre></p>"},{"location":"api/blackboard/#fact-management-methods","title":"Fact Management Methods","text":""},{"location":"api/blackboard/#add_facttype-attributes","title":"<code>add_fact(type, attributes = {})</code>","text":"<p>Adds a persistent fact to the blackboard.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type - <code>attributes</code> (Hash, optional) - Fact attributes (default: <code>{}</code>)</p> <p>Returns: <code>KBS::Blackboard::Fact</code> - Persistent fact with UUID</p> <p>Side Effects: - Generates UUID for fact - Saves fact to store (within transaction) - Logs addition to audit log - Notifies observers</p> <p>Example: <pre><code>fact = memory.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact.uuid  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\nputs fact.type  # =&gt; :temperature\nputs fact[:value]  # =&gt; 85\n</code></pre></p> <p>Transaction Handling: <pre><code>memory.transaction do\n  fact1 = memory.add_fact(:order, id: 1, status: \"pending\")\n  fact2 = memory.add_fact(:inventory, item: \"ABC\", quantity: 100)\n  # Both facts committed together\nend\n</code></pre></p>"},{"location":"api/blackboard/#remove_factfact","title":"<code>remove_fact(fact)</code>","text":"<p>Removes a fact from the blackboard.</p> <p>Parameters: - <code>fact</code> (KBS::Blackboard::Fact or String) - Fact object or UUID</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Marks fact as inactive in store - Logs removal to audit log - Notifies observers</p> <p>Example: <pre><code>fact = memory.add_fact(:temperature, value: 85)\nmemory.remove_fact(fact)\n\n# Or by UUID\nmemory.remove_fact(\"550e8400-e29b-41d4-a716-446655440000\")\n\n# Fact remains in audit log\nhistory = memory.get_history(fact.uuid)\nputs history.last[:action]  # =&gt; \"REMOVE\"\n</code></pre></p>"},{"location":"api/blackboard/#update_factfact-new_attributes","title":"<code>update_fact(fact, new_attributes)</code>","text":"<p>Updates a fact's attributes.</p> <p>Parameters: - <code>fact</code> (KBS::Blackboard::Fact or String) - Fact object or UUID - <code>new_attributes</code> (Hash) - New attributes to merge</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Updates fact in store - Logs update to audit log</p> <p>Example: <pre><code>fact = memory.add_fact(:temperature, location: \"server_room\", value: 85)\nmemory.update_fact(fact, value: 90, timestamp: Time.now)\n\n# Or by UUID\nmemory.update_fact(fact.uuid, value: 95)\n</code></pre></p> <p>Note: Updates do NOT notify observers or trigger rule re-evaluation. For that, retract and re-add the fact.</p>"},{"location":"api/blackboard/#get_factstype-nil-pattern","title":"<code>get_facts(type = nil, pattern = {})</code>","text":"<p>Retrieves facts from the blackboard.</p> <p>Parameters: - <code>type</code> (Symbol, optional) - Filter by fact type (default: <code>nil</code>, all types) - <code>pattern</code> (Hash, optional) - Additional attribute filters (default: <code>{}</code>)</p> <p>Returns: <code>Array&lt;KBS::Blackboard::Fact&gt;</code></p> <p>Example: <pre><code># Get all facts\nall_facts = memory.get_facts\n\n# Get all temperature facts\ntemps = memory.get_facts(:temperature)\n\n# Get temperature facts from specific location\nserver_temps = memory.get_facts(:temperature, location: \"server_room\")\n</code></pre></p> <p>Performance: O(N) where N = total facts (uses linear scan). For large datasets, consider <code>query_facts</code>.</p>"},{"location":"api/blackboard/#facts","title":"<code>facts</code>","text":"<p>Alias for <code>get_facts()</code>. Returns all facts.</p> <p>Returns: <code>Array&lt;KBS::Blackboard::Fact&gt;</code></p> <p>Example: <pre><code>puts \"Total facts: #{memory.facts.size}\"\n</code></pre></p>"},{"location":"api/blackboard/#query_factssql_conditions-nil-params","title":"<code>query_facts(sql_conditions = nil, params = [])</code>","text":"<p>Advanced SQL query for facts (SQLite store only).</p> <p>Parameters: - <code>sql_conditions</code> (String, optional) - SQL WHERE clause (default: <code>nil</code>) - <code>params</code> (Array, optional) - Parameters for SQL query (default: <code>[]</code>)</p> <p>Returns: <code>Array&lt;KBS::Blackboard::Fact&gt;</code></p> <p>Example: <pre><code># Query with SQL condition\nhigh_temps = memory.query_facts(\n  \"fact_type = ? AND json_extract(attributes, '$.value') &gt; ?\",\n  [:temperature, 80]\n)\n\n# Complex query\nrecent_errors = memory.query_facts(\n  \"fact_type = ? AND datetime(json_extract(attributes, '$.timestamp')) &gt; datetime(?)\",\n  [:error, (Time.now - 3600).iso8601]\n)\n</code></pre></p> <p>Important: Only works with SQLite stores. Redis stores will raise NotImplementedError.</p>"},{"location":"api/blackboard/#message-queue-methods","title":"Message Queue Methods","text":""},{"location":"api/blackboard/#post_messagesender-topic-content-priority-0","title":"<code>post_message(sender, topic, content, priority: 0)</code>","text":"<p>Posts a message to the blackboard message queue.</p> <p>Parameters: - <code>sender</code> (String) - Sender identifier (e.g., agent name) - <code>topic</code> (String) - Message topic (channel/category) - <code>content</code> (Hash) - Message payload - <code>priority</code> (Integer, optional) - Message priority (default: 0, higher = more urgent)</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Adds message to queue - Persists to store</p> <p>Example: <pre><code># Post high-priority alert\nmemory.post_message(\n  \"temperature_agent\",\n  \"alerts\",\n  { level: \"critical\", value: 110, location: \"server_room\" },\n  priority: 100\n)\n\n# Post normal-priority task\nmemory.post_message(\n  \"scheduler\",\n  \"tasks\",\n  { task_name: \"cleanup\", params: {} },\n  priority: 10\n)\n</code></pre></p> <p>Message Ordering: Messages consumed in priority order (highest first), then FIFO within same priority.</p>"},{"location":"api/blackboard/#consume_messagetopic-consumer","title":"<code>consume_message(topic, consumer)</code>","text":"<p>Retrieves and removes the highest priority message from a topic.</p> <p>Parameters: - <code>topic</code> (String) - Topic to consume from - <code>consumer</code> (String) - Consumer identifier (for audit trail)</p> <p>Returns: <code>Hash</code> or <code>nil</code> - Message hash with <code>:id</code>, <code>:sender</code>, <code>:topic</code>, <code>:content</code>, <code>:priority</code>, <code>:posted_at</code>, or <code>nil</code> if queue empty</p> <p>Side Effects: - Removes message from queue (atomic operation) - Marks message as consumed - Records consumer and consumption timestamp</p> <p>Example: <pre><code># Consumer loop\nloop do\n  msg = memory.consume_message(\"tasks\", \"worker_1\")\n  break unless msg\n\n  puts \"Processing: #{msg[:content][:task_name]} (priority #{msg[:priority]})\"\n  puts \"Sent by: #{msg[:sender]} at #{msg[:posted_at]}\"\n\n  # Process message...\n  process_task(msg[:content])\nend\n</code></pre></p> <p>Thread Safety: Atomic pop (safe for concurrent consumers with PostgreSQL/Redis).</p>"},{"location":"api/blackboard/#peek_messagestopic-limit-10","title":"<code>peek_messages(topic, limit: 10)</code>","text":"<p>Views messages in queue without consuming them.</p> <p>Parameters: - <code>topic</code> (String) - Topic to peek - <code>limit</code> (Integer, optional) - Max messages to return (default: 10)</p> <p>Returns: <code>Array&lt;Hash&gt;</code> - Array of message hashes (same format as <code>consume_message</code>)</p> <p>Example: <pre><code># Check queue depth\npending = memory.peek_messages(\"tasks\", limit: 100)\nputs \"Pending tasks: #{pending.size}\"\n\n# Inspect high-priority messages\npending.each do |msg|\n  if msg[:priority] &gt; 50\n    puts \"High priority: #{msg[:content][:task_name]}\"\n  end\nend\n</code></pre></p> <p>Use Cases: - Monitor queue depth - Inspect waiting messages - Debugging message flow</p>"},{"location":"api/blackboard/#audit-log-methods","title":"Audit Log Methods","text":""},{"location":"api/blackboard/#log_rule_firingrule_name-fact_uuids-bindings","title":"<code>log_rule_firing(rule_name, fact_uuids, bindings = {})</code>","text":"<p>Logs a rule firing event.</p> <p>Parameters: - <code>rule_name</code> (String) - Name of fired rule - <code>fact_uuids</code> (Array) - UUIDs of facts that matched - <code>bindings</code> (Hash, optional) - Variable bindings (default: <code>{}</code>) <p>Returns: <code>nil</code></p> <p>Side Effects: - Adds entry to audit log - Records timestamp and session ID</p> <p>Example: <pre><code># Typically called by engine, but can be called manually\nmemory.log_rule_firing(\n  \"high_temperature_alert\",\n  [fact1.uuid, fact2.uuid],\n  { :temp? =&gt; 85, :location? =&gt; \"server_room\" }\n)\n</code></pre></p> <p>Note: <code>KBS::Blackboard::Engine</code> calls this automatically. Manual calls useful for custom logging.</p>"},{"location":"api/blackboard/#get_historyfact_uuid-nil-limit-100","title":"<code>get_history(fact_uuid = nil, limit: 100)</code>","text":"<p>Retrieves fact change history.</p> <p>Parameters: - <code>fact_uuid</code> (String, optional) - Filter by fact UUID (default: <code>nil</code>, all facts) - <code>limit</code> (Integer, optional) - Max entries to return (default: 100)</p> <p>Returns: <code>Array&lt;Hash&gt;</code> - Array of history entries with <code>:fact_uuid</code>, <code>:fact_type</code>, <code>:attributes</code>, <code>:action</code>, <code>:timestamp</code>, <code>:session_id</code></p> <p>Example: <pre><code># Get history for specific fact\nfact = memory.add_fact(:temperature, value: 85)\nmemory.update_fact(fact, value: 90)\nmemory.update_fact(fact, value: 95)\n\nhistory = memory.get_history(fact.uuid)\nhistory.each do |entry|\n  puts \"#{entry[:timestamp]}: #{entry[:action]} - #{entry[:attributes][:value]}\"\nend\n\n# Output:\n# 2025-01-15 10:30:03: UPDATE - 95\n# 2025-01-15 10:30:02: UPDATE - 90\n# 2025-01-15 10:30:00: ADD - 85\n</code></pre></p> <p>All Facts History: <pre><code># Get recent changes across all facts\nrecent_changes = memory.get_history(limit: 50)\n</code></pre></p>"},{"location":"api/blackboard/#get_rule_firingsrule_name-nil-limit-100","title":"<code>get_rule_firings(rule_name = nil, limit: 100)</code>","text":"<p>Retrieves rule firing history.</p> <p>Parameters: - <code>rule_name</code> (String, optional) - Filter by rule name (default: <code>nil</code>, all rules) - <code>limit</code> (Integer, optional) - Max entries to return (default: 100)</p> <p>Returns: <code>Array&lt;Hash&gt;</code> - Array of firing entries with <code>:rule_name</code>, <code>:fact_uuids</code>, <code>:bindings</code>, <code>:fired_at</code>, <code>:session_id</code></p> <p>Example: <pre><code># Get firings for specific rule\nfirings = memory.get_rule_firings(\"high_temperature_alert\", limit: 10)\nfirings.each do |firing|\n  puts \"#{firing[:fired_at]}: #{firing[:rule_name]}\"\n  puts \"  Bindings: #{firing[:bindings]}\"\n  puts \"  Facts: #{firing[:fact_uuids]}\"\nend\n\n# All rule firings\nall_firings = memory.get_rule_firings(limit: 100)\n</code></pre></p> <p>Use Cases: - Debugging rule behavior - Performance analysis - Compliance auditing</p>"},{"location":"api/blackboard/#knowledge-source-methods","title":"Knowledge Source Methods","text":""},{"location":"api/blackboard/#register_knowledge_sourcename-description-nil-topics","title":"<code>register_knowledge_source(name, description: nil, topics: [])</code>","text":"<p>Registers an agent/knowledge source.</p> <p>Parameters: - <code>name</code> (String) - Knowledge source name - <code>description</code> (String, optional) - Description (default: <code>nil</code>) - <code>topics</code> (Array, optional) - Topics this source produces/consumes (default: <code>[]</code>) <p>Returns: <code>nil</code></p> <p>Side Effects: - Stores knowledge source metadata in database</p> <p>Example: <pre><code>memory.register_knowledge_source(\n  \"TemperatureMonitor\",\n  description: \"Monitors temperature sensors and generates alerts\",\n  topics: [\"temperature_readings\", \"alerts\"]\n)\n\nmemory.register_knowledge_source(\n  \"AlertDispatcher\",\n  description: \"Dispatches alerts to external systems\",\n  topics: [\"alerts\"]\n)\n</code></pre></p> <p>Use Cases: - Document multi-agent systems - Visualize agent architecture - Track message flow</p>"},{"location":"api/blackboard/#observer-pattern-methods","title":"Observer Pattern Methods","text":""},{"location":"api/blackboard/#add_observerobserver","title":"<code>add_observer(observer)</code>","text":"<p>Registers an observer to receive fact change notifications.</p> <p>Parameters: - <code>observer</code> - Object responding to <code>update(action, fact)</code> method</p> <p>Returns: <code>nil</code></p> <p>Side Effects: Adds observer to internal observers list</p> <p>Example: <pre><code>class FactLogger\n  def update(action, fact)\n    case action\n    when :add\n      puts \"Added: #{fact.type} #{fact.attributes}\"\n    when :remove\n      puts \"Removed: #{fact.uuid}\"\n    end\n  end\nend\n\nlogger = FactLogger.new\nmemory.add_observer(logger)\n\nmemory.add_fact(:temperature, value: 85)\n# Output: Added: temperature {:value=&gt;85}\n</code></pre></p> <p>Important: Observers are NOT persisted. Re-register after restart.</p>"},{"location":"api/blackboard/#session-management-methods","title":"Session Management Methods","text":""},{"location":"api/blackboard/#clear_session","title":"<code>clear_session</code>","text":"<p>Removes all facts from current session.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Removes facts with matching session_id - Preserves audit log</p> <p>Example: <pre><code># Add facts\nmemory.add_fact(:temperature, value: 85)\nmemory.add_fact(:humidity, value: 60)\n\n# Clear session facts\nmemory.clear_session\n\n# Facts removed, but audit log intact\nputs memory.facts.size  # =&gt; 0\nputs memory.get_history.size  # =&gt; 2 (ADD entries still present)\n</code></pre></p>"},{"location":"api/blackboard/#transactionblock","title":"<code>transaction(&amp;block)</code>","text":"<p>Executes block within database transaction.</p> <p>Parameters: - <code>&amp;block</code> - Block to execute</p> <p>Returns: Result of block</p> <p>Side Effects: - Begins transaction - Executes block - Commits on success - Rolls back on exception</p> <p>Example: <pre><code>memory.transaction do\n  fact1 = memory.add_fact(:order, id: 1, total: 100)\n  fact2 = memory.add_fact(:inventory, item: \"ABC\", quantity: 10)\n\n  # If this raises, both facts are rolled back\n  raise \"Validation failed\" if fact1[:total] &gt; 1000\nend\n</code></pre></p> <p>Nested Transactions: Supported (SQLite uses savepoints).</p>"},{"location":"api/blackboard/#statistics-methods","title":"Statistics Methods","text":""},{"location":"api/blackboard/#stats","title":"<code>stats</code>","text":"<p>Returns blackboard statistics.</p> <p>Parameters: None</p> <p>Returns: <code>Hash</code> with keys: - <code>:facts_count</code> (Integer) - Active facts - <code>:total_messages</code> (Integer) - Total messages (consumed + unconsumed) - <code>:unconsumed_messages</code> (Integer) - Unconsumed messages - <code>:rules_fired</code> (Integer) - Total rule firings</p> <p>Example: <pre><code>stats = memory.stats\nputs \"Facts: #{stats[:facts_count]}\"\nputs \"Messages (unconsumed): #{stats[:unconsumed_messages]}\"\nputs \"Messages (total): #{stats[:total_messages]}\"\nputs \"Rules fired: #{stats[:rules_fired]}\"\n</code></pre></p>"},{"location":"api/blackboard/#maintenance-methods","title":"Maintenance Methods","text":""},{"location":"api/blackboard/#vacuum","title":"<code>vacuum</code>","text":"<p>Optimizes database storage (SQLite only).</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: Reclaims unused database space</p> <p>Example: <pre><code># After deleting many facts\nmemory.vacuum\n</code></pre></p> <p>When to Use: After bulk deletions or periodically for long-running systems.</p>"},{"location":"api/blackboard/#close","title":"<code>close</code>","text":"<p>Closes database connection.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: Closes connection to store</p> <p>Example: <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'kb.db')\n# ... use memory ...\nmemory.close\n</code></pre></p> <p>Important: Required for proper cleanup. Use <code>ensure</code> block: <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'kb.db')\nbegin\n  # ... use memory ...\nensure\n  memory.close\nend\n</code></pre></p>"},{"location":"api/blackboard/#kbsblackboardmessagequeue","title":"KBS::Blackboard::MessageQueue","text":"<p>Priority-based message queue for inter-agent communication.</p> <p>Typically accessed via: <code>memory.message_queue</code> or <code>memory.post_message()</code> / <code>memory.consume_message()</code></p>"},{"location":"api/blackboard/#methods","title":"Methods","text":""},{"location":"api/blackboard/#postsender-topic-content-priority-0","title":"<code>post(sender, topic, content, priority: 0)</code>","text":"<p>Posts a message to the queue.</p> <p>Parameters: - <code>sender</code> (String) - Sender identifier - <code>topic</code> (String) - Message topic - <code>content</code> (Hash or String) - Message payload (auto-converts to JSON) - <code>priority</code> (Integer, optional) - Priority (default: 0)</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>memory.message_queue.post(\"agent1\", \"alerts\", { alert: \"critical\" }, priority: 100)\n</code></pre></p>"},{"location":"api/blackboard/#consumetopic-consumer","title":"<code>consume(topic, consumer)</code>","text":"<p>Consumes highest priority message from topic.</p> <p>Parameters: - <code>topic</code> (String) - Topic to consume from - <code>consumer</code> (String) - Consumer identifier</p> <p>Returns: <code>Hash</code> or <code>nil</code></p> <p>Example: <pre><code>msg = memory.message_queue.consume(\"tasks\", \"worker_1\")\nputs msg[:content] if msg\n</code></pre></p>"},{"location":"api/blackboard/#peektopic-limit-10","title":"<code>peek(topic, limit: 10)</code>","text":"<p>Views messages without consuming.</p> <p>Parameters: - <code>topic</code> (String) - Topic to peek - <code>limit</code> (Integer, optional) - Max messages (default: 10)</p> <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example: <pre><code>pending = memory.message_queue.peek(\"tasks\", limit: 5)\nputs \"Next #{pending.size} tasks:\"\npending.each { |m| puts \"  - #{m[:content]}\" }\n</code></pre></p>"},{"location":"api/blackboard/#stats_1","title":"<code>stats</code>","text":"<p>Returns queue statistics.</p> <p>Returns: <code>Hash</code> with <code>:total_messages</code>, <code>:unconsumed_messages</code></p> <p>Example: <pre><code>stats = memory.message_queue.stats\nputs \"Queue depth: #{stats[:unconsumed_messages]}\"\n</code></pre></p>"},{"location":"api/blackboard/#kbsblackboardauditlog","title":"KBS::Blackboard::AuditLog","text":"<p>Complete audit trail of all fact changes and rule firings.</p> <p>Typically accessed via: <code>memory.audit_log</code> or <code>memory.get_history()</code> / <code>memory.get_rule_firings()</code></p>"},{"location":"api/blackboard/#methods_1","title":"Methods","text":""},{"location":"api/blackboard/#log_fact_changefact_uuid-fact_type-attributes-action","title":"<code>log_fact_change(fact_uuid, fact_type, attributes, action)</code>","text":"<p>Logs a fact change event.</p> <p>Parameters: - <code>fact_uuid</code> (String) - Fact UUID - <code>fact_type</code> (Symbol) - Fact type - <code>attributes</code> (Hash) - Fact attributes - <code>action</code> (String) - Action: \"ADD\", \"UPDATE\", \"REMOVE\"</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>memory.audit_log.log_fact_change(\n  fact.uuid,\n  :temperature,\n  { value: 85 },\n  'ADD'\n)\n</code></pre></p> <p>Note: Automatically called by Memory. Manual calls useful for custom tracking.</p>"},{"location":"api/blackboard/#log_rule_firingrule_name-fact_uuids-bindings_1","title":"<code>log_rule_firing(rule_name, fact_uuids, bindings = {})</code>","text":"<p>Logs a rule firing event.</p> <p>Parameters: - <code>rule_name</code> (String) - Rule name - <code>fact_uuids</code> (Array) - Matched fact UUIDs - <code>bindings</code> (Hash, optional) - Variable bindings (default: <code>{}</code>) <p>Returns: <code>nil</code></p> <p>Example: <pre><code>memory.audit_log.log_rule_firing(\n  \"high_temp_alert\",\n  [fact1.uuid, fact2.uuid],\n  { :temp? =&gt; 85 }\n)\n</code></pre></p>"},{"location":"api/blackboard/#fact_historyfact_uuid-nil-limit-100","title":"<code>fact_history(fact_uuid = nil, limit: 100)</code>","text":"<p>Retrieves fact change history.</p> <p>Parameters: - <code>fact_uuid</code> (String, optional) - Filter by UUID (default: <code>nil</code>) - <code>limit</code> (Integer, optional) - Max entries (default: 100)</p> <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example: <pre><code>history = memory.audit_log.fact_history(fact.uuid, limit: 10)\n</code></pre></p>"},{"location":"api/blackboard/#rule_firingsrule_name-nil-limit-100","title":"<code>rule_firings(rule_name = nil, limit: 100)</code>","text":"<p>Retrieves rule firing history.</p> <p>Parameters: - <code>rule_name</code> (String, optional) - Filter by rule name (default: <code>nil</code>) - <code>limit</code> (Integer, optional) - Max entries (default: 100)</p> <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example: <pre><code>firings = memory.audit_log.rule_firings(\"my_rule\", limit: 50)\n</code></pre></p>"},{"location":"api/blackboard/#stats_2","title":"<code>stats</code>","text":"<p>Returns audit log statistics.</p> <p>Returns: <code>Hash</code> with <code>:rules_fired</code></p> <p>Example: <pre><code>stats = memory.audit_log.stats\nputs \"Total rule firings: #{stats[:rules_fired]}\"\n</code></pre></p>"},{"location":"api/blackboard/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/blackboard/#1-multi-agent-coordination","title":"1. Multi-Agent Coordination","text":"<pre><code># Setup\nmemory = KBS::Blackboard::Memory.new(db_path: 'agents.db')\n\n# Agent 1 - Temperature Monitor\nmemory.register_knowledge_source(\n  \"TempMonitor\",\n  description: \"Monitors temperature sensors\",\n  topics: [\"sensors\", \"alerts\"]\n)\n\ndef monitor_loop(memory)\n  loop do\n    temp = read_sensor\n    fact = memory.add_fact(:temperature, value: temp, timestamp: Time.now)\n\n    if temp &gt; 80\n      memory.post_message(\n        \"TempMonitor\",\n        \"alerts\",\n        { type: \"high_temp\", value: temp },\n        priority: 50\n      )\n    end\n\n    sleep 5\n  end\nend\n\n# Agent 2 - Alert Dispatcher\nmemory.register_knowledge_source(\n  \"AlertDispatcher\",\n  description: \"Sends alerts to external systems\",\n  topics: [\"alerts\"]\n)\n\ndef dispatch_loop(memory)\n  loop do\n    msg = memory.consume_message(\"alerts\", \"AlertDispatcher\")\n    break unless msg\n\n    case msg[:content][:type]\n    when \"high_temp\"\n      send_email_alert(msg[:content][:value])\n    end\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#2-audit-trail-analysis","title":"2. Audit Trail Analysis","text":"<pre><code># Find facts that were updated multiple times\nmemory.get_history(limit: 1000).group_by { |e| e[:fact_uuid] }.each do |uuid, entries|\n  if entries.size &gt; 5\n    puts \"Fact #{uuid} changed #{entries.size} times\"\n    entries.each do |entry|\n      puts \"  #{entry[:timestamp]}: #{entry[:action]} - #{entry[:attributes]}\"\n    end\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#3-rule-performance-analysis","title":"3. Rule Performance Analysis","text":"<pre><code># Analyze rule firing frequency\nfirings = memory.get_rule_firings(limit: 10000)\nby_rule = firings.group_by { |f| f[:rule_name] }\n\nby_rule.each do |rule_name, firings_list|\n  puts \"#{rule_name}: #{firings_list.size} firings\"\n\n  # Calculate average time between firings\n  if firings_list.size &gt; 1\n    times = firings_list.map { |f| f[:fired_at] }.sort\n    intervals = times.each_cons(2).map { |t1, t2| (t2 - t1).to_f }\n    avg_interval = intervals.sum / intervals.size\n    puts \"  Avg interval: #{avg_interval.round(2)} seconds\"\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#4-transaction-based-workflows","title":"4. Transaction-Based Workflows","text":"<pre><code>def process_order(memory, order_data)\n  memory.transaction do\n    # Add order fact\n    order = memory.add_fact(:order, order_data)\n\n    # Check inventory\n    inventory = memory.get_facts(:inventory, product_id: order[:product_id]).first\n    raise \"Insufficient inventory\" if inventory[:quantity] &lt; order[:quantity]\n\n    # Deduct inventory\n    memory.update_fact(inventory, quantity: inventory[:quantity] - order[:quantity])\n\n    # Create shipment fact\n    shipment = memory.add_fact(:shipment, order_id: order.uuid, status: \"pending\")\n\n    # Post message for shipping agent\n    memory.post_message(\n      \"OrderProcessor\",\n      \"shipments\",\n      { shipment_id: shipment.uuid },\n      priority: 10\n    )\n\n    # If any step fails, entire transaction rolls back\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#5-debugging-message-flow","title":"5. Debugging Message Flow","text":"<pre><code># Monitor message queue\ndef monitor_queue(memory, topic)\n  loop do\n    pending = memory.peek_messages(topic, limit: 10)\n    puts \"#{Time.now}: #{pending.size} messages in #{topic} queue\"\n\n    pending.each do |msg|\n      age = Time.now - msg[:posted_at]\n      puts \"  [#{msg[:priority]}] #{msg[:sender]}: #{msg[:content]} (#{age.round}s old)\"\n    end\n\n    sleep 5\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#6-session-isolation","title":"6. Session Isolation","text":"<pre><code># Separate test runs\ntest_memory = KBS::Blackboard::Memory.new(db_path: 'test.db')\nputs \"Session: #{test_memory.session_id}\"\n\n# Run test\ntest_memory.add_fact(:test_marker, run_id: 1)\nrun_tests(test_memory)\n\n# Cleanup session (preserves audit log)\ntest_memory.clear_session\n\n# Analyze audit log across sessions\nall_history = test_memory.get_history(limit: 10000)\nby_session = all_history.group_by { |e| e[:session_id] }\nputs \"Total sessions: #{by_session.size}\"\n</code></pre>"},{"location":"api/blackboard/#7-custom-observer-for-metrics","title":"7. Custom Observer for Metrics","text":"<pre><code>class MetricsObserver\n  def initialize\n    @fact_counts = Hash.new(0)\n    @add_count = 0\n    @remove_count = 0\n  end\n\n  def update(action, fact)\n    case action\n    when :add\n      @add_count += 1\n      @fact_counts[fact.type] += 1\n    when :remove\n      @remove_count += 1\n      @fact_counts[fact.type] -= 1\n    end\n  end\n\n  def report\n    puts \"Facts added: #{@add_count}\"\n    puts \"Facts removed: #{@remove_count}\"\n    puts \"Active facts by type:\"\n    @fact_counts.each do |type, count|\n      puts \"  #{type}: #{count}\"\n    end\n  end\nend\n\nmetrics = MetricsObserver.new\nmemory.add_observer(metrics)\n\n# ... run system ...\n\nmetrics.report\n</code></pre>"},{"location":"api/blackboard/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/blackboard/#message-queue","title":"Message Queue","text":"<ul> <li>Priority indexing: Messages sorted by priority + timestamp</li> <li>Atomic pop: <code>consume</code> uses SELECT + UPDATE in transaction (safe for concurrent consumers)</li> <li>Scaling: For &gt;10,000 messages/sec, use Redis store</li> </ul>"},{"location":"api/blackboard/#audit-log","title":"Audit Log","text":"<ul> <li>Write performance: Each fact change = 1 audit log insert (can be disabled for high-throughput)</li> <li>Query performance: Indexed by <code>fact_uuid</code> and <code>session_id</code></li> <li>Growth: Audit log grows unbounded. Implement periodic archival for production:</li> </ul> <pre><code># Archive old audit entries\ndef archive_old_audit(memory, cutoff_date)\n  memory.store.db.execute(\n    \"DELETE FROM fact_history WHERE timestamp &lt; ?\",\n    [cutoff_date.iso8601]\n  )\n\n  memory.store.db.execute(\n    \"DELETE FROM rules_fired WHERE fired_at &lt; ?\",\n    [cutoff_date.iso8601]\n  )\n\n  memory.vacuum\nend\n\n# Archive entries older than 30 days\narchive_old_audit(memory, Date.today - 30)\n</code></pre>"},{"location":"api/blackboard/#see-also","title":"See Also","text":"<ul> <li>Engine API - Blackboard::Engine integration</li> <li>Facts API - Persistent fact objects</li> <li>Custom Persistence - Implementing custom stores</li> <li>Blackboard Guide - Blackboard pattern overview</li> <li>Blackboard Examples - Multi-agent coordination and blackboard systems</li> </ul>"},{"location":"api/engine/","title":"Engine API Reference","text":"<p>Complete API reference for KBS engine classes.</p>"},{"location":"api/engine/#table-of-contents","title":"Table of Contents","text":"<ul> <li>KBS::Engine - Core RETE engine</li> <li>KBS::Blackboard::Engine - Persistent RETE engine with blackboard</li> <li>Engine Lifecycle</li> <li>Advanced Topics</li> </ul>"},{"location":"api/engine/#kbsengine","title":"KBS::Engine","text":"<p>The core RETE II algorithm engine for in-memory fact processing.</p>"},{"location":"api/engine/#constructor","title":"Constructor","text":""},{"location":"api/engine/#initialize","title":"<code>initialize()</code>","text":"<p>Creates a new in-memory RETE engine.</p> <p>Parameters: None</p> <p>Returns: <code>KBS::Engine</code> instance</p> <p>Example - Low-level API: <pre><code>require 'kbs'\n\nengine = KBS::Engine.new\n# Engine ready with empty working memory\n</code></pre></p> <p>Using DSL (Recommended): <pre><code>require 'kbs'\n\nkb = KBS.knowledge_base do\n  # Engine automatically created\n  # Define rules and facts here\nend\n\n# Access engine if needed\nengine = kb.engine\n</code></pre></p> <p>Internal State Initialized: - <code>@working_memory</code> - WorkingMemory instance - <code>@rules</code> - Array of registered rules - <code>@alpha_memories</code> - Hash of pattern \u2192 AlphaMemory - <code>@production_nodes</code> - Hash of rule name \u2192 ProductionNode - <code>@root_beta_memory</code> - Root BetaMemory with dummy token</p>"},{"location":"api/engine/#public-methods","title":"Public Methods","text":""},{"location":"api/engine/#add_rulerule","title":"<code>add_rule(rule)</code>","text":"<p>Registers a rule and compiles it into the RETE network.</p> <p>Parameters: - <code>rule</code> (Rule) - Rule object with conditions and action</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Builds alpha memories for each condition pattern - Creates join nodes or negation nodes - Creates beta memories for partial matches - Creates production node for rule - Activates existing facts through new network paths</p> <p>Example: <pre><code>rule = KBS::Rule.new(\n  name: \"high_temperature\",\n  priority: 10,\n  conditions: [\n    KBS::Condition.new(:temperature, { location: \"server_room\" })\n  ],\n  action: -&gt;(bindings) { puts \"Alert: High temperature!\" }\n)\n\nengine.add_rule(rule)\n</code></pre></p> <p>Using DSL: <pre><code>kb = KBS.knowledge_base do\n  rule \"high_temperature\", priority: 10 do\n    on :temperature, location: \"server_room\", value: greater_than(80)\n    perform do |facts, bindings|\n      puts \"Alert: #{bindings[:location?]} is #{bindings[:value?]}\u00b0F\"\n    end\n  end\nend\n\nkb.rules.each { |rule| engine.add_rule(rule) }\n</code></pre></p> <p>Performance Notes: - First rule with a pattern creates alpha memory - Subsequent rules sharing patterns reuse alpha memory (network sharing) - Cost is O(C) where C is number of conditions in rule</p>"},{"location":"api/engine/#add_facttype-attributes","title":"<code>add_fact(type, attributes = {})</code>","text":"<p>Adds a fact to working memory and activates matching alpha memories.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type (e.g., <code>:temperature</code>, <code>:order</code>) - <code>attributes</code> (Hash) - Fact attributes (default: <code>{}</code>)</p> <p>Returns: <code>KBS::Fact</code> - The created fact</p> <p>Side Effects: - Creates Fact object - Adds to working memory - Activates all matching alpha memories - Propagates through join nodes - May create new tokens in beta memories</p> <p>Example - Low-level API: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\n# =&gt; #&lt;KBS::Fact:0x00... @type=:temperature @attributes={...}&gt;\n\n# Facts without attributes\nmarker = engine.add_fact(:system_ready)\n# =&gt; #&lt;KBS::Fact:0x00... @type=:system_ready @attributes={}&gt;\n</code></pre></p> <p>Using DSL (Recommended): <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, location: \"server_room\", value: 85\n  fact :system_ready\nend\n</code></pre></p> <p>Thread Safety: Not thread-safe. Wrap in mutex if adding facts from multiple threads.</p> <p>Performance: O(A \u00d7 P) where A is number of alpha memories, P is pattern matching cost</p>"},{"location":"api/engine/#remove_factfact","title":"<code>remove_fact(fact)</code>","text":"<p>Removes a fact from working memory and deactivates it in alpha memories.</p> <p>Parameters: - <code>fact</code> (KBS::Fact) - Fact object to remove (must be exact object reference)</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Removes from working memory - Deactivates fact in all alpha memories - Removes tokens containing this fact - May cause negation nodes to re-evaluate</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nengine.remove_fact(fact)\n\n# Common pattern: Store fact reference for later removal\n@current_alert = engine.add_fact(:alert, level: \"critical\")\n# Later...\nengine.remove_fact(@current_alert) if @current_alert\n</code></pre></p> <p>Important: You must keep a reference to the fact object to remove it. Finding facts requires inspecting <code>engine.working_memory.facts</code>.</p> <p>Example - Finding and Removing: <pre><code># Find all temperature facts\ntemp_facts = engine.working_memory.facts.select { |f| f.type == :temperature }\n\n# Remove specific fact\nold_fact = temp_facts.find { |f| f[:timestamp] &lt; Time.now - 3600 }\nengine.remove_fact(old_fact) if old_fact\n</code></pre></p>"},{"location":"api/engine/#run","title":"<code>run()</code>","text":"<p>Executes all activated rules by firing production nodes.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Fires actions for all tokens in production nodes - Rule actions may add/remove facts - Rule actions may modify external state</p> <p>Example - Low-level API: <pre><code>engine.add_fact(:temperature, value: 85)\nengine.add_fact(:sensor, status: \"active\")\n\n# Facts are in working memory but rules haven't fired\nengine.run  # Execute all matching rules\n\n# Rules fire based on priority (highest first within each production)\n</code></pre></p> <p>Using DSL (Recommended): <pre><code>kb = KBS.knowledge_base do\n  rule \"my_rule\" do\n    on :temperature, value: greater_than(80)\n    perform { puts \"High temperature!\" }\n  end\n\n  fact :temperature, value: 85\n  fact :sensor, status: \"active\"\n\n  run  # Execute all matching rules\nend\n</code></pre></p> <p>Execution Order: - Production nodes fire in arbitrary order (dictionary order by rule name) - Within a production node, tokens fire in insertion order - For priority-based execution, use <code>KBS::Blackboard::Engine</code></p> <p>Example - Multiple Rule Firings: <pre><code>fired_rules = []\n\nkb = KBS.knowledge_base do\n  rule \"rule_a\", priority: 10 do\n    on :temperature, value: greater_than(80)\n    perform { fired_rules &lt;&lt; \"rule_a\" }\n  end\n\n  rule \"rule_b\", priority: 20 do\n    on :temperature, value: greater_than(80)\n    perform { fired_rules &lt;&lt; \"rule_b\" }\n  end\nend\n\nkb.rules.each { |r| engine.add_rule(r) }\nengine.add_fact(:temperature, value: 85)\nengine.run\n\n# Both rules fire (priority doesn't affect KBS::Engine execution order)\nputs fired_rules  # =&gt; [\"rule_a\", \"rule_b\"] or [\"rule_b\", \"rule_a\"]\n</code></pre></p> <p>Best Practice: Call <code>run</code> after batch adding facts: <pre><code># Good - batch facts then run once\nengine.add_fact(:temperature, value: 85)\nengine.add_fact(:humidity, value: 60)\nengine.add_fact(:pressure, value: 1013)\nengine.run\n\n# Avoid - running after each fact (may fire rules prematurely)\nengine.add_fact(:temperature, value: 85)\nengine.run  # Rule may fire with incomplete data\nengine.add_fact(:humidity, value: 60)\nengine.run\n</code></pre></p>"},{"location":"api/engine/#public-attributes","title":"Public Attributes","text":""},{"location":"api/engine/#working_memory","title":"<code>working_memory</code>","text":"<p>Type: <code>KBS::WorkingMemory</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The working memory storing all facts.</p> <p>Example: <pre><code>engine.add_fact(:temperature, value: 85)\nengine.add_fact(:humidity, value: 60)\n\n# Inspect all facts\nputs engine.working_memory.facts.size  # =&gt; 2\n\n# Find specific facts\ntemps = engine.working_memory.facts.select { |f| f.type == :temperature }\ntemps.each do |fact|\n  puts \"Temperature: #{fact[:value]}\"\nend\n</code></pre></p>"},{"location":"api/engine/#rules","title":"<code>rules</code>","text":"<p>Type: <code>Array&lt;KBS::Rule&gt;</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: All registered rules.</p> <p>Example: <pre><code>puts \"Registered rules:\"\nengine.rules.each do |rule|\n  puts \"  - #{rule.name} (priority: #{rule.priority})\"\n  puts \"    Conditions: #{rule.conditions.size}\"\nend\n</code></pre></p>"},{"location":"api/engine/#alpha_memories","title":"<code>alpha_memories</code>","text":"<p>Type: <code>Hash&lt;Hash, KBS::AlphaMemory&gt;</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Pattern \u2192 AlphaMemory mapping.</p> <p>Example: <pre><code># Inspect alpha memories (useful for debugging)\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern: #{pattern}\"\n  puts \"  Facts: #{memory.facts.size}\"\n  puts \"  Successors: #{memory.successors.size}\"\nend\n</code></pre></p>"},{"location":"api/engine/#production_nodes","title":"<code>production_nodes</code>","text":"<p>Type: <code>Hash&lt;Symbol, KBS::ProductionNode&gt;</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Rule name \u2192 ProductionNode mapping.</p> <p>Example: <pre><code># Check if a rule is activated\nprod_node = engine.production_nodes[:high_temperature]\nif prod_node &amp;&amp; prod_node.tokens.any?\n  puts \"Rule 'high_temperature' has #{prod_node.tokens.size} activations\"\nend\n</code></pre></p>"},{"location":"api/engine/#observer-pattern","title":"Observer Pattern","text":"<p>The engine implements the observer pattern to watch fact changes.</p>"},{"location":"api/engine/#updateaction-fact-internal","title":"<code>update(action, fact)</code> (Internal)","text":"<p>Parameters: - <code>action</code> (Symbol) - <code>:add</code> or <code>:remove</code> - <code>fact</code> (KBS::Fact) - The fact that changed</p> <p>Description: Called automatically by WorkingMemory when facts change. Activates/deactivates alpha memories.</p> <p>Example - Custom Observer: <pre><code>class FactLogger\n  def update(action, fact)\n    puts \"[#{Time.now}] #{action.upcase}: #{fact.type} #{fact.attributes}\"\n  end\nend\n\nlogger = FactLogger.new\nengine.working_memory.add_observer(logger)\n\nengine.add_fact(:temperature, value: 85)\n# Output: [2025-01-15 10:30:00] ADD: temperature {:value=&gt;85}\n</code></pre></p>"},{"location":"api/engine/#kbsblackboardengine","title":"KBS::Blackboard::Engine","text":"<p>Persistent RETE engine with blackboard memory, audit logging, and message queue.</p> <p>Inherits: <code>KBS::Engine</code></p> <p>Key Differences from KBS::Engine: - Persistent facts (SQLite, Redis, or Hybrid) - Audit trail of all fact changes - Message queue for inter-agent communication - Transaction support - Observer notifications - Rule firing logged with bindings</p>"},{"location":"api/engine/#constructor_1","title":"Constructor","text":""},{"location":"api/engine/#initializedb_path-memory-store-nil","title":"<code>initialize(db_path: ':memory:', store: nil)</code>","text":"<p>Creates a persistent RETE engine with blackboard memory.</p> <p>Parameters: - <code>db_path</code> (String, optional) - Path to SQLite database (default: <code>:memory:</code>) - <code>store</code> (Store, optional) - Custom persistence store (default: <code>nil</code>, uses SQLiteStore)</p> <p>Returns: <code>KBS::Blackboard::Engine</code> instance</p> <p>Example - In-Memory: <pre><code>engine = KBS::Blackboard::Engine.new\n# Blackboard in RAM (lost on exit)\n</code></pre></p> <p>Example - SQLite Persistence: <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'knowledge_base.db')\n# Facts persisted to knowledge_base.db\n</code></pre></p> <p>Using DSL with Blackboard (Recommended): <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'knowledge_base.db')\n\nkb = KBS.knowledge_base(engine: engine) do\n  rule \"persistent_rule\" do\n    on :temperature, value: greater_than(80)\n    perform { puts \"High temp alert!\" }\n  end\n\n  fact :temperature, value: 85\n  run\nend\n\n# Facts persist across restarts\nkb.close\n</code></pre></p> <p>Example - Redis Persistence: <pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(url: 'redis://localhost:6379/0')\nengine = KBS::Blackboard::Engine.new(store: store)\n# Fast, distributed persistence\n</code></pre></p> <p>Example - Hybrid Persistence: <pre><code>require 'kbs/blackboard/persistence/hybrid_store'\n\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\nengine = KBS::Blackboard::Engine.new(store: store)\n# Facts in Redis, audit trail in SQLite\n</code></pre></p>"},{"location":"api/engine/#public-methods_1","title":"Public Methods","text":""},{"location":"api/engine/#add_facttype-attributes_1","title":"<code>add_fact(type, attributes = {})</code>","text":"<p>Adds a persistent fact to the blackboard.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type - <code>attributes</code> (Hash) - Fact attributes</p> <p>Returns: <code>KBS::Blackboard::Fact</code> - Persistent fact with UUID</p> <p>Side Effects: - Creates fact with UUID - Saves to persistent store - Logs to audit trail - Activates alpha memories - Notifies observers</p> <p>Example - Low-level API: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact.uuid  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Fact persists across restarts\nengine2 = KBS::Blackboard::Engine.new(db_path: 'knowledge_base.db')\nreloaded_facts = engine2.blackboard.get_facts_by_type(:temperature)\nputs reloaded_facts.first[:value]  # =&gt; 85\n</code></pre></p> <p>Using DSL (Recommended): <pre><code># Session 1\nengine = KBS::Blackboard::Engine.new(db_path: 'knowledge_base.db')\nkb = KBS.knowledge_base(engine: engine) do\n  fact :temperature, location: \"server_room\", value: 85\nend\nkb.close\n\n# Session 2 - facts still available\nengine2 = KBS::Blackboard::Engine.new(db_path: 'knowledge_base.db')\ntemps = engine2.blackboard.get_facts_by_type(:temperature)\nputs temps.first[:value]  # =&gt; 85\n</code></pre></p> <p>Difference from KBS::Engine: Returns <code>KBS::Blackboard::Fact</code> (has <code>.uuid</code>) instead of <code>KBS::Fact</code>.</p>"},{"location":"api/engine/#remove_factfact_1","title":"<code>remove_fact(fact)</code>","text":"<p>Removes a persistent fact from the blackboard.</p> <p>Parameters: - <code>fact</code> (KBS::Blackboard::Fact) - Fact to remove</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Marks fact as inactive in store - Logs removal to audit trail - Deactivates in alpha memories - Notifies observers</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nengine.remove_fact(fact)\n\n# Fact marked inactive but remains in audit trail\naudit = engine.blackboard.audit_log.get_fact_history(fact.uuid)\nputs audit.last[:action]  # =&gt; \"retract\"\n</code></pre></p>"},{"location":"api/engine/#run_1","title":"<code>run()</code>","text":"<p>Executes activated rules with audit logging.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Fires rules in production nodes - Logs each rule firing to audit trail - Records fact UUIDs and variable bindings - Marks tokens as fired (prevents duplicate firing)</p> <p>Example: <pre><code>engine.add_rule(my_rule)\nengine.add_fact(:temperature, value: 85)\nengine.run\n\n# Check audit log\nengine.blackboard.audit_log.entries.each do |entry|\n  next unless entry[:event_type] == \"rule_fired\"\n  puts \"Rule #{entry[:rule_name]} fired with bindings: #{entry[:bindings]}\"\nend\n</code></pre></p> <p>Difference from KBS::Engine: - Logs every rule firing - Prevents duplicate firing of same token - Records variable bindings in audit</p>"},{"location":"api/engine/#post_messagesender-topic-content-priority-0","title":"<code>post_message(sender, topic, content, priority: 0)</code>","text":"<p>Posts a message to the blackboard message queue.</p> <p>Parameters: - <code>sender</code> (String) - Sender identifier (e.g., agent name) - <code>topic</code> (String) - Message topic (channel) - <code>content</code> (Hash) - Message payload - <code>priority</code> (Integer, optional) - Message priority (default: 0, higher = more urgent)</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Adds message to queue - Persists to store - Higher priority messages consumed first</p> <p>Example: <pre><code># Agent 1 posts message\nengine.post_message(\n  \"trading_agent\",\n  \"orders\",\n  { action: \"buy\", symbol: \"AAPL\", quantity: 100 },\n  priority: 10\n)\n\n# Agent 2 consumes message\nmsg = engine.consume_message(\"orders\", \"execution_agent\")\nputs msg[:content][:action]  # =&gt; \"buy\"\nputs msg[:sender]  # =&gt; \"trading_agent\"\n</code></pre></p> <p>Use Cases: - Inter-agent communication - Command/event bus - Task queues - Priority-based scheduling</p>"},{"location":"api/engine/#consume_messagetopic-consumer","title":"<code>consume_message(topic, consumer)</code>","text":"<p>Retrieves and removes the highest priority message from a topic.</p> <p>Parameters: - <code>topic</code> (String) - Topic to consume from - <code>consumer</code> (String) - Consumer identifier (for audit trail)</p> <p>Returns: <code>Hash</code> or <code>nil</code> - Message hash with <code>:id</code>, <code>:sender</code>, <code>:topic</code>, <code>:content</code>, <code>:priority</code>, <code>:timestamp</code>, or <code>nil</code> if queue empty</p> <p>Side Effects: - Removes message from queue - Logs consumption to audit trail (if store supports it)</p> <p>Example: <pre><code># Consumer loop\nloop do\n  msg = engine.consume_message(\"tasks\", \"worker_1\")\n  break unless msg\n\n  puts \"Processing: #{msg[:content][:task_name]} (priority #{msg[:priority]})\"\n  # Process message...\nend\n</code></pre></p> <p>Thread Safety: Atomic pop operation (PostgreSQL/Redis stores support concurrent consumers)</p>"},{"location":"api/engine/#stats","title":"<code>stats()</code>","text":"<p>Returns blackboard statistics.</p> <p>Parameters: None</p> <p>Returns: <code>Hash</code> with keys: - <code>:facts_count</code> (Integer) - Number of active facts - <code>:messages_count</code> (Integer) - Number of queued messages (all topics) - <code>:audit_entries_count</code> (Integer) - Total audit log entries</p> <p>Example: <pre><code>stats = engine.stats\nputs \"Facts: #{stats[:facts_count]}\"\nputs \"Messages: #{stats[:messages_count]}\"\nputs \"Audit entries: #{stats[:audit_entries_count]}\"\n</code></pre></p> <p>Performance: May be slow for large databases (counts all rows)</p>"},{"location":"api/engine/#public-attributes_1","title":"Public Attributes","text":""},{"location":"api/engine/#blackboard","title":"<code>blackboard</code>","text":"<p>Type: <code>KBS::Blackboard::Memory</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The blackboard memory (also accessible as <code>working_memory</code>).</p> <p>Example: <pre><code># Access blackboard components\nengine.blackboard.message_queue.post(\"agent1\", \"alerts\", { alert: \"critical\" })\nengine.blackboard.audit_log.entries.last\nengine.blackboard.transaction { engine.add_fact(:order, status: \"pending\") }\n\n# Get facts by type\ntemps = engine.blackboard.get_facts_by_type(:temperature)\n</code></pre></p>"},{"location":"api/engine/#engine-lifecycle","title":"Engine Lifecycle","text":""},{"location":"api/engine/#typical-flow","title":"Typical Flow","text":"<pre><code># 1. Create engine\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# 2. Define and register rules\nkb = KBS.knowledge_base do\n  rule \"high_temp_alert\", priority: 10 do\n    on :temperature, value: greater_than(80)\n    perform do |facts, bindings|\n      puts \"Alert! Temperature: #{bindings[:value?]}\"\n    end\n  end\nend\nkb.rules.each { |r| engine.add_rule(r) }\n\n# 3. Add initial facts\nengine.add_fact(:sensor, id: 1, status: \"active\")\n\n# 4. Main loop\nloop do\n  # Collect new data\n  temp = read_temperature_sensor\n  engine.add_fact(:temperature, value: temp, timestamp: Time.now)\n\n  # Execute rules\n  engine.run\n\n  # Process messages\n  while msg = engine.consume_message(\"tasks\", \"main_loop\")\n    handle_task(msg[:content])\n  end\n\n  sleep 5\nend\n</code></pre>"},{"location":"api/engine/#restart-and-recovery","title":"Restart and Recovery","text":"<pre><code># Session 1 - Add facts\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nengine.add_fact(:account, id: 1, balance: 1000)\n# Exit\n\n# Session 2 - Facts still present\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\naccounts = engine.blackboard.get_facts_by_type(:account)\nputs accounts.first[:balance]  # =&gt; 1000\n\n# BUT: Rules must be re-registered (not persisted)\nkb = load_rules\nkb.rules.each { |r| engine.add_rule(r) }\n</code></pre> <p>Important: Only facts persist. Rules, alpha memories, and RETE network must be rebuilt on restart.</p>"},{"location":"api/engine/#transaction-example","title":"Transaction Example","text":"<pre><code>engine.blackboard.transaction do\n  fact1 = engine.add_fact(:order, id: 1, status: \"pending\")\n  fact2 = engine.add_fact(:inventory, item: \"ABC\", quantity: 100)\n\n  # If error occurs here, both facts are rolled back\n  raise \"Validation failed\" if invalid_order?(fact1)\nend\n</code></pre> <p>Database Support: SQLite and PostgreSQL support ACID transactions. Redis and MongoDB require custom transaction logic.</p>"},{"location":"api/engine/#advanced-topics","title":"Advanced Topics","text":""},{"location":"api/engine/#network-sharing","title":"Network Sharing","text":"<p>Multiple rules sharing condition patterns reuse alpha memories:</p> <pre><code># Both rules share the :temperature alpha memory\nrule \"high_temp_alert\" do\n  on :temperature, value: greater_than(80)\n  perform { puts \"High temperature!\" }\nend\n\nrule \"critical_temp_alert\" do\n  on :temperature, value: greater_than(100)\n  perform { puts \"CRITICAL temperature!\" }\nend\n\n# Only 1 alpha memory created for :temperature\n# Pattern matching happens once per fact\n</code></pre>"},{"location":"api/engine/#inspecting-the-rete-network","title":"Inspecting the RETE Network","text":"<pre><code># Dump alpha memories\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern: #{pattern.inspect}\"\n  puts \"  Facts in alpha memory: #{memory.facts.size}\"\n  puts \"  Successor nodes: #{memory.successors.size}\"\n  memory.successors.each do |succ|\n    puts \"    #{succ.class.name}\"\n  end\nend\n\n# Dump production nodes\nengine.production_nodes.each do |name, node|\n  puts \"Rule: #{name}\"\n  puts \"  Tokens (activations): #{node.tokens.size}\"\n  node.tokens.each do |token|\n    puts \"    Token with #{token.facts.size} facts\"\n  end\nend\n</code></pre> <p>Use Case: Debugging why a rule didn't fire</p>"},{"location":"api/engine/#custom-working-memory-observer","title":"Custom Working Memory Observer","text":"<pre><code>class MetricsCollector\n  def initialize\n    @fact_count = 0\n    @retract_count = 0\n  end\n\n  def update(action, fact)\n    case action\n    when :add\n      @fact_count += 1\n    when :remove\n      @retract_count += 1\n    end\n  end\n\n  def report\n    puts \"Facts added: #{@fact_count}\"\n    puts \"Facts retracted: #{@retract_count}\"\n  end\nend\n\nmetrics = MetricsCollector.new\nengine.working_memory.add_observer(metrics)\n\n# Run engine...\nengine.add_fact(:temperature, value: 85)\nengine.remove_fact(fact)\n\nmetrics.report\n# =&gt; Facts added: 1\n# =&gt; Facts retracted: 1\n</code></pre>"},{"location":"api/engine/#programmatic-rule-creation","title":"Programmatic Rule Creation","text":"<pre><code># Without DSL - manual Rule object\ncondition = KBS::Condition.new(:temperature, { value: -&gt; (v) { v &gt; 80 } })\naction = -&gt;(bindings) { puts \"High temperature detected\" }\nrule = KBS::Rule.new(name: \"high_temp\", priority: 10, conditions: [condition], action: action)\n\nengine.add_rule(rule)\n</code></pre> <p>When to Use: Dynamically generating rules at runtime based on configuration.</p>"},{"location":"api/engine/#engine-composition","title":"Engine Composition","text":"<pre><code># Multiple engines with different rule sets\nclass MonitoringSystem\n  def initialize\n    @temperature_engine = KBS::Blackboard::Engine.new(db_path: 'temp.db')\n    @security_engine = KBS::Blackboard::Engine.new(db_path: 'security.db')\n\n    setup_temperature_rules(@temperature_engine)\n    setup_security_rules(@security_engine)\n  end\n\n  def process_sensor_data(data)\n    if data[:type] == :temperature\n      @temperature_engine.add_fact(:temperature, data)\n      @temperature_engine.run\n    elsif data[:type] == :motion\n      @security_engine.add_fact(:motion, data)\n      @security_engine.run\n    end\n  end\nend\n</code></pre> <p>Use Case: Separating concerns across multiple knowledge bases</p>"},{"location":"api/engine/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/engine/#rule-ordering","title":"Rule Ordering","text":"<p>Rules are added to <code>@rules</code> array in registration order, but execution order depends on when tokens reach production nodes.</p> <pre><code># Both rules activated by same fact\nengine.add_rule(rule_a)  # Registered first\nengine.add_rule(rule_b)  # Registered second\n\nengine.add_fact(:temperature, value: 85)\nengine.run\n# Both fire, but order is unpredictable in KBS::Engine\n# Use KBS::Blackboard::Engine with priority for deterministic order\n</code></pre>"},{"location":"api/engine/#fact-batching","title":"Fact Batching","text":"<pre><code># Efficient - batch facts then run once\nfacts_to_add.each do |data|\n  engine.add_fact(:sensor_reading, data)\nend\nengine.run  # All rules see complete dataset\n\n# Inefficient - run after each fact\nfacts_to_add.each do |data|\n  engine.add_fact(:sensor_reading, data)\n  engine.run  # May fire rules prematurely\nend\n</code></pre>"},{"location":"api/engine/#memory-growth","title":"Memory Growth","text":"<pre><code># Clean up old facts to prevent memory growth\ncutoff_time = Time.now - 3600  # 1 hour ago\nold_facts = engine.working_memory.facts.select do |fact|\n  fact[:timestamp] &amp;&amp; fact[:timestamp] &lt; cutoff_time\nend\n\nold_facts.each { |f| engine.remove_fact(f) }\n</code></pre> <p>Production Pattern: Implement fact expiration in a cleanup rule:</p> <pre><code>rule \"expire_old_facts\", priority: 0 do\n  on :temperature, timestamp: -&gt;(ts) { Time.now - ts &gt; 3600 }\n  perform do |facts, bindings|\n    fact = bindings[:matched_fact?]\n    engine.remove_fact(fact)\n  end\nend\n</code></pre>"},{"location":"api/engine/#error-handling","title":"Error Handling","text":""},{"location":"api/engine/#rule-action-errors","title":"Rule Action Errors","text":"<pre><code>rule \"risky_operation\" do\n  on :task, status: \"pending\"\n  perform do |facts, bindings|\n    begin\n      perform_risky_operation(bindings[:task_id?])\n    rescue =&gt; e\n      # Log error\n      puts \"Error in rule: #{e.message}\"\n\n      # Add error fact for other rules to handle\n      engine.add_fact(:error, rule: \"risky_operation\", message: e.message)\n    end\n  end\nend\n</code></pre>"},{"location":"api/engine/#store-connection-errors","title":"Store Connection Errors","text":"<pre><code>begin\n  engine = KBS::Blackboard::Engine.new(db_path: '/invalid/path/kb.db')\nrescue Errno::EACCES =&gt; e\n  puts \"Cannot access database: #{e.message}\"\n  # Fallback to in-memory\n  engine = KBS::Blackboard::Engine.new\nend\n</code></pre>"},{"location":"api/engine/#thread-safety","title":"Thread Safety","text":"<p>KBS::Engine and KBS::Blackboard::Engine are NOT thread-safe.</p> <p>For multi-threaded access:</p> <pre><code>require 'thread'\n\nclass ThreadSafeEngine\n  def initialize(*args)\n    @engine = KBS::Blackboard::Engine.new(*args)\n    @mutex = Mutex.new\n  end\n\n  def add_fact(*args)\n    @mutex.synchronize { @engine.add_fact(*args) }\n  end\n\n  def run\n    @mutex.synchronize { @engine.run }\n  end\nend\n</code></pre> <p>Better Approach: Use one engine per thread or message passing between threads.</p>"},{"location":"api/engine/#see-also","title":"See Also","text":"<ul> <li>Facts API - Working with fact objects</li> <li>Rules API - Rule and Condition objects</li> <li>Blackboard API - Memory, MessageQueue, AuditLog</li> <li>DSL Guide - Rule definition syntax</li> <li>Performance Guide - Optimization strategies</li> </ul>"},{"location":"api/facts/","title":"Facts API Reference","text":"<p>Complete API reference for fact and condition classes in KBS.</p>"},{"location":"api/facts/#table-of-contents","title":"Table of Contents","text":"<ul> <li>KBS::Fact - Transient in-memory fact</li> <li>KBS::Blackboard::Fact - Persistent fact with UUID</li> <li>KBS::Condition - Pattern matching condition</li> <li>Fact Patterns</li> <li>Pattern Matching Semantics</li> </ul>"},{"location":"api/facts/#kbsfact","title":"KBS::Fact","text":"<p>Transient in-memory fact used by the core RETE engine.</p>"},{"location":"api/facts/#constructor","title":"Constructor","text":""},{"location":"api/facts/#initializetype-attributes","title":"<code>initialize(type, attributes = {})</code>","text":"<p>Creates a new transient fact.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type (e.g., <code>:temperature</code>, <code>:order</code>) - <code>attributes</code> (Hash, optional) - Fact attributes (default: <code>{}</code>)</p> <p>Returns: <code>KBS::Fact</code> instance</p> <p>Example: <pre><code># Fact with attributes\nfact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n# Fact without attributes (marker/flag)\nflag = KBS::Fact.new(:system_ready)\n</code></pre></p> <p>Internal Behavior: - <code>@id</code> is set to <code>object_id</code> (unique Ruby object identifier) - <code>@type</code> stores the fact type - <code>@attributes</code> stores the attribute hash</p>"},{"location":"api/facts/#public-attributes","title":"Public Attributes","text":""},{"location":"api/facts/#id","title":"<code>id</code>","text":"<p>Type: <code>Integer</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Unique identifier (Ruby object ID)</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\nputs fact.id  # =&gt; 70123456789012 (varies)\n</code></pre></p> <p>Note: Not stable across Ruby processes. For persistent IDs, use <code>KBS::Blackboard::Fact</code> with UUIDs.</p>"},{"location":"api/facts/#type","title":"<code>type</code>","text":"<p>Type: <code>Symbol</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact type</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\nputs fact.type  # =&gt; :temperature\n</code></pre></p>"},{"location":"api/facts/#attributes","title":"<code>attributes</code>","text":"<p>Type: <code>Hash</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact's attribute hash</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nputs fact.attributes  # =&gt; {:location=&gt;\"server_room\", :value=&gt;85}\n</code></pre></p> <p>Important: Direct modification bypasses change tracking: <pre><code># Don't do this (changes not tracked)\nfact.attributes[:value] = 90\n\n# Instead use []= accessor\nfact[:value] = 90\n</code></pre></p>"},{"location":"api/facts/#public-methods","title":"Public Methods","text":""},{"location":"api/facts/#key","title":"<code>[](key)</code>","text":"<p>Retrieves an attribute value.</p> <p>Parameters: - <code>key</code> (Symbol) - Attribute key</p> <p>Returns: Attribute value or <code>nil</code> if not present</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nputs fact[:location]  # =&gt; \"server_room\"\nputs fact[:value]     # =&gt; 85\nputs fact[:missing]   # =&gt; nil\n</code></pre></p>"},{"location":"api/facts/#key-value","title":"<code>[]=(key, value)</code>","text":"<p>Sets an attribute value.</p> <p>Parameters: - <code>key</code> (Symbol) - Attribute key - <code>value</code> - Attribute value</p> <p>Returns: The value</p> <p>Side Effects: Modifies the fact's attributes hash</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\nfact[:value] = 90\nfact[:timestamp] = Time.now\n\nputs fact.attributes  # =&gt; {:value=&gt;90, :timestamp=&gt;2025-01-15 10:30:00}\n</code></pre></p> <p>Important for KBS::Fact: Changes are NOT persisted and do NOT trigger re-evaluation. For tracked updates, use <code>KBS::Blackboard::Fact</code>.</p>"},{"location":"api/facts/#matchespattern","title":"<code>matches?(pattern)</code>","text":"<p>Checks if this fact matches a pattern.</p> <p>Parameters: - <code>pattern</code> (Hash) - Pattern hash with <code>:type</code> and attribute constraints</p> <p>Returns: <code>true</code> if matches, <code>false</code> otherwise</p> <p>Pattern Types: 1. Type constraint: <code>pattern[:type]</code> must equal fact type 2. Literal values: Attribute must equal specified value 3. Predicate lambdas: <code>value.is_a?(Proc)</code> - attribute passed to lambda, must return truthy 4. Variable bindings: <code>value.is_a?(Symbol) &amp;&amp; value.to_s.start_with?('?')</code> - always matches (variable captures value)</p> <p>Example - Literal Matching: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n# Type only\nfact.matches?(type: :temperature)  # =&gt; true\nfact.matches?(type: :pressure)     # =&gt; false\n\n# Type + literal attribute\nfact.matches?(type: :temperature, location: \"server_room\")  # =&gt; true\nfact.matches?(type: :temperature, location: \"lobby\")        # =&gt; false\n\n# Multiple literals\nfact.matches?(type: :temperature, location: \"server_room\", value: 85)  # =&gt; true\nfact.matches?(type: :temperature, location: \"server_room\", value: 90)  # =&gt; false\n</code></pre></p> <p>Example - Predicate Matching: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\n\n# Lambda predicate\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 80 })   # =&gt; true\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 100 })  # =&gt; false\n\n# Complex predicate\nfact.matches?(\n  type: :temperature,\n  value: -&gt;(v) { v &gt;= 70 &amp;&amp; v &lt;= 90 }\n)  # =&gt; true\n</code></pre></p> <p>Example - Variable Binding: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n# Variables always match (they capture the value)\nfact.matches?(type: :temperature, location: :loc?)  # =&gt; true\nfact.matches?(type: :temperature, value: :temp?)    # =&gt; true\n\n# Variables with other constraints\nfact.matches?(\n  type: :temperature,\n  location: \"server_room\",  # Literal constraint\n  value: :temp?             # Variable binding\n)  # =&gt; true\n</code></pre></p> <p>Example - Missing Attributes: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)  # No :location attribute\n\n# Missing attributes fail predicate/literal checks\nfact.matches?(type: :temperature, location: \"server_room\")  # =&gt; false\nfact.matches?(type: :temperature, location: -&gt;(l) { l.length &gt; 5 })  # =&gt; false (no :location)\n\n# Missing attributes match variables\nfact.matches?(type: :temperature, location: :loc?)  # =&gt; true (variable matches nil)\n</code></pre></p> <p>Algorithm: 1. If <code>pattern[:type]</code> present and doesn't match fact type \u2192 return <code>false</code> 2. For each key in pattern (except <code>:type</code>):    - If value is Proc: call with fact attribute value, return <code>false</code> if falsy or attribute missing    - If value is variable (symbol starting with <code>?</code>): skip (always matches)    - Otherwise: return <code>false</code> if fact attribute \u2260 pattern value 3. Return <code>true</code> if all checks passed</p>"},{"location":"api/facts/#to_s","title":"<code>to_s</code>","text":"<p>Returns string representation of fact.</p> <p>Parameters: None</p> <p>Returns: <code>String</code> in format <code>\"type(attr1: val1, attr2: val2)\"</code></p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nputs fact.to_s  # =&gt; \"temperature(location: server_room, value: 85)\"\n\nflag = KBS::Fact.new(:system_ready)\nputs flag.to_s  # =&gt; \"system_ready()\"\n</code></pre></p>"},{"location":"api/facts/#kbsblackboardfact","title":"KBS::Blackboard::Fact","text":"<p>Persistent fact with UUID, used by blackboard memory.</p> <p>Inherits: None (separate implementation from <code>KBS::Fact</code>)</p> <p>Key Differences from KBS::Fact: - Has UUID instead of object ID - <code>[]=</code> and <code>update()</code> trigger persistence and audit logging - <code>retract()</code> method to remove from blackboard - Reference to blackboard memory for update tracking</p>"},{"location":"api/facts/#constructor_1","title":"Constructor","text":""},{"location":"api/facts/#initializeuuid-type-attributes-blackboard-nil","title":"<code>initialize(uuid, type, attributes, blackboard = nil)</code>","text":"<p>Creates a persistent fact. Usually created via <code>engine.add_fact()</code>, not directly.</p> <p>Parameters: - <code>uuid</code> (String) - Unique identifier (UUID format) - <code>type</code> (Symbol) - Fact type - <code>attributes</code> (Hash) - Fact attributes - <code>blackboard</code> (KBS::Blackboard::Memory, optional) - Reference to blackboard (default: <code>nil</code>)</p> <p>Returns: <code>KBS::Blackboard::Fact</code> instance</p> <p>Example - Direct Construction (rare): <pre><code>require 'securerandom'\n\nfact = KBS::Blackboard::Fact.new(\n  SecureRandom.uuid,\n  :temperature,\n  { location: \"server_room\", value: 85 }\n)\nputs fact.uuid  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre></p> <p>Example - Typical Usage: <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nfact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\n# Returns KBS::Blackboard::Fact with UUID and blackboard reference\n</code></pre></p>"},{"location":"api/facts/#public-attributes_1","title":"Public Attributes","text":""},{"location":"api/facts/#uuid","title":"<code>uuid</code>","text":"<p>Type: <code>String</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Globally unique identifier (UUID format)</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nputs fact.uuid  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre></p> <p>Use Cases: - Stable ID across restarts - Foreign keys in external systems - Audit trail references</p>"},{"location":"api/facts/#type_1","title":"<code>type</code>","text":"<p>Type: <code>Symbol</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact type</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nputs fact.type  # =&gt; :temperature\n</code></pre></p>"},{"location":"api/facts/#attributes_1","title":"<code>attributes</code>","text":"<p>Type: <code>Hash</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact's attribute hash</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact.attributes  # =&gt; {:location=&gt;\"server_room\", :value=&gt;85}\n</code></pre></p> <p>Important: Direct modification bypasses persistence: <pre><code># Don't do this (not persisted)\nfact.attributes[:value] = 90\n\n# Instead use []= or update()\nfact[:value] = 90\n# or\nfact.update(value: 90)\n</code></pre></p>"},{"location":"api/facts/#public-methods_1","title":"Public Methods","text":""},{"location":"api/facts/#key_1","title":"<code>[](key)</code>","text":"<p>Retrieves an attribute value.</p> <p>Parameters: - <code>key</code> (Symbol) - Attribute key</p> <p>Returns: Attribute value or <code>nil</code> if not present</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact[:location]  # =&gt; \"server_room\"\nputs fact[:value]     # =&gt; 85\nputs fact[:missing]   # =&gt; nil\n</code></pre></p>"},{"location":"api/facts/#key-value_1","title":"<code>[]=(key, value)</code>","text":"<p>Sets an attribute value with persistence.</p> <p>Parameters: - <code>key</code> (Symbol) - Attribute key - <code>value</code> - Attribute value (must be JSON-serializable for most stores)</p> <p>Returns: The value</p> <p>Side Effects: - Updates fact's attributes hash - Calls <code>blackboard.update_fact(self, @attributes)</code> if blackboard present - Persists change to store - Logs to audit trail - Notifies observers</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nfact[:value] = 90  # Immediately persisted\n\n# After restart\nengine2 = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nreloaded = engine2.blackboard.get_facts_by_type(:temperature).first\nputs reloaded[:value]  # =&gt; 90\n</code></pre></p> <p>Important: Updates do NOT trigger rule re-evaluation. To trigger rules, retract and re-add: <pre><code>old_fact = fact\nfact.retract\nnew_fact = engine.add_fact(:temperature, value: 90)\nengine.run\n</code></pre></p>"},{"location":"api/facts/#updatenew_attributes","title":"<code>update(new_attributes)</code>","text":"<p>Bulk update multiple attributes with persistence.</p> <p>Parameters: - <code>new_attributes</code> (Hash) - Hash of attributes to merge</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Merges <code>new_attributes</code> into <code>@attributes</code> - Persists changes - Logs to audit trail - Notifies observers</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\n\nfact.update(value: 90, timestamp: Time.now)\n\nputs fact.attributes\n# =&gt; {:location=&gt;\"server_room\", :value=&gt;90, :timestamp=&gt;2025-01-15 10:30:00}\n</code></pre></p> <p>Difference from <code>[]=</code>: Updates multiple attributes in single persistence operation (more efficient).</p>"},{"location":"api/facts/#retract","title":"<code>retract()</code>","text":"<p>Removes this fact from the blackboard.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Calls <code>blackboard.remove_fact(self)</code> if blackboard present - Marks fact as inactive in store - Logs retraction to audit trail - Deactivates in alpha memories - Notifies observers</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nfact.retract  # Fact removed\n\n# Equivalent to:\nengine.remove_fact(fact)\n</code></pre></p> <p>Use Case: Fact self-destruction in rule actions: <pre><code>rule \"auto_expire_old_alerts\" do\n  on :alert, timestamp: -&gt;(ts) { Time.now - ts &gt; 3600 }\n  perform do |facts, bindings|\n    # Fact can remove itself\n    alert_fact = bindings[:matched_fact?]\n    alert_fact.retract\n  end\nend\n</code></pre></p>"},{"location":"api/facts/#matchespattern_1","title":"<code>matches?(pattern)</code>","text":"<p>Checks if this fact matches a pattern. Same semantics as <code>KBS::Fact#matches?</code>.</p> <p>Parameters: - <code>pattern</code> (Hash) - Pattern hash with <code>:type</code> and attribute constraints</p> <p>Returns: <code>true</code> if matches, <code>false</code> otherwise</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\n\nfact.matches?(type: :temperature)  # =&gt; true\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 80 })  # =&gt; true\nfact.matches?(type: :pressure)  # =&gt; false\n</code></pre></p> <p>See <code>KBS::Fact#matches?</code> for detailed semantics.</p>"},{"location":"api/facts/#to_s_1","title":"<code>to_s</code>","text":"<p>Returns string representation with UUID prefix.</p> <p>Parameters: None</p> <p>Returns: <code>String</code> in format <code>\"type(uuid_prefix...: attr1=val1, attr2=val2)\"</code></p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact.to_s\n# =&gt; \"temperature(550e8400...: location=server_room, value=85)\"\n</code></pre></p> <p>Note: Only first 8 characters of UUID shown for brevity.</p>"},{"location":"api/facts/#to_h","title":"<code>to_h</code>","text":"<p>Returns hash representation of fact.</p> <p>Parameters: None</p> <p>Returns: <code>Hash</code> with keys <code>:uuid</code>, <code>:type</code>, <code>:attributes</code></p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nhash = fact.to_h\n\nputs hash\n# =&gt; {\n#   :uuid =&gt; \"550e8400-e29b-41d4-a716-446655440000\",\n#   :type =&gt; :temperature,\n#   :attributes =&gt; {:location=&gt;\"server_room\", :value=&gt;85}\n# }\n</code></pre></p> <p>Use Cases: - Serialization for APIs - Logging - Testing assertions</p>"},{"location":"api/facts/#kbscondition","title":"KBS::Condition","text":"<p>Pattern matching condition used in rule definitions.</p>"},{"location":"api/facts/#constructor_2","title":"Constructor","text":""},{"location":"api/facts/#initializetype-pattern-negated-false","title":"<code>initialize(type, pattern = {}, negated: false)</code>","text":"<p>Creates a condition that matches facts.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type to match - <code>pattern</code> (Hash, optional) - Attribute constraints (default: <code>{}</code>) - <code>negated</code> (Boolean, optional) - If <code>true</code>, condition matches when pattern is absent (default: <code>false</code>)</p> <p>Returns: <code>KBS::Condition</code> instance</p> <p>Example - Positive Condition: <pre><code># Match any temperature fact\ncondition = KBS::Condition.new(:temperature)\n\n# Match temperature facts with location=\"server_room\"\ncondition = KBS::Condition.new(:temperature, location: \"server_room\")\n\n# Match temperature facts with value &gt; 80\ncondition = KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n</code></pre></p> <p>Example - Negated Condition: <pre><code># Match when there is NO alert fact\ncondition = KBS::Condition.new(:alert, {}, negated: true)\n\n# Match when there is NO critical alert\ncondition = KBS::Condition.new(:alert, { level: \"critical\" }, negated: true)\n</code></pre></p> <p>Example - Variable Binding: <pre><code># Capture temperature value in :temp? variable\ncondition = KBS::Condition.new(:temperature, value: :temp?)\n\n# Capture location and value\ncondition = KBS::Condition.new(\n  :temperature,\n  location: :loc?,\n  value: :temp?\n)\n</code></pre></p>"},{"location":"api/facts/#public-attributes_2","title":"Public Attributes","text":""},{"location":"api/facts/#type_2","title":"<code>type</code>","text":"<p>Type: <code>Symbol</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact type this condition matches</p> <p>Example: <pre><code>condition = KBS::Condition.new(:temperature, value: :temp?)\nputs condition.type  # =&gt; :temperature\n</code></pre></p>"},{"location":"api/facts/#pattern","title":"<code>pattern</code>","text":"<p>Type: <code>Hash</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The attribute pattern to match</p> <p>Example: <pre><code>condition = KBS::Condition.new(:temperature, location: \"server_room\", value: :temp?)\nputs condition.pattern  # =&gt; {:location=&gt;\"server_room\", :value=&gt;:temp?}\n</code></pre></p>"},{"location":"api/facts/#negated","title":"<code>negated</code>","text":"<p>Type: <code>Boolean</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Whether this is a negation condition</p> <p>Example: <pre><code>pos_condition = KBS::Condition.new(:temperature, value: :temp?)\nputs pos_condition.negated  # =&gt; false\n\nneg_condition = KBS::Condition.new(:alert, {}, negated: true)\nputs neg_condition.negated  # =&gt; true\n</code></pre></p>"},{"location":"api/facts/#variable_bindings","title":"<code>variable_bindings</code>","text":"<p>Type: <code>Hash&lt;Symbol, Symbol&gt;</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Map of variable names to attribute keys (e.g., <code>{:temp? =&gt; :value}</code>)</p> <p>Example: <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  location: :loc?,\n  value: :temp?\n)\n\nputs condition.variable_bindings\n# =&gt; {:loc?=&gt;:location, :temp?=&gt;:value}\n</code></pre></p> <p>Use Case: RETE engine uses this to extract bindings when condition matches: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nbindings = {}\n\ncondition.variable_bindings.each do |var, attr|\n  bindings[var] = fact[attr]\nend\n\nputs bindings  # =&gt; {:loc?=&gt;\"server_room\", :temp?=&gt;85}\n</code></pre></p>"},{"location":"api/facts/#fact-patterns","title":"Fact Patterns","text":"<p>Patterns are hashes used to match facts. They appear in: - <code>Condition.new(type, pattern)</code> - <code>Fact#matches?(pattern)</code> - Alpha memory keys</p>"},{"location":"api/facts/#pattern-structure","title":"Pattern Structure","text":"<pre><code>{\n  type: :fact_type,           # Optional: fact type constraint\n  attribute1: literal_value,   # Literal constraint\n  attribute2: :variable?,      # Variable binding\n  attribute3: -&gt;(v) { ... }    # Predicate lambda\n}\n</code></pre>"},{"location":"api/facts/#pattern-types","title":"Pattern Types","text":""},{"location":"api/facts/#1-empty-pattern","title":"1. Empty Pattern","text":"<p>Matches all facts of a type.</p> <pre><code>condition = KBS::Condition.new(:temperature)\n# Matches ANY temperature fact\n</code></pre>"},{"location":"api/facts/#2-literal-pattern","title":"2. Literal Pattern","text":"<p>Matches facts with exact attribute values.</p> <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  location: \"server_room\",\n  sensor_id: 42\n)\n\n# Matches:\nKBS::Fact.new(:temperature, location: \"server_room\", sensor_id: 42, value: 85)\n\n# Doesn't match:\nKBS::Fact.new(:temperature, location: \"lobby\", sensor_id: 42)\nKBS::Fact.new(:temperature, location: \"server_room\", sensor_id: 99)\n</code></pre>"},{"location":"api/facts/#3-predicate-pattern","title":"3. Predicate Pattern","text":"<p>Matches facts where attribute satisfies lambda.</p> <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &gt; 80 &amp;&amp; v &lt; 100 },\n  location: -&gt;(l) { l.start_with?(\"server\") }\n)\n\n# Matches:\nKBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nKBS::Fact.new(:temperature, location: \"server_1\", value: 90)\n\n# Doesn't match:\nKBS::Fact.new(:temperature, location: \"server_room\", value: 110)  # value &gt; 100\nKBS::Fact.new(:temperature, location: \"lobby\", value: 85)  # location doesn't start with \"server\"\n</code></pre> <p>Important: Predicate fails if attribute is missing: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\")  # No :value\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 0 })  # =&gt; false (no :value attribute)\n</code></pre></p>"},{"location":"api/facts/#4-variable-binding-pattern","title":"4. Variable Binding Pattern","text":"<p>Variables (symbols starting with <code>?</code>) capture attribute values for use in join tests and action blocks.</p> <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  location: :loc?,\n  value: :temp?\n)\n\n# Matches ANY temperature fact, binding :loc? and :temp?\nfact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n# Bindings: {:loc? =&gt; \"server_room\", :temp? =&gt; 85}\n</code></pre>"},{"location":"api/facts/#5-mixed-pattern","title":"5. Mixed Pattern","text":"<p>Combine literals, predicates, and variables.</p> <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  location: \"server_room\",      # Literal\n  value: :temp?,                # Variable\n  timestamp: -&gt;(ts) { ts &gt; cutoff_time }  # Predicate\n)\n\n# Only matches temperature facts from server_room with recent timestamp\n# Captures value in :temp? variable\n</code></pre>"},{"location":"api/facts/#pattern-matching-semantics","title":"Pattern Matching Semantics","text":""},{"location":"api/facts/#matching-algorithm","title":"Matching Algorithm","text":"<p>For <code>fact.matches?(pattern)</code>:</p> <ol> <li>Type Check: If <code>pattern[:type]</code> present, must equal <code>fact.type</code></li> <li>Attribute Checks: For each <code>key, value</code> in pattern (except <code>:type</code>):</li> <li>Variable (<code>value.is_a?(Symbol) &amp;&amp; value.to_s.start_with?('?')</code>): Always matches (captures <code>fact[key]</code>)</li> <li>Predicate (<code>value.is_a?(Proc)</code>): Must satisfy <code>value.call(fact[key])</code>. Fails if <code>fact[key]</code> is nil.</li> <li>Literal: Must equal <code>fact[key]</code></li> <li>Result: <code>true</code> if all checks pass, <code>false</code> otherwise</li> </ol>"},{"location":"api/facts/#open-world-assumption","title":"Open World Assumption","text":"<p>Facts are not required to have all attributes in the pattern. Patterns only constrain attributes they specify.</p> <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85, timestamp: Time.now)\n\n# Matches - pattern doesn't mention :timestamp\nfact.matches?(type: :temperature, location: \"server_room\")  # =&gt; true\n\n# Matches - pattern only constrains :value\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 80 })  # =&gt; true\n</code></pre> <p>But: If pattern specifies an attribute the fact lacks, match fails:</p> <pre><code>fact = KBS::Fact.new(:temperature, value: 85)  # No :location\n\n# Fails - fact missing :location attribute\nfact.matches?(type: :temperature, location: \"server_room\")  # =&gt; false\n\n# Fails - predicate can't evaluate nil\nfact.matches?(type: :temperature, location: -&gt;(l) { l.length &gt; 5 })  # =&gt; false\n\n# Succeeds - variable matches nil\nfact.matches?(type: :temperature, location: :loc?)  # =&gt; true (binds :loc? =&gt; nil)\n</code></pre>"},{"location":"api/facts/#variable-binding-extraction","title":"Variable Binding Extraction","text":"<p>Variables are extracted during condition construction:</p> <pre><code>condition = KBS::Condition.new(\n  :order,\n  symbol: :sym?,\n  quantity: :qty?,\n  price: :price?\n)\n\nputs condition.variable_bindings\n# =&gt; {:sym?=&gt;:symbol, :qty?=&gt;:quantity, :price?=&gt;:price}\n</code></pre> <p>When a fact matches, bindings are populated:</p> <pre><code>fact = KBS::Fact.new(:order, symbol: \"AAPL\", quantity: 100, price: 150.25)\n\nbindings = {}\ncondition.variable_bindings.each do |var, attr|\n  bindings[var] = fact[attr]\nend\n\nputs bindings\n# =&gt; {:sym?=&gt;\"AAPL\", :qty?=&gt;100, :price?=&gt;150.25}\n</code></pre>"},{"location":"api/facts/#predicate-constraints","title":"Predicate Constraints","text":"<p>Predicates are powerful but have caveats:</p> <p>1. Nil Attributes Fail: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\")  # No :value\n\n# Predicate fails - can't call lambda on nil\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 0 })  # =&gt; false\n</code></pre></p> <p>2. Predicates Run on Every Match Attempt: <pre><code># This predicate runs every time a fact is checked\nexpensive_check = -&gt;(v) { complex_calculation(v) }\ncondition = KBS::Condition.new(:temperature, value: expensive_check)\n\n# For 1000 temperature facts, expensive_check runs 1000 times\n</code></pre></p> <p>3. Predicates Should Be Pure Functions: <pre><code># Bad - side effects\ncounter = 0\ncondition = KBS::Condition.new(:temperature, value: -&gt;(v) { counter += 1; v &gt; 80 })\n\n# Good - pure predicate\ncondition = KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n</code></pre></p> <p>4. Predicates Can't Access Other Attributes: <pre><code># This doesn't work - predicate only receives attribute value\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &gt; @threshold }  # @threshold from where?\n)\n\n# Use closures to capture context\nthreshold = 80\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &gt; threshold }  # Closure captures threshold\n)\n</code></pre></p>"},{"location":"api/facts/#negation-semantics","title":"Negation Semantics","text":"<p>Negated conditions match when NO fact satisfies the pattern:</p> <pre><code># Rule fires when there's NO critical alert\nrule \"all_clear\" do\n  negated :alert, level: \"critical\"  # negated: true\n  perform { puts \"All systems normal\" }\nend\n</code></pre> <p>Important: Negation matches absence, not presence of opposite:</p> <pre><code># Matches when NO alert with level=\"critical\" exists\nnegated :alert, level: \"critical\"\n\n# NOT equivalent to: Match when alert with level != \"critical\" exists\n# To match non-critical alerts, use predicate:\non :alert, level: -&gt;(l) { l != \"critical\" }\n</code></pre> <p>See Negation Guide for detailed semantics.</p>"},{"location":"api/facts/#common-patterns","title":"Common Patterns","text":""},{"location":"api/facts/#1-range-checks","title":"1. Range Checks","text":"<pre><code># Between 70 and 90\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &gt;= 70 &amp;&amp; v &lt;= 90 }\n)\n\n# Outside range\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &lt; 70 || v &gt; 90 }\n)\n</code></pre>"},{"location":"api/facts/#2-string-matching","title":"2. String Matching","text":"<pre><code># Starts with\ncondition = KBS::Condition.new(\n  :sensor,\n  name: -&gt;(n) { n.start_with?(\"temp_\") }\n)\n\n# Regex match\ncondition = KBS::Condition.new(\n  :sensor,\n  name: -&gt;(n) { n =~ /^sensor_\\d+$/ }\n)\n\n# Contains substring\ncondition = KBS::Condition.new(\n  :log_entry,\n  message: -&gt;(m) { m.include?(\"ERROR\") }\n)\n</code></pre>"},{"location":"api/facts/#3-collection-membership","title":"3. Collection Membership","text":"<pre><code># One of several values\nvalid_statuses = [\"pending\", \"processing\", \"completed\"]\ncondition = KBS::Condition.new(\n  :order,\n  status: -&gt;(s) { valid_statuses.include?(s) }\n)\n\n# Not in collection\ninvalid_statuses = [\"cancelled\", \"failed\"]\ncondition = KBS::Condition.new(\n  :order,\n  status: -&gt;(s) { !invalid_statuses.include?(s) }\n)\n</code></pre>"},{"location":"api/facts/#4-timestamp-checks","title":"4. Timestamp Checks","text":"<pre><code># Recent facts (last hour)\ncutoff = Time.now - 3600\ncondition = KBS::Condition.new(\n  :temperature,\n  timestamp: -&gt;(ts) { ts &gt; cutoff }\n)\n\n# Old facts (older than 1 day)\ncutoff = Time.now - 86400\ncondition = KBS::Condition.new(\n  :temperature,\n  timestamp: -&gt;(ts) { ts &lt; cutoff }\n)\n</code></pre>"},{"location":"api/facts/#5-cross-attribute-constraints-using-multiple-conditions","title":"5. Cross-Attribute Constraints (Using Multiple Conditions)","text":"<p>You can't directly compare two attributes of the same fact in one condition. Use multiple conditions:</p> <pre><code># Want: Match orders where quantity * price &gt; 10000\n# Can't do this in one condition:\n# condition = KBS::Condition.new(:order, ...)  # No way to access both :quantity and :price\n\n# Instead: Capture variables and check in action or use join test\nrule \"large_order\" do\n  on :order, quantity: :qty?, price: :price?\n  perform do |facts, bindings|\n    total = bindings[:qty?] * bindings[:price?]\n    if total &gt; 10000\n      puts \"Large order: $#{total}\"\n    end\n  end\nend\n</code></pre>"},{"location":"api/facts/#6-nullnil-checks","title":"6. Null/Nil Checks","text":"<p>Variables capture <code>nil</code>, predicates fail on <code>nil</code>:</p> <pre><code># Match facts with ANY value for :location (including nil)\ncondition = KBS::Condition.new(:temperature, location: :loc?)\n# Matches fact.new(:temperature, location: nil)  \u2192 binds :loc? =&gt; nil\n# Matches fact.new(:temperature)  \u2192 binds :loc? =&gt; nil\n\n# Match facts with NON-NIL :location\ncondition = KBS::Condition.new(\n  :temperature,\n  location: -&gt;(l) { !l.nil? }\n)\n# Fails fact.new(:temperature, location: nil)\n# Fails fact.new(:temperature)  (no :location attribute)\n</code></pre>"},{"location":"api/facts/#performance-tips","title":"Performance Tips","text":""},{"location":"api/facts/#1-order-predicates-by-selectivity","title":"1. Order Predicates by Selectivity","text":"<pre><code># Good - Most selective predicate first\ncondition = KBS::Condition.new(\n  :temperature,\n  sensor_id: 42,              # Likely filters to 1 fact\n  value: -&gt;(v) { v &gt; 80 }     # Then check value\n)\n\n# Less optimal - Expensive check first\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { expensive_calculation(v) },  # Runs on many facts\n  sensor_id: 42               # Could have filtered first\n)\n</code></pre> <p>Note: Within a single condition, Ruby evaluates hash in insertion order (Ruby 1.9+), but RETE evaluates all constraints anyway. The real optimization is condition ordering in rules.</p>"},{"location":"api/facts/#2-avoid-expensive-predicates","title":"2. Avoid Expensive Predicates","text":"<pre><code># Bad - Complex regex on every fact\ncondition = KBS::Condition.new(\n  :log_entry,\n  message: -&gt;(m) { m =~ /very.*complex.*regex.*pattern/ }\n)\n\n# Better - Simple check first, complex check in action\nrule \"complex_log_analysis\" do\n  on :log_entry, level: \"ERROR\", message: :msg?  # Simple literal filter\n  perform do |facts, bindings|\n    if bindings[:msg?] =~ /very.*complex.*regex.*pattern/\n      # Expensive check runs only on ERROR logs\n    end\n  end\nend\n</code></pre>"},{"location":"api/facts/#3-use-literals-when-possible","title":"3. Use Literals When Possible","text":"<p>Literals are fastest (hash equality check). Predicates are slower (lambda call).</p> <pre><code># Fast\ncondition = KBS::Condition.new(:temperature, location: \"server_room\")\n\n# Slower (but necessary for ranges/complex checks)\ncondition = KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n</code></pre>"},{"location":"api/facts/#testing-patterns","title":"Testing Patterns","text":""},{"location":"api/facts/#testing-fact-matching","title":"Testing Fact Matching","text":"<pre><code>require 'minitest/autorun'\n\nclass TestFactMatching &lt; Minitest::Test\n  def test_literal_match\n    fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n    assert fact.matches?(type: :temperature)\n    assert fact.matches?(type: :temperature, location: \"server_room\")\n    refute fact.matches?(type: :temperature, location: \"lobby\")\n  end\n\n  def test_predicate_match\n    fact = KBS::Fact.new(:temperature, value: 85)\n\n    assert fact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 80 })\n    refute fact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 100 })\n  end\n\n  def test_variable_binding\n    fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n    # Variables always match\n    assert fact.matches?(type: :temperature, location: :loc?, value: :temp?)\n  end\n\n  def test_missing_attribute\n    fact = KBS::Fact.new(:temperature, value: 85)  # No :location\n\n    # Literal fails on missing\n    refute fact.matches?(type: :temperature, location: \"server_room\")\n\n    # Predicate fails on missing\n    refute fact.matches?(type: :temperature, location: -&gt;(l) { l.length &gt; 0 })\n\n    # Variable succeeds on missing (binds to nil)\n    assert fact.matches?(type: :temperature, location: :loc?)\n  end\nend\n</code></pre>"},{"location":"api/facts/#testing-variable-extraction","title":"Testing Variable Extraction","text":"<pre><code>class TestVariableExtraction &lt; Minitest::Test\n  def test_variable_bindings\n    condition = KBS::Condition.new(\n      :temperature,\n      location: :loc?,\n      value: :temp?\n    )\n\n    expected = { :loc? =&gt; :location, :temp? =&gt; :value }\n    assert_equal expected, condition.variable_bindings\n  end\n\n  def test_no_variables\n    condition = KBS::Condition.new(:temperature, location: \"server_room\")\n\n    assert_empty condition.variable_bindings\n  end\nend\n</code></pre>"},{"location":"api/facts/#see-also","title":"See Also","text":"<ul> <li>Engine API - Adding facts to engines</li> <li>Rules API - Using conditions in rules</li> <li>Pattern Matching Guide - Detailed pattern semantics</li> <li>Variable Binding Guide - Join tests and bindings</li> <li>DSL Guide - Declarative condition syntax</li> </ul>"},{"location":"api/rules/","title":"Rules API Reference","text":"<p>Complete API reference for rule classes in KBS.</p>"},{"location":"api/rules/#table-of-contents","title":"Table of Contents","text":"<ul> <li>KBS::Rule - Production rule with conditions and action</li> <li>Rule Lifecycle</li> <li>Rule Patterns</li> <li>Best Practices</li> </ul>"},{"location":"api/rules/#kbsrule","title":"KBS::Rule","text":"<p>A production rule that fires when all conditions match.</p> <p>Structure: A rule consists of: 1. Name - Unique identifier 2. Priority - Execution order (higher = more urgent) 3. Conditions - Array of patterns to match 4. Action - Lambda executed when all conditions match</p>"},{"location":"api/rules/#constructor","title":"Constructor","text":""},{"location":"api/rules/#initializename-conditions-action-nil-priority-0-block","title":"<code>initialize(name, conditions: [], action: nil, priority: 0, &amp;block)</code>","text":"<p>Creates a new rule.</p> <p>Parameters: - <code>name</code> (Symbol or String) - Unique rule identifier - <code>conditions</code> (Array, optional) - Conditions to match (default: <code>[]</code>) - <code>action</code> (Proc, optional) - Action lambda to execute (default: <code>nil</code>) - <code>priority</code> (Integer, optional) - Rule priority (default: <code>0</code>) - <code>&amp;block</code> (Block, optional) - Configuration block yielding self <p>Returns: <code>KBS::Rule</code> instance</p> <p>Example - Low-level API (Direct Construction): <pre><code># Minimal rule\nrule = KBS::Rule.new(:high_temperature)\n\n# Rule with all parameters\nrule = KBS::Rule.new(\n  :high_temperature,\n  conditions: [\n    KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n  ],\n  action: -&gt;(facts) { puts \"High temperature detected!\" },\n  priority: 10\n)\n</code></pre></p> <p>Example - Low-level API (Block Configuration): <pre><code>rule = KBS::Rule.new(:high_temperature) do |r|\n  r.conditions &lt;&lt; KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n  r.action = -&gt;(facts) { puts \"High temperature: #{facts[0][:value]}\" }\nend\n</code></pre></p> <p>Using DSL (Recommended): <pre><code>kb = KBS.knowledge_base do\n  rule \"high_temperature\", priority: 10 do\n    on :temperature, value: greater_than(80)\n    perform do |facts, bindings|\n      puts \"High temperature: #{bindings[:value?]}\"\n    end\n  end\nend\n\n# Add to engine\nkb.rules.each { |r| engine.add_rule(r) }\n</code></pre></p>"},{"location":"api/rules/#public-attributes","title":"Public Attributes","text":""},{"location":"api/rules/#name","title":"<code>name</code>","text":"<p>Type: <code>Symbol</code> or <code>String</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Unique rule identifier</p> <p>Example - Low-level API: <pre><code>rule = KBS::Rule.new(:high_temperature, priority: 10)\nputs rule.name  # =&gt; :high_temperature\n</code></pre></p> <p>Using DSL (Recommended): <pre><code>kb = KBS.knowledge_base do\n  rule \"high_temperature\", priority: 10 do\n    on :temperature, value: greater_than(80)\n    perform { puts \"Alert!\" }\n  end\nend\n\nputs kb.rules.first.name  # =&gt; \"high_temperature\"\n</code></pre></p> <p>Best Practice: Use descriptive names that indicate the rule's purpose: <pre><code># Good\n\"high_temperature_alert\"\n\"low_inventory_reorder\"\n\"fraud_detection_high_risk\"\n\n# Less clear\n\"rule1\"\n\"temp_rule\"\n\"check\"\n</code></pre></p>"},{"location":"api/rules/#priority","title":"<code>priority</code>","text":"<p>Type: <code>Integer</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Rule priority (higher = executes first in KBS::Blackboard::Engine)</p> <p>Default: <code>0</code></p> <p>Range: Any integer (commonly 0-100)</p> <p>Example - Low-level API: <pre><code>rule = KBS::Rule.new(:critical_alert, priority: 100)\nputs rule.priority  # =&gt; 100\n</code></pre></p> <p>Using DSL (Recommended): <pre><code>kb = KBS.knowledge_base do\n  rule \"critical_alert\", priority: 100 do\n    on :alert, level: \"critical\"\n    perform { puts \"CRITICAL ALERT!\" }\n  end\nend\n</code></pre></p> <p>Priority Semantics: - KBS::Engine: Priority is stored but NOT used for execution order (rules fire in arbitrary order) - KBS::Blackboard::Engine: Higher priority rules fire first within production nodes</p> <p>Common Priority Ranges: <pre><code># Critical safety rules\npriority: 100\n\n# Important business rules\npriority: 50\n\n# Standard rules\npriority: 10\n\n# Cleanup/logging rules\npriority: 0\n\n# Background tasks\npriority: -10\n</code></pre></p> <p>Example - Priority Ordering: <pre><code>kb = KBS.knowledge_base do\n  rule \"log_temperature\", priority: 0 do\n    on :temperature, value: :temp?\n    perform { |facts, b| puts \"Logged: #{b[:temp?]}\" }\n  end\n\n  rule \"critical_alert\", priority: 100 do\n    on :temperature, value: greater_than(100)\n    perform { puts \"CRITICAL TEMPERATURE!\" }\n  end\n\n  rule \"high_alert\", priority: 50 do\n    on :temperature, value: greater_than(80)\n    perform { puts \"High temperature warning\" }\n  end\nend\n\nengine = KBS::Blackboard::Engine.new\nkb.rules.each { |r| engine.add_rule(r) }\nengine.add_fact(:temperature, value: 110)\nengine.run\n\n# Output (in priority order):\n# CRITICAL TEMPERATURE!      (priority 100)\n# High temperature warning   (priority 50)\n# Logged: 110                (priority 0)\n</code></pre></p>"},{"location":"api/rules/#conditions","title":"<code>conditions</code>","text":"<p>Type: <code>Array&lt;KBS::Condition&gt;</code></p> <p>Read/Write: Yes (via <code>attr_accessor</code>)</p> <p>Description: Array of conditions that must all match for rule to fire</p> <p>Example - Low-level API: <pre><code>rule = KBS::Rule.new(:temperature_alert)\nrule.conditions &lt;&lt; KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\nrule.conditions &lt;&lt; KBS::Condition.new(:sensor, status: \"active\")\n\nputs rule.conditions.size  # =&gt; 2\n</code></pre></p> <p>Using DSL (Recommended): <pre><code>kb = KBS.knowledge_base do\n  rule \"temperature_alert\" do\n    on :temperature, value: greater_than(80)\n    on :sensor, status: \"active\"\n    perform { puts \"Alert!\" }\n  end\nend\n\nputs kb.rules.first.conditions.size  # =&gt; 2\n</code></pre></p> <p>Condition Order Matters (for performance):</p> <p>Low-level API: <pre><code># Good - Most selective condition first\nrule.conditions = [\n  KBS::Condition.new(:sensor, id: 42),             # Filters to 1 fact\n  KBS::Condition.new(:temperature, value: :temp?)  # Then match temperature\n]\n\n# Less optimal - Less selective first\nrule.conditions = [\n  KBS::Condition.new(:temperature, value: :temp?),  # Matches many facts\n  KBS::Condition.new(:sensor, id: 42)               # Could have filtered first\n]\n</code></pre></p> <p>Using DSL (Recommended): <pre><code># Good - Most selective condition first\nrule \"sensor_alert\" do\n  on :sensor, id: 42                    # Filters to 1 fact\n  on :temperature, value: :temp?        # Then match temperature\n  perform { |facts, b| puts b[:temp?] }\nend\n\n# Less optimal - Less selective first\nrule \"sensor_alert\" do\n  on :temperature, value: :temp?        # Matches many facts\n  on :sensor, id: 42                    # Could have filtered first\n  perform { |facts, b| puts b[:temp?] }\nend\n</code></pre></p> <p>See Performance Guide for condition ordering strategies.</p>"},{"location":"api/rules/#action","title":"<code>action</code>","text":"<p>Type: <code>Proc</code> (lambda or proc)</p> <p>Read/Write: Yes (via <code>attr_accessor</code>)</p> <p>Description: Lambda executed when all conditions match</p> <p>Signature: <code>action.call(facts)</code> or <code>action.call(facts, bindings)</code> (both supported)</p> <p>Parameters: - <code>facts</code> (Array) - Array of matched facts (parallel to conditions array) - <code>bindings</code> (Hash, optional) - Variable bindings extracted from facts <p>Example - Low-level API (Facts Parameter): <pre><code>rule.action = -&gt;(facts) do\n  temp_fact = facts[0]  # First condition's matched fact\n  sensor_fact = facts[1]  # Second condition's matched fact\n\n  puts \"Temperature: #{temp_fact[:value]} from sensor #{sensor_fact[:id]}\"\nend\n</code></pre></p> <p>Example - Low-level API (Bindings Parameter): <pre><code># Rule with variable bindings\nrule = KBS::Rule.new(:temperature_alert) do |r|\n  r.conditions &lt;&lt; KBS::Condition.new(:temperature, value: :temp?, location: :loc?)\n  r.action = -&gt;(facts, bindings) do\n    # bindings: {:temp? =&gt; 85, :loc? =&gt; \"server_room\"}\n    puts \"#{bindings[:loc?]}: #{bindings[:temp?]}\u00b0F\"\n  end\nend\n</code></pre></p> <p>Using DSL (Recommended): <pre><code>rule \"temperature_alert\" do\n  on :temperature, value: :temp?, location: :loc?\n  perform do |facts, bindings|\n    # Cleaner - DSL automatically provides bindings\n    puts \"#{bindings[:loc?]}: #{bindings[:temp?]}\u00b0F\"\n  end\nend\n</code></pre></p> <p>Action Requirements: - Must be a Proc (lambda or proc) - Should be idempotent if possible (safe to run multiple times) - Should not modify facts directly (use <code>engine.add_fact</code> / <code>engine.remove_fact</code> instead) - May add/remove facts (triggers new rule evaluation)</p>"},{"location":"api/rules/#public-methods","title":"Public Methods","text":""},{"location":"api/rules/#firefacts","title":"<code>fire(facts)</code>","text":"<p>Executes the rule's action with matched facts.</p> <p>Parameters: - <code>facts</code> (Array) - Matched facts (one per condition) <p>Returns: Result of action lambda, or <code>nil</code> if no action</p> <p>Side Effects: - Increments internal <code>@fired_count</code> - Executes action lambda - Action may modify external state, add/remove facts, etc.</p> <p>Example - Low-level API: <pre><code>rule = KBS::Rule.new(:log_temperature) do |r|\n  r.conditions &lt;&lt; KBS::Condition.new(:temperature, value: :temp?)\n  r.action = -&gt;(facts, bindings) do\n    puts \"Temperature: #{bindings[:temp?]}\"\n  end\nend\n\nfact = KBS::Fact.new(:temperature, value: 85)\nrule.fire([fact])\n# Output: Temperature: 85\n</code></pre></p> <p>Using DSL (Recommended): <pre><code>kb = KBS.knowledge_base do\n  rule \"log_temperature\" do\n    on :temperature, value: :temp?\n    perform do |facts, bindings|\n      puts \"Temperature: #{bindings[:temp?]}\"\n    end\n  end\n\n  fact :temperature, value: 85\n  run  # Fires the rule automatically\nend\n# Output: Temperature: 85\n</code></pre></p> <p>Note: Typically called by the RETE engine, not user code. Users call <code>engine.run</code> which fires all activated rules.</p>"},{"location":"api/rules/#rule-lifecycle","title":"Rule Lifecycle","text":""},{"location":"api/rules/#1-rule-creation","title":"1. Rule Creation","text":"<pre><code># Via DSL (recommended)\nkb = KBS.knowledge_base do\n  rule \"my_rule\", priority: 10 do\n    on :temperature, value: :temp?\n    perform { |facts, b| puts b[:temp?] }\n  end\nend\n\n# Or programmatically\nrule = KBS::Rule.new(\n  :my_rule,\n  conditions: [KBS::Condition.new(:temperature, value: :temp?)],\n  action: -&gt;(facts) { puts facts[0][:value] },\n  priority: 10\n)\n</code></pre>"},{"location":"api/rules/#2-rule-registration","title":"2. Rule Registration","text":"<pre><code>engine.add_rule(rule)\n# Internally:\n# - Adds rule to @rules array\n# - Compiles rule into RETE network\n# - Creates alpha memories for condition patterns\n# - Creates join nodes (or negation nodes)\n# - Creates production node for rule\n# - Activates existing facts through new network\n</code></pre>"},{"location":"api/rules/#3-rule-activation","title":"3. Rule Activation","text":"<pre><code>engine.add_fact(:temperature, value: 85)\n# Internally:\n# - Fact activates matching alpha memories\n# - Propagates through join nodes\n# - Creates tokens in beta memories\n# - Token reaches production node\n# - Rule is \"activated\" (ready to fire)\n</code></pre>"},{"location":"api/rules/#4-rule-firing","title":"4. Rule Firing","text":"<pre><code>engine.run\n# Internally (KBS::Engine):\n# - Iterates production nodes\n# - For each token in production node:\n#   - Calls rule.fire(token.facts)\n#   - Executes action lambda\n\n# Internally (KBS::Blackboard::Engine):\n# - Same as above, but:\n#   - Logs rule firing to audit trail\n#   - Marks token as fired (prevents duplicate firing)\n#   - Records variable bindings\n</code></pre>"},{"location":"api/rules/#5-rule-re-firing","title":"5. Rule Re-firing","text":"<p>Rules can fire multiple times:</p> <pre><code>rule \"log_temperature\" do\n  on :temperature, value: :temp?\n  perform { |facts, b| puts \"Temperature: #{b[:temp?]}\" }\nend\n\nengine.add_fact(:temperature, value: 85)\nengine.add_fact(:temperature, value: 90)\nengine.add_fact(:temperature, value: 95)\nengine.run\n\n# Output:\n# Temperature: 85\n# Temperature: 90\n# Temperature: 95\n</code></pre> <p>Each fact creates a separate activation (token) that fires independently.</p>"},{"location":"api/rules/#rule-patterns","title":"Rule Patterns","text":""},{"location":"api/rules/#1-simple-rule-one-condition","title":"1. Simple Rule (One Condition)","text":"<p>Match single fact type:</p> <pre><code>rule \"log_all_temperatures\" do\n  on :temperature, value: :temp?\n  perform do |facts, bindings|\n    puts \"Temperature: #{bindings[:temp?]}\"\n  end\nend\n</code></pre>"},{"location":"api/rules/#2-join-rule-multiple-conditions","title":"2. Join Rule (Multiple Conditions)","text":"<p>Match multiple related facts:</p> <pre><code>rule \"sensor_temperature_alert\" do\n  on :sensor, id: :sensor_id?, status: \"active\"\n  on :temperature, sensor_id: :sensor_id?, value: greater_than(80)\n  perform do |facts, bindings|\n    puts \"Sensor #{bindings[:sensor_id?]} reports high temperature\"\n  end\nend\n\n# Matches when:\n# - sensor fact with id=42, status=\"active\" exists\n# - temperature fact with sensor_id=42, value &gt; 80 exists\n</code></pre> <p>Variable Binding: <code>:sensor_id?</code> in first condition must equal <code>sensor_id</code> in second condition (join test).</p>"},{"location":"api/rules/#3-guard-rule-negation","title":"3. Guard Rule (Negation)","text":"<p>Match when fact is absent:</p> <pre><code>rule \"all_clear\" do\n  on :system, status: \"running\"\n  negated :alert, level: \"critical\"  # Fire when NO critical alerts exist\n  perform do\n    puts \"All systems normal\"\n  end\nend\n</code></pre>"},{"location":"api/rules/#4-state-machine-rule","title":"4. State Machine Rule","text":"<p>Rules can implement state transitions:</p> <pre><code>rule \"pending_to_processing\" do\n  on :order, id: :order_id?, status: \"pending\"\n  on :worker, status: \"available\", id: :worker_id?\n  perform do |facts, bindings|\n    # Transition order to processing\n    order = find_order(bindings[:order_id?])\n    order.update(status: \"processing\", worker_id: bindings[:worker_id?])\n\n    # Update worker\n    worker = find_worker(bindings[:worker_id?])\n    worker.update(status: \"busy\")\n  end\nend\n</code></pre>"},{"location":"api/rules/#5-cleanup-rule","title":"5. Cleanup Rule","text":"<p>Low-priority rules that clean up old facts:</p> <pre><code>rule \"expire_old_temperatures\", priority: 0 do\n  on :temperature, timestamp: less_than(Time.now - 3600)\n  perform do |facts, bindings|\n    fact = bindings[:matched_fact?]\n    fact.retract  # Remove old temperature reading\n  end\nend\n</code></pre>"},{"location":"api/rules/#6-aggregation-rule","title":"6. Aggregation Rule","text":"<p>Collect multiple facts and compute aggregate:</p> <pre><code>rule \"daily_temperature_summary\", priority: 5 do\n  on :trigger, event: \"end_of_day\"\n  perform do\n    temps = engine.working_memory.facts\n      .select { |f| f.type == :temperature }\n      .map { |f| f[:value] }\n\n    avg = temps.sum / temps.size.to_f\n    max = temps.max\n    min = temps.min\n\n    engine.add_fact(:daily_summary, avg: avg, max: max, min: min, date: Date.today)\n  end\nend\n</code></pre>"},{"location":"api/rules/#7-conflict-resolution-rule","title":"7. Conflict Resolution Rule","text":"<p>Higher priority rule overrides lower priority:</p> <pre><code>rule \"high_risk_order\", priority: 100 do\n  on :order, id: :order_id?, total: greater_than(10000)\n  perform do |facts, bindings|\n    puts \"HIGH RISK: Order #{bindings[:order_id?]} requires manual review\"\n    # This fires first due to priority\n  end\nend\n\nrule \"auto_approve_order\", priority: 10 do\n  on :order, id: :order_id?, status: \"pending\"\n  perform do |facts, bindings|\n    puts \"Auto-approving order #{bindings[:order_id?]}\"\n    # This fires later (if at all)\n  end\nend\n</code></pre>"},{"location":"api/rules/#8-recursive-rule","title":"8. Recursive Rule","text":"<p>Rule that adds facts triggering other rules:</p> <pre><code>rule \"calculate_fibonacci\" do\n  on :fib_request, n: :n?\n  negated :fib_result, n: :n?  # Not already calculated\n  perform do |facts, bindings|\n    n = bindings[:n?]\n\n    if n &lt;= 1\n      engine.add_fact(:fib_result, n: n, value: n)\n    else\n      # Request sub-problems\n      engine.add_fact(:fib_request, n: n - 1)\n      engine.add_fact(:fib_request, n: n - 2)\n\n      # Wait for sub-results in another rule...\n    end\n  end\nend\n\nrule \"combine_fibonacci\" do\n  on :fib_request, n: :n?\n  on :fib_result, n: :n_minus_1?, value: :val1?\n  on :fib_result, n: :n_minus_2?, value: :val2?\n  # ... (complex join test: ?n_minus_1 == ?n - 1, etc.)\n  perform do |facts, bindings|\n    result = bindings[:val1?] + bindings[:val2?]\n    engine.add_fact(:fib_result, n: bindings[:n?], value: result)\n  end\nend\n</code></pre>"},{"location":"api/rules/#best-practices","title":"Best Practices","text":""},{"location":"api/rules/#1-descriptive-rule-names","title":"1. Descriptive Rule Names","text":"<pre><code># Good\nrule \"high_temperature_alert\"\nrule \"low_inventory_reorder\"\nrule \"fraud_detection_suspicious_transaction\"\n\n# Bad\nrule \"rule1\"\nrule \"temp\"\nrule \"check\"\n</code></pre>"},{"location":"api/rules/#2-order-conditions-by-selectivity","title":"2. Order Conditions by Selectivity","text":"<p>Most selective (fewest matching facts) first:</p> <pre><code># Good - sensor_id=42 filters to ~1 fact\nrule \"sensor_alert\" do\n  on :sensor, id: 42, status: :status?              # Very selective\n  on :temperature, sensor_id: 42, value: :temp?     # Also selective\n  perform { ... }\nend\n\n# Bad - :temperature matches many facts\nrule \"sensor_alert\" do\n  on :temperature, value: :temp?                    # Matches 1000s of facts\n  on :sensor, id: 42, status: :status?              # Could have filtered first\n  perform { ... }\nend\n</code></pre> <p>Why: RETE builds network from first to last condition. Fewer intermediate tokens = faster.</p>"},{"location":"api/rules/#3-use-priority-for-critical-rules","title":"3. Use Priority for Critical Rules","text":"<pre><code>rule \"critical_shutdown\", priority: 1000 do\n  on :temperature, value: greater_than(120)\n  perform { shutdown_system! }\nend\n\nrule \"log_temperature\", priority: 0 do\n  on :temperature, value: :temp?\n  perform { |facts, b| log(b[:temp?]) }\nend\n</code></pre> <p>Critical safety rules should have high priority to fire before less important rules.</p>"},{"location":"api/rules/#4-keep-actions-idempotent","title":"4. Keep Actions Idempotent","text":"<pre><code># Good - Idempotent (safe to run multiple times)\nrule \"alert_high_temp\" do\n  on :temperature, value: greater_than(80)\n  perform do |facts, bindings|\n    # Check if alert already sent\n    unless alert_sent?(bindings[:temp?])\n      send_alert(bindings[:temp?])\n      mark_alert_sent(bindings[:temp?])\n    end\n  end\nend\n\n# Bad - Not idempotent (sends duplicate alerts)\nrule \"alert_high_temp\" do\n  on :temperature, value: greater_than(80)\n  perform do |facts, bindings|\n    send_alert(bindings[:temp?])  # Sends every time rule fires\n  end\nend\n</code></pre>"},{"location":"api/rules/#5-avoid-side-effects-in-conditions","title":"5. Avoid Side Effects in Conditions","text":"<pre><code># Bad - Side effect in condition predicate\ncounter = 0\nrule \"count_temps\" do\n  on :temperature, value: -&gt;(v) { counter += 1; v &gt; 80 }  # BAD!\n  perform { puts \"Count: #{counter}\" }\nend\n\n# Good - Side effects in action only\ncounter = 0\nrule \"count_temps\" do\n  on :temperature, value: greater_than(80)\n  perform { counter += 1; puts \"Count: #{counter}\" }\nend\n</code></pre> <p>Why: Predicates run during pattern matching (potentially multiple times). Side effects cause unpredictable behavior.</p>"},{"location":"api/rules/#6-use-variable-bindings-for-joins","title":"6. Use Variable Bindings for Joins","text":"<pre><code># Good - Variable binding creates join test\nrule \"order_inventory_check\" do\n  on :order, product_id: :pid?, quantity: :qty?\n  on :inventory, product_id: :pid?, available: :available?\n  perform do |facts, bindings|\n    if bindings[:available?] &lt; bindings[:qty?]\n      puts \"Insufficient inventory for product #{bindings[:pid?]}\"\n    end\n  end\nend\n\n# Bad - No join test (matches all combinations)\nrule \"order_inventory_check\" do\n  on :order, product_id: :pid1?, quantity: :qty?\n  on :inventory, product_id: :pid2?, available: :available?\n  perform do |facts, bindings|\n    # No guarantee pid1 == pid2!\n    if bindings[:pid1?] == bindings[:pid2?]  # Manual check in action (inefficient)\n      ...\n    end\n  end\nend\n</code></pre>"},{"location":"api/rules/#7-document-complex-rules","title":"7. Document Complex Rules","text":"<pre><code># Good - Documented\nrule \"portfolio_rebalancing\", priority: 50 do\n  # Triggers when portfolio drift exceeds threshold\n  # Conditions:\n  # 1. Portfolio exists and is active\n  # 2. Current allocation deviates &gt; 5% from target\n  # Action:\n  # - Calculates rebalancing trades\n  # - Creates pending orders\n\n  on :portfolio, id: :portfolio_id?, status: \"active\"\n  on :drift_calculation, portfolio_id: :portfolio_id?, drift: greater_than(0.05)\n  perform do |facts, bindings|\n    # Implementation...\n  end\nend\n</code></pre>"},{"location":"api/rules/#8-test-rules-in-isolation","title":"8. Test Rules in Isolation","text":"<pre><code>require 'minitest/autorun'\n\nclass TestHighTemperatureRule &lt; Minitest::Test\n  def setup\n    @engine = KBS::Blackboard::Engine.new\n    @fired = false\n\n    @rule = KBS::Rule.new(:high_temp) do |r|\n      r.conditions &lt;&lt; KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n      r.action = -&gt;(facts) { @fired = true }\n    end\n\n    @engine.add_rule(@rule)\n  end\n\n  def test_fires_when_temperature_high\n    @engine.add_fact(:temperature, value: 85)\n    @engine.run\n    assert @fired\n  end\n\n  def test_does_not_fire_when_temperature_low\n    @engine.add_fact(:temperature, value: 75)\n    @engine.run\n    refute @fired\n  end\nend\n</code></pre>"},{"location":"api/rules/#9-use-negation-for-guards","title":"9. Use Negation for Guards","text":"<pre><code># Good - Negation ensures system ready\nrule \"start_processing\" do\n  on :work_item, status: \"pending\"\n  negated :system_error  # Don't process if system has errors\n  perform { process_work_item }\nend\n\n# Alternative - Check in action (less efficient)\nrule \"start_processing\" do\n  on :work_item, status: \"pending\"\n  perform do\n    unless system_has_errors?\n      process_work_item\n    end\n  end\nend\n</code></pre> <p>Why: Negation in condition prevents token creation. Action-based check still creates token (wastes memory).</p>"},{"location":"api/rules/#10-limit-fact-growth","title":"10. Limit Fact Growth","text":"<pre><code># Good - Cleanup rule prevents unbounded growth\nrule \"expire_old_facts\", priority: 0 do\n  on :temperature, timestamp: less_than(Time.now - 3600)\n  perform do |facts, bindings|\n    fact = bindings[:matched_fact?]\n    fact.retract\n  end\nend\n\n# Bad - No cleanup (memory leak)\nloop do\n  engine.add_fact(:temperature, value: rand(100), timestamp: Time.now)\n  engine.run\n  sleep 1\n  # Facts accumulate forever!\nend\n</code></pre>"},{"location":"api/rules/#common-patterns-reference","title":"Common Patterns Reference","text":""},{"location":"api/rules/#rule-priority-examples","title":"Rule Priority Examples","text":"<pre><code># Emergency shutdown\npriority: 1000\n\n# Critical alerts\npriority: 500\n\n# Business logic\npriority: 100\n\n# Data validation\npriority: 50\n\n# Standard processing\npriority: 10\n\n# Logging/auditing\npriority: 5\n\n# Cleanup\npriority: 0\n</code></pre>"},{"location":"api/rules/#action-signatures","title":"Action Signatures","text":"<pre><code># 1. Facts only\naction: -&gt;(facts) do\n  temp_fact = facts[0]\n  puts temp_fact[:value]\nend\n\n# 2. Facts and bindings (recommended)\naction: -&gt;(facts, bindings) do\n  puts bindings[:temp?]\nend\n\n# 3. DSL style (cleanest)\nperform do |facts, bindings|\n  puts bindings[:temp?]\nend\n</code></pre>"},{"location":"api/rules/#condition-patterns","title":"Condition Patterns","text":"<pre><code># Literal matching\non :temperature, location: \"server_room\"\n\n# Range check\non :temperature, value: between(70, 90)\non :temperature, value: greater_than(80)\non :temperature, value: less_than(100)\n\n# Variable binding\non :temperature, location: :loc?, value: :temp?\n\n# Predicate\non :temperature, value: -&gt;(v) { v &gt; 80 &amp;&amp; v &lt; 100 }\n\n# Negation\nnegated :alert, level: \"critical\"\n\n# Collection membership\non :order, status: one_of(\"pending\", \"processing\", \"completed\")\n</code></pre>"},{"location":"api/rules/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/rules/#rule-compilation-cost","title":"Rule Compilation Cost","text":"<p>Adding a rule to the engine compiles it into the RETE network:</p> <pre><code># Cost: O(C) where C = number of conditions\nengine.add_rule(rule)\n</code></pre> <p>Optimization: Add all rules before adding facts:</p> <pre><code># Good\nkb.rules.each { |r| engine.add_rule(r) }  # Compile all rules first\nfacts.each { |f| engine.add_fact(f.type, f.attributes) }  # Then add facts\nengine.run\n\n# Less optimal\nfacts.each do |f|\n  engine.add_fact(f.type, f.attributes)\n  kb.rules.each { |r| engine.add_rule(r) }  # Recompiling for each fact!\n  engine.run\nend\n</code></pre>"},{"location":"api/rules/#condition-ordering","title":"Condition Ordering","text":"<p>Order conditions from most to least selective:</p> <pre><code># Assume:\n# - 10,000 temperature facts\n# - 100 sensor facts\n# - 10 sensors with id=42\n\n# Good (selective first)\nrule \"alert\" do\n  on :sensor, id: 42, status: :status?        # Filters to 10 facts\n  on :temperature, sensor_id: 42, value: :v?  # Then filters to ~100 facts\n  # Creates ~10 intermediate tokens\nend\n\n# Bad (unselective first)\nrule \"alert\" do\n  on :temperature, value: :v?                 # Matches 10,000 facts!\n  on :sensor, id: 42, status: :status?        # Then filters\n  # Creates 10,000 intermediate tokens (slow, memory-intensive)\nend\n</code></pre>"},{"location":"api/rules/#action-complexity","title":"Action Complexity","text":"<p>Keep actions fast:</p> <pre><code># Good - Fast action\nperform do |facts, bindings|\n  puts \"Temperature: #{bindings[:temp?]}\"\nend\n\n# Bad - Slow action blocks engine\nperform do |facts, bindings|\n  sleep 5  # Blocks engine for 5 seconds!\n  send_email_alert(bindings[:temp?])  # Network I/O\nend\n\n# Better - Offload slow work\nperform do |facts, bindings|\n  # Post message for async worker\n  engine.post_message(\"alert_system\", \"email_queue\", bindings)\nend\n</code></pre>"},{"location":"api/rules/#debugging-rules","title":"Debugging Rules","text":""},{"location":"api/rules/#why-didnt-my-rule-fire","title":"Why Didn't My Rule Fire?","text":"<pre><code>def debug_rule(engine, rule_name)\n  rule = engine.rules.find { |r| r.name == rule_name }\n  return \"Rule not found\" unless rule\n\n  puts \"Rule: #{rule.name}\"\n  puts \"Conditions (#{rule.conditions.size}):\"\n\n  rule.conditions.each_with_index do |cond, i|\n    matching_facts = engine.working_memory.facts.select { |f| f.matches?(cond.pattern.merge(type: cond.type)) }\n\n    puts \"  #{i + 1}. #{cond.type} #{cond.pattern}\"\n    puts \"     Negated: #{cond.negated}\"\n    puts \"     Matching facts: #{matching_facts.size}\"\n\n    if matching_facts.empty?\n      puts \"     \u274c NO MATCHING FACTS (rule can't fire)\"\n    else\n      puts \"     \u2713 #{matching_facts.size} facts match\"\n      matching_facts.first(3).each do |f|\n        puts \"       - #{f}\"\n      end\n    end\n  end\n\n  # Check production node\n  prod_node = engine.production_nodes[rule.name]\n  if prod_node\n    puts \"Production node activations: #{prod_node.tokens.size}\"\n  else\n    puts \"Production node not found (rule not compiled?)\"\n  end\nend\n\ndebug_rule(engine, :high_temperature)\n</code></pre>"},{"location":"api/rules/#see-also","title":"See Also","text":"<ul> <li>Engine API - Registering and running rules</li> <li>Facts API - Understanding fact matching</li> <li>DSL Guide - Declarative rule syntax</li> <li>Writing Rules Guide - Best practices and patterns</li> <li>Performance Guide - Optimization strategies</li> <li>Testing Guide - Testing rules in isolation</li> </ul>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>KBS is built on a layered architecture that separates concerns while maintaining high performance.</p>"},{"location":"architecture/#system-layers","title":"System Layers","text":"<p>KBS uses a layered architecture where facts flow from your application through the DSL, RETE engine, and working memory to one of two storage backends.</p>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#1-rete-engine","title":"1. RETE Engine","text":"<p>The heart of KBS. Implements Charles Forgy's RETE algorithm with modern optimizations.</p> <p>Key Files: - <code>lib/kbs/rete_engine.rb</code> - Main engine coordinator - <code>lib/kbs/alpha_memory.rb</code> - Pattern-level fact storage - <code>lib/kbs/beta_memory.rb</code> - Token (partial match) storage - <code>lib/kbs/join_node.rb</code> - Inter-condition joins - <code>lib/kbs/negation_node.rb</code> - Negated condition handling - <code>lib/kbs/production_node.rb</code> - Rule firing coordination</p> <p>Responsibilities: - Compile rules into discrimination networks - Propagate fact changes through the network - Maintain partial matches (tokens) - Fire rules when all conditions are satisfied</p> <p>Learn more: RETE Algorithm Details</p>"},{"location":"architecture/#2-working-memory","title":"2. Working Memory","text":"<p>Stores facts and notifies the RETE engine of changes using the Observer pattern.</p> <p>Variants: - <code>WorkingMemory</code>: Transient in-memory storage - <code>Blackboard::Memory</code>: Persistent storage with audit trails</p> <p>Responsibilities: - Store facts - Notify observers when facts are added/removed - Support queries and bulk operations</p> <p>Learn more: Blackboard Architecture</p>"},{"location":"architecture/#3-dsl-layer","title":"3. DSL Layer","text":"<p>Provides a Ruby-native interface for defining rules, conditions, and patterns.</p> <p>Key Classes: - <code>Rule</code> - Production rule with conditions and actions - <code>Condition</code> - Pattern specification for fact matching - <code>Fact</code> - Knowledge representation unit</p> <p>Example: <pre><code>Rule.new(\"alert\") do |r|\n  r.conditions = [\n    Condition.new(:sensor, { temp: :t? }),\n    Condition.new(:threshold, { max: :max? })\n  ]\n\n  r.action = lambda { |facts, bindings|\n    puts \"Alert!\" if bindings[:t?] &gt; bindings[:max?]\n  }\nend\n</code></pre></p>"},{"location":"architecture/#4-blackboard-system","title":"4. Blackboard System","text":"<p>Multi-agent collaboration framework with persistent shared memory.</p> <p>Components: - Memory - Central workspace for facts - MessageQueue - Priority-based agent communication - AuditLog - Complete history of changes - Persistence - Pluggable storage backends (SQLite, Redis, Hybrid)</p> <p>Use Cases: - Multi-agent problem solving - Audit requirements - Long-running systems - Distributed reasoning</p> <p>Learn more: Blackboard System Details</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#adding-a-fact","title":"Adding a Fact","text":"<pre><code>User Code\n   \u2502\n   \u251c\u2500\u2192 engine.add_fact(:stock, price: 150)\n   \u2502\n   \u25bc\nWorkingMemory.add_fact(fact)\n   \u2502\n   \u251c\u2500\u2192 @facts &lt;&lt; fact\n   \u2514\u2500\u2192 notify_observers(:add, fact)\n          \u2502\n          \u25bc\n       Engine.update(:add, fact)\n          \u2502\n          \u2514\u2500\u2192 For each AlphaMemory:\n                 if fact.matches?(pattern)\n                    \u2502\n                    \u25bc\n                 AlphaMemory.activate(fact)\n                    \u2502\n                    \u2514\u2500\u2192 JoinNode.right_activate(fact)\n                           \u2502\n                           \u2514\u2500\u2192 Create tokens, propagate...\n                                  \u2502\n                                  \u25bc\n                               ProductionNode\n</code></pre>"},{"location":"architecture/#firing-rules","title":"Firing Rules","text":"<pre><code>User Code\n   \u2502\n   \u251c\u2500\u2192 engine.run()\n   \u2502\n   \u25bc\nFor each ProductionNode:\n   \u2502\n   \u251c\u2500\u2192 For each token:\n   \u2502      \u2502\n   \u2502      \u2514\u2500\u2192 rule.fire(token.facts)\n   \u2502             \u2502\n   \u2502             \u2514\u2500\u2192 Extract bindings\n   \u2502                    \u2502\n   \u2502                    \u2514\u2500\u2192 Execute action lambda\n   \u2502                           \u2502\n   \u2502                           \u2514\u2500\u2192 User code in action\n   \u2502\n   \u2514\u2500\u2192 Mark tokens as fired\n</code></pre>"},{"location":"architecture/#network-compilation","title":"Network Compilation","text":"<p>When you add a rule, KBS compiles it into a discrimination network:</p> <pre><code>rule = Rule.new(\"example\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :sym? }),\n    Condition.new(:alert, { symbol: :sym? }, negated: true)\n  ]\n  r.action = -&gt;(facts, bindings) { puts bindings[:sym?] }\nend\n\nengine.add_rule(rule)\n</code></pre> <p>Compiled Network:</p> <p></p> <p>The rule compiles into a network with alpha memories for each condition type, join nodes to combine matches, a negation node for the NOT condition, and a production node that fires when all conditions are satisfied.</p> <p>Learn more: Network Structure</p>"},{"location":"architecture/#performance-characteristics","title":"Performance Characteristics","text":"Operation Complexity Notes Add rule O(C \u00d7 F) C = conditions, F = existing facts Add fact O(N) N = activated nodes (typically &lt;&lt; total) Remove fact O(T) T = tokens containing fact Fire rules O(M) M = complete matches Network sharing O(1) Same pattern \u2192 same alpha memory"},{"location":"architecture/#design-principles","title":"Design Principles","text":""},{"location":"architecture/#1-algorithm-fidelity","title":"1. Algorithm Fidelity","text":"<p>Maintain RETE correctness per Forgy's specifications. No shortcuts that break semantics.</p>"},{"location":"architecture/#2-separation-of-concerns","title":"2. Separation of Concerns","text":"<ul> <li>Engine: Pattern matching</li> <li>Memory: Storage</li> <li>DSL: User interface</li> <li>Blackboard: Collaboration</li> </ul> <p>Each component is independently testable and swappable.</p>"},{"location":"architecture/#3-performance-through-clarity","title":"3. Performance Through Clarity","text":"<p>Optimize algorithm first (unlinking, network sharing), then profile before micro-optimizations.</p>"},{"location":"architecture/#4-testability","title":"4. Testability","text":"<p>Every method testable in isolation. Dependency injection for external services.</p>"},{"location":"architecture/#5-graceful-degradation","title":"5. Graceful Degradation","text":"<p>Optional features (Redis, AI) don't block core functionality. Fallback to SQLite or in-memory.</p>"},{"location":"architecture/#6-auditability","title":"6. Auditability","text":"<p>Complete audit trails for production systems. Know why a rule fired.</p>"},{"location":"architecture/#extension-points","title":"Extension Points","text":""},{"location":"architecture/#custom-persistence","title":"Custom Persistence","text":"<p>Implement <code>KBS::Blackboard::Persistence::Store</code>:</p> <pre><code>class MyStore\n  def save_fact(fact) ... end\n  def load_facts(type) ... end\n  def delete_fact(id) ... end\n  # ...\nend\n\nengine = KBS::Blackboard::Engine.new(store: MyStore.new)\n</code></pre>"},{"location":"architecture/#custom-pattern-matching","title":"Custom Pattern Matching","text":"<p>Override <code>Fact#matches?</code>:</p> <pre><code>class MyFact &lt; KBS::Fact\n  def matches?(pattern)\n    # Custom matching logic\n  end\nend\n</code></pre>"},{"location":"architecture/#custom-rule-actions","title":"Custom Rule Actions","text":"<p>Actions are lambdas - inject any Ruby code:</p> <pre><code>r.action = lambda do |facts, bindings|\n  send_email(bindings[:alert?])\n  log_to_database(facts)\n  trigger_api_call(bindings)\nend\n</code></pre>"},{"location":"architecture/#file-organization","title":"File Organization","text":"<pre><code>lib/kbs/\n\u251c\u2500\u2500 rete_engine.rb         # Main engine\n\u251c\u2500\u2500 working_memory.rb      # Fact storage\n\u251c\u2500\u2500 fact.rb                # Fact representation\n\u251c\u2500\u2500 rule.rb                # Rule definition\n\u251c\u2500\u2500 condition.rb           # Pattern specification\n\u251c\u2500\u2500 token.rb               # Partial match\n\u251c\u2500\u2500 alpha_memory.rb        # Pattern-level cache\n\u251c\u2500\u2500 beta_memory.rb         # Token storage\n\u251c\u2500\u2500 join_node.rb           # Inter-condition joins\n\u251c\u2500\u2500 negation_node.rb       # Negated conditions\n\u251c\u2500\u2500 production_node.rb     # Rule firing\n\u2514\u2500\u2500 blackboard/            # Persistent memory\n    \u251c\u2500\u2500 engine.rb          # Blackboard-aware RETE\n    \u251c\u2500\u2500 memory.rb          # Central workspace\n    \u251c\u2500\u2500 fact.rb            # Persisted fact\n    \u251c\u2500\u2500 message_queue.rb   # Agent communication\n    \u251c\u2500\u2500 audit_log.rb       # Change history\n    \u2514\u2500\u2500 persistence/       # Storage backends\n        \u251c\u2500\u2500 store.rb       # Abstract interface\n        \u251c\u2500\u2500 sqlite_store.rb\n        \u251c\u2500\u2500 redis_store.rb\n        \u2514\u2500\u2500 hybrid_store.rb\n</code></pre>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<ul> <li>RETE Algorithm - Deep dive into pattern matching</li> <li>Blackboard System - Persistent memory architecture</li> <li>Network Structure - How rules compile into networks</li> <li>API Reference - Complete class documentation</li> </ul>"},{"location":"architecture/blackboard/","title":"Blackboard Architecture","text":"<p>The Blackboard pattern is a powerful approach to multi-agent problem-solving where independent knowledge sources collaborate through a shared workspace.</p>"},{"location":"architecture/blackboard/#overview","title":"Overview","text":"<p>Blackboard system with multiple agents reading and writing to shared persistent memory with pluggable storage backends.</p>"},{"location":"architecture/blackboard/#core-concept","title":"Core Concept","text":"<p>The blackboard architecture consists of three main components:</p> <ol> <li>Blackboard (Memory): Central shared workspace for facts</li> <li>Knowledge Sources (Agents): Independent experts that read and write facts</li> <li>Control Component: Coordinates agent execution (often via rules)</li> </ol> <p>Agents operate asynchronously, triggered by changes to the blackboard state. Each agent: - Reads relevant facts from the blackboard - Performs reasoning or computation - Writes conclusions back to the blackboard - Triggers other agents via fact changes</p>"},{"location":"architecture/blackboard/#kbs-implementation","title":"KBS Implementation","text":""},{"location":"architecture/blackboard/#blackboardmemory","title":"Blackboard::Memory","text":"<p>The central workspace that replaces <code>WorkingMemory</code> with persistence:</p> <pre><code>require 'kbs/blackboard'\n\n# Create blackboard with SQLite backend\nmemory = KBS::Blackboard::Memory.new(db_path: 'knowledge_base.db')\n\n# Add facts (persisted automatically)\nfact = memory.add_fact(:stock, {\n  symbol: \"AAPL\",\n  price: 150.50,\n  timestamp: Time.now\n})\n# =&gt; #&lt;KBS::Blackboard::Fact uuid=\"abc-123\" ...&gt;\n\n# Query facts\nstocks = memory.facts_of_type(:stock)\n# =&gt; [#&lt;KBS::Blackboard::Fact ...&gt;, ...]\n\n# Facts survive process restart\nmemory2 = KBS::Blackboard::Memory.new(db_path: 'knowledge_base.db')\nmemory2.facts_of_type(:stock)\n# =&gt; Still there!\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/memory.rb</code></p>"},{"location":"architecture/blackboard/#blackboardengine","title":"Blackboard::Engine","text":"<p>RETE engine with persistent blackboard memory:</p> <pre><code># Create engine with blackboard\nengine = KBS::Blackboard::Engine.new(db_path: 'trading.db')\n\n# Define rules using DSL (persisted in the database)\nkb = KBS.knowledge_base(engine: engine) do\n  rule \"buy_signal\" do\n    on :stock, symbol: :sym?, price: :price?\n    on :threshold, symbol: :sym?, max: :max?\n\n    perform do |facts, bindings|\n      if bindings[:price?] &lt; bindings[:max?]\n        # Write new fact to blackboard\n        fact :order,\n          symbol: bindings[:sym?],\n          action: \"BUY\",\n          price: bindings[:price?]\n      end\n    end\n  end\n\n  # Facts trigger rules, which create new facts\n  fact :stock, symbol: \"AAPL\", price: 145.0\n  fact :threshold, symbol: \"AAPL\", max: 150.0\n  run\n  # =&gt; Creates :order fact in blackboard\nend\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/engine.rb</code></p>"},{"location":"architecture/blackboard/#message-queue","title":"Message Queue","text":"<p>Priority-based communication between agents:</p> <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'system.db')\nqueue = memory.message_queue\n\n# Agent 1: Post high-priority message\nqueue.post(\"risk_analysis\", {\n  alert: \"High volatility detected\",\n  severity: \"critical\"\n}, priority: 10)\n\n# Agent 2: Read and process messages\nmessages = queue.read(\"risk_analysis\", limit: 5)\nmessages.each do |msg|\n  puts \"Processing: #{msg[:data][:alert]}\"\n  queue.acknowledge(msg[:id])\nend\n\n# Unacknowledged messages remain in queue\npending = queue.pending(\"risk_analysis\")\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/message_queue.rb</code></p>"},{"location":"architecture/blackboard/#audit-log","title":"Audit Log","text":"<p>Complete history of all changes for compliance and debugging:</p> <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'audit.db')\naudit = memory.audit_log\n\n# All fact changes are logged automatically\nfact = memory.add_fact(:stock, symbol: \"AAPL\", price: 150)\nmemory.update_fact(fact.id, price: 155)\nmemory.remove_fact(fact)\n\n# Query audit trail\nhistory = audit.fact_history(fact.id)\n# =&gt; [\n#   { action: \"created\", timestamp: ..., data: {price: 150} },\n#   { action: \"updated\", timestamp: ..., data: {price: 155} },\n#   { action: \"deleted\", timestamp: ... }\n# ]\n\n# See what rules fired\nrule_log = audit.rules_fired(limit: 10)\n# =&gt; [\n#   { rule_name: \"buy_signal\", timestamp: ..., facts: [...] },\n#   ...\n# ]\n\n# Recent changes across all facts\nrecent = audit.recent_changes(limit: 20)\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/audit_log.rb</code></p>"},{"location":"architecture/blackboard/#persistence-backends","title":"Persistence Backends","text":""},{"location":"architecture/blackboard/#sqlite-store-default","title":"SQLite Store (Default)","text":"<p>Best for: Single-process applications, development, small-to-medium data.</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n</code></pre> <p>Pros: - \u2705 Zero configuration (no server needed) - \u2705 ACID transactions - \u2705 Durable across restarts - \u2705 Simple backup (copy .db file) - \u2705 Full-text search capabilities</p> <p>Cons: - \u26a0\ufe0f Slower than Redis (still fast for most use cases) - \u26a0\ufe0f Single-writer limitation - \u26a0\ufe0f Not distributed</p> <p>Schema: <pre><code>CREATE TABLE facts (\n  id TEXT PRIMARY KEY,\n  fact_type TEXT NOT NULL,\n  attributes TEXT NOT NULL, -- JSON\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE audit_log (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  fact_id TEXT,\n  action TEXT NOT NULL,\n  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n  data TEXT -- JSON\n);\n\nCREATE TABLE messages (\n  id TEXT PRIMARY KEY,\n  topic TEXT NOT NULL,\n  priority INTEGER DEFAULT 0,\n  data TEXT NOT NULL, -- JSON\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  acknowledged BOOLEAN DEFAULT 0\n);\n</code></pre></p> <p>Implementation: <code>lib/kbs/blackboard/persistence/sqlite_store.rb</code></p>"},{"location":"architecture/blackboard/#redis-store","title":"Redis Store","text":"<p>Best for: High-throughput applications, distributed systems, real-time trading.</p> <pre><code>store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>Pros: - \u2705 100x faster than SQLite for reads/writes - \u2705 Supports distributed agents (multiple processes, machines) - \u2705 Built-in pub/sub for real-time notifications - \u2705 Atomic operations - \u2705 TTL support for ephemeral facts</p> <p>Cons: - \u26a0\ufe0f Requires Redis server - \u26a0\ufe0f Volatile by default (enable RDB/AOF for durability) - \u26a0\ufe0f More complex deployment</p> <p>Data Structures: <pre><code># Facts stored as Redis hashes\nfact:{uuid} \u2192 { type: \"stock\", symbol: \"AAPL\", price: 150 }\n\n# Indexes for efficient queries\nfacts:type:stock \u2192 Set of fact UUIDs\nfacts:active \u2192 Set of all active fact UUIDs\n\n# Messages as sorted sets (by priority)\nmessages:risk_alerts \u2192 ZSet[(msg1, priority), (msg2, priority), ...]\n\n# Audit as lists\nfact_history:{uuid} \u2192 List of change records\nrules_fired:all \u2192 List of rule executions\n</code></pre></p> <p>Implementation: <code>lib/kbs/blackboard/persistence/redis_store.rb</code></p>"},{"location":"architecture/blackboard/#hybrid-store","title":"Hybrid Store","text":"<p>Best for: Production systems needing speed + durability + audit.</p> <pre><code>store = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>Strategy: - Redis: Facts and messages (fast access) - SQLite: Audit log (durable history)</p> <p>Pros: - \u2705 Fast fact operations (Redis) - \u2705 Durable audit trail (SQLite) - \u2705 Best of both worlds</p> <p>Cons: - \u26a0\ufe0f Requires both Redis and SQLite - \u26a0\ufe0f Slightly more complex</p> <p>Implementation: <code>lib/kbs/blackboard/persistence/hybrid_store.rb</code></p>"},{"location":"architecture/blackboard/#multi-agent-example","title":"Multi-Agent Example","text":"<p>Trading system with four specialized agents:</p> <pre><code># Shared blackboard\nengine = KBS::Blackboard::Engine.new(db_path: 'trading.db')\n\nkb = KBS.knowledge_base(engine: engine) do\n  # Agent 1: Market Data Collector\n  rule \"collect_data\", priority: 5 do\n    on :market_open, status: true\n    without :stock_data, symbol: :sym?\n\n    perform do |facts, bindings|\n      price = fetch_current_price(bindings[:sym?])\n      fact :stock_data,\n        symbol: bindings[:sym?],\n        price: price,\n        timestamp: Time.now\n    end\n  end\n\n  # Agent 2: Signal Generator\n  rule \"generate_signals\", priority: 10 do\n    on :stock_data, symbol: :sym?, price: :price?\n    on :sma_data, symbol: :sym?, sma: :sma?\n\n    perform do |facts, bindings|\n      if bindings[:price?] &gt; bindings[:sma?]\n        fact :signal,\n          symbol: bindings[:sym?],\n          direction: \"BUY\",\n          strength: (bindings[:price?] / bindings[:sma?]) - 1.0\n      end\n    end\n  end\n\n  # Agent 3: Risk Manager\n  rule \"check_risk\", priority: 20 do\n    on :signal, symbol: :sym?, direction: :dir?\n    on :portfolio, symbol: :sym?, position: :pos?\n\n    perform do |facts, bindings|\n      if bindings[:pos?] &gt; 1000 &amp;&amp; bindings[:dir?] == \"BUY\"\n        fact :risk_alert,\n          symbol: bindings[:sym?],\n          reason: \"Position limit exceeded\"\n      else\n        fact :approved_signal,\n          symbol: bindings[:sym?],\n          direction: bindings[:dir?]\n      end\n    end\n  end\n\n  # Agent 4: Order Executor\n  rule \"execute_orders\", priority: 30 do\n    on :approved_signal, symbol: :sym?, direction: :dir?\n    without :risk_alert, symbol: :sym?\n\n    perform do |facts, bindings|\n      execute_trade(bindings[:sym?], bindings[:dir?])\n      fact :execution,\n        symbol: bindings[:sym?],\n        direction: bindings[:dir?],\n        timestamp: Time.now\n    end\n  end\n\n  # Trigger the system\n  fact :market_open, status: true\n  fact :portfolio, symbol: \"AAPL\", position: 500\n\n  # Agents collaborate through blackboard\n  run\nend\n</code></pre>"},{"location":"architecture/blackboard/#transactions","title":"Transactions","text":"<p>Ensure atomic multi-fact updates:</p> <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'trades.db')\n\nmemory.transaction do\n  # All or nothing\n  order = memory.add_fact(:order, {\n    symbol: \"AAPL\",\n    action: \"BUY\",\n    quantity: 100\n  })\n\n  execution = memory.add_fact(:execution, {\n    order_id: order.id,\n    price: 150.50,\n    timestamp: Time.now\n  })\n\n  memory.update_fact(order.id, status: \"filled\")\n\n  # If any operation fails, entire transaction rolls back\nend\n</code></pre> <p>Nested transactions are supported via reference counting.</p>"},{"location":"architecture/blackboard/#best-practices","title":"Best Practices","text":""},{"location":"architecture/blackboard/#1-agent-specialization","title":"1. Agent Specialization","text":"<p>Each agent should focus on one aspect of the problem: - \u2705 Data collection - \u2705 Signal generation - \u2705 Risk assessment - \u2705 Execution</p>"},{"location":"architecture/blackboard/#2-priority-based-execution","title":"2. Priority-Based Execution","text":"<p>Use rule priorities to ensure correct agent ordering: <pre><code>data_collector:  priority: 5\nsignal_generator: priority: 10\nrisk_manager:     priority: 20\nexecutor:         priority: 30\n</code></pre></p>"},{"location":"architecture/blackboard/#3-fact-versioning","title":"3. Fact Versioning","text":"<p>Include timestamps for temporal reasoning: <pre><code>engine.add_fact(:price, {\n  symbol: \"AAPL\",\n  value: 150,\n  timestamp: Time.now,\n  source: \"market_data_feed\"\n})\n</code></pre></p>"},{"location":"architecture/blackboard/#4-message-acknowledgment","title":"4. Message Acknowledgment","text":"<p>Always acknowledge processed messages: <pre><code>messages = queue.read(\"alerts\", limit: 10)\nmessages.each do |msg|\n  process_alert(msg[:data])\n  queue.acknowledge(msg[:id])  # Important!\nend\n</code></pre></p>"},{"location":"architecture/blackboard/#5-audit-everything","title":"5. Audit Everything","text":"<p>Use audit log for debugging and compliance: <pre><code># When something goes wrong, trace back\naudit = memory.audit_log\nchanges = audit.recent_changes(limit: 100)\nchanges.each do |change|\n  puts \"#{change[:timestamp]}: #{change[:action]} on #{change[:fact_type]}\"\nend\n</code></pre></p>"},{"location":"architecture/blackboard/#performance-tuning","title":"Performance Tuning","text":""},{"location":"architecture/blackboard/#choose-the-right-backend","title":"Choose the Right Backend","text":"Backend Use Case Performance Durability SQLite Development, single-process Good Excellent Redis High-frequency trading, distributed Excellent Good (with AOF) Hybrid Production systems Excellent Excellent"},{"location":"architecture/blackboard/#batch-operations","title":"Batch Operations","text":"<pre><code># Bad: Individual adds (slow)\n1000.times do |i|\n  memory.add_fact(:reading, sensor: i, value: rand)\nend\n\n# Good: Transaction batch (fast)\nmemory.transaction do\n  1000.times do |i|\n    memory.add_fact(:reading, sensor: i, value: rand)\n  end\nend\n</code></pre>"},{"location":"architecture/blackboard/#index-strategy-sqlite","title":"Index Strategy (SQLite)","text":"<pre><code>-- Add indexes for frequent queries\nCREATE INDEX idx_facts_type ON facts(fact_type);\nCREATE INDEX idx_facts_created ON facts(created_at);\nCREATE INDEX idx_messages_topic ON messages(topic, priority);\n</code></pre>"},{"location":"architecture/blackboard/#redis-memory-management","title":"Redis Memory Management","text":"<pre><code># Set TTL for ephemeral facts\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  ttl: 3600  # Facts expire after 1 hour\n)\n</code></pre>"},{"location":"architecture/blackboard/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"architecture/blackboard/#opportunistic-triggering","title":"Opportunistic Triggering","text":"<p>Agents activate when their preconditions are met:</p> <pre><code># Trigger fires only when specific fact exists\nkb = KBS.knowledge_base(engine: engine) do\n  rule \"on_critical_alert\" do\n    on :alert, severity: \"critical\"\n\n    perform do |facts, bindings|\n      notify_team(facts[0])\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/blackboard/#blackboard-focus","title":"Blackboard Focus","text":"<p>Limit agent attention to relevant facts:</p> <pre><code># Agent only sees recent stock data\nkb = KBS.knowledge_base(engine: engine) do\n  rule \"analyze_recent\" do\n    on :stock_data,\n      symbol: :sym?,\n      timestamp: :ts?,\n      predicate: lambda { |f| Time.now - f[:timestamp] &lt; 300 }  # Last 5 minutes\n\n    perform do |facts, bindings|\n      # Process recent data only\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/blackboard/#conflict-resolution","title":"Conflict Resolution","text":"<p>When multiple agents could act, use priorities:</p> <pre><code>kb = KBS.knowledge_base(engine: engine) do\n  # High priority: Stop-loss overrides everything\n  rule \"stop_loss\", priority: 100 do\n    # ...\n  end\n\n  # Medium priority: Risk management\n  rule \"risk_check\", priority: 50 do\n    # ...\n  end\n\n  # Low priority: Normal trading signals\n  rule \"buy\", priority: 10 do\n    # ...\n  end\nend\n</code></pre>"},{"location":"architecture/blackboard/#next-steps","title":"Next Steps","text":"<ul> <li>Network Structure - How blackboard integrates with RETE</li> <li>Persistence Guide - Choosing and configuring backends</li> <li>Blackboard Examples - Complete working systems</li> <li>Custom Persistence - Build your own backend</li> </ul>"},{"location":"architecture/network-structure/","title":"Network Structure","text":"<p>How RETE compiles rules into an efficient discrimination network.</p>"},{"location":"architecture/network-structure/#overview","title":"Overview","text":"<p>When you add a rule to the engine, KBS compiles it into a discrimination network\u2014a directed acyclic graph (DAG) of nodes that efficiently matches patterns against facts. This document explains the compilation process, node types, and optimization strategies.</p>"},{"location":"architecture/network-structure/#network-compilation-process","title":"Network Compilation Process","text":""},{"location":"architecture/network-structure/#step-1-parse-rule-conditions","title":"Step 1: Parse Rule Conditions","text":"<pre><code>rule = Rule.new(\"example\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :sym?, price: :price? }),\n    Condition.new(:threshold, { symbol: :sym?, max: :max? })\n  ]\n  r.action = lambda { |facts, bindings| ... }\nend\n</code></pre> <p>The engine extracts: - Condition types (<code>:stock</code>, <code>:threshold</code>) - Patterns (attribute constraints) - Variable bindings (<code>:sym?</code>, <code>:price?</code>, <code>:max?</code>) - Join tests (<code>:sym?</code> appears in both conditions)</p>"},{"location":"architecture/network-structure/#step-2-create-or-reuse-alpha-memories","title":"Step 2: Create or Reuse Alpha Memories","text":"<p>For each condition, the engine creates or reuses an <code>AlphaMemory</code> node:</p> <pre><code># Pattern for first condition\npattern1 = { type: :stock, symbol: :sym?, price: :price? }\nalpha1 = get_or_create_alpha_memory(pattern1)\n\n# Pattern for second condition\npattern2 = { type: :threshold, symbol: :sym?, max: :max? }\nalpha2 = get_or_create_alpha_memory(pattern2)\n</code></pre> <p>Network Sharing: If another rule has the same pattern, they share the same alpha memory node.</p>"},{"location":"architecture/network-structure/#step-3-build-join-network","title":"Step 3: Build Join Network","text":"<p>Connect conditions through join nodes:</p> <pre><code># Start with root beta memory (contains dummy token)\ncurrent_beta = @root_beta_memory\n\n# For each condition\nrule.conditions.each do |condition|\n  alpha_memory = get_or_create_alpha_memory(condition.pattern)\n\n  # Build join tests for variable consistency\n  tests = extract_join_tests(condition)\n\n  # Create join or negation node\n  if condition.negated\n    node = NegationNode.new(alpha_memory, current_beta, tests)\n  else\n    node = JoinNode.new(alpha_memory, current_beta, tests)\n  end\n\n  # Create beta memory to store results\n  new_beta = BetaMemory.new\n  node.successors &lt;&lt; new_beta\n  current_beta = new_beta\nend\n</code></pre>"},{"location":"architecture/network-structure/#step-4-attach-production-node","title":"Step 4: Attach Production Node","text":"<pre><code>production_node = ProductionNode.new(rule)\ncurrent_beta.successors &lt;&lt; production_node\n@production_nodes[rule.name] = production_node\n</code></pre>"},{"location":"architecture/network-structure/#node-types","title":"Node Types","text":""},{"location":"architecture/network-structure/#alpha-memory-nodes","title":"Alpha Memory Nodes","text":"<p>Purpose: Store facts matching a specific pattern</p> <p>Structure: <pre><code>class AlphaMemory\n  attr_accessor :items      # Facts that match pattern\n  attr_accessor :successors # Join nodes using this alpha\n  attr_accessor :pattern    # Pattern to match\n  attr_reader :linked       # Unlinking state\nend\n</code></pre></p> <p>Example: <pre><code>AlphaMemory(stock, symbol: \"AAPL\")\n  items: [stock(symbol: \"AAPL\", price: 150), ...]\n  successors: [JoinNode1, JoinNode2, ...]\n</code></pre></p>"},{"location":"architecture/network-structure/#beta-memory-nodes","title":"Beta Memory Nodes","text":"<p>Purpose: Store partial matches (tokens) as they propagate</p> <p>Structure: <pre><code>class BetaMemory\n  attr_accessor :tokens     # Partial matches\n  attr_accessor :successors # Next nodes in network\n  attr_reader :linked       # Unlinking state\nend\n</code></pre></p> <p>Example: <pre><code>BetaMemory\n  tokens: [\n    Token(parent: root, fact: stock(...)),\n    Token(parent: root, fact: stock(...))\n  ]\n  successors: [JoinNode2]\n</code></pre></p>"},{"location":"architecture/network-structure/#join-nodes","title":"Join Nodes","text":"<p>Purpose: Combine facts from alpha memory with tokens from beta memory</p> <p>Structure: <pre><code>class JoinNode\n  attr_accessor :alpha_memory  # Right input\n  attr_accessor :beta_memory   # Left input\n  attr_accessor :tests         # Join tests to perform\n  attr_accessor :successors    # Beta memory nodes\nend\n</code></pre></p> <p>Join Tests: <pre><code>{\n  token_field_index: 0,    # Check first fact in token\n  token_field: :symbol,    # Get its :symbol attribute\n  fact_field: :symbol,     # Compare with new fact's :symbol\n  operation: :eq           # Must be equal\n}\n</code></pre></p>"},{"location":"architecture/network-structure/#negation-nodes","title":"Negation Nodes","text":"<p>Purpose: Implement negated conditions (match when pattern is absent)</p> <p>Structure: <pre><code>class NegationNode\n  attr_accessor :alpha_memory       # Pattern to check\n  attr_accessor :beta_memory        # Tokens to test\n  attr_accessor :tests              # Join tests\n  attr_accessor :tokens_with_matches # Track inhibiting facts\nend\n</code></pre></p> <p>Behavior: - Token arrives \u2192 check alpha memory for matches - No matches found \u2192 propagate token (condition satisfied) - Matches found \u2192 block token (condition not satisfied) - Match removed \u2192 unblock token</p>"},{"location":"architecture/network-structure/#production-nodes","title":"Production Nodes","text":"<p>Purpose: Fire rule actions when all conditions match</p> <p>Structure: <pre><code>class ProductionNode\n  attr_accessor :rule   # Rule to fire\n  attr_accessor :tokens # Complete matches ready to fire\nend\n</code></pre></p>"},{"location":"architecture/network-structure/#complete-example","title":"Complete Example","text":""},{"location":"architecture/network-structure/#rule-definition","title":"Rule Definition","text":"<pre><code>rule = Rule.new(\"trading_signal\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :sym?, price: :price? }),\n    Condition.new(:threshold, { symbol: :sym?, buy_below: :threshold? }),\n    Condition.new(:order, { symbol: :sym? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:price?] &lt; bindings[:threshold?]\n      puts \"BUY #{bindings[:sym?]}\"\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/network-structure/#compiled-network","title":"Compiled Network","text":"<p>The trading signal rule compiles into a network with three join points. The first two join nodes combine stock and threshold facts based on matching symbols. The negation node ensures no existing order for that symbol. Tokens propagate through beta memories, carrying partial matches until reaching the production node.</p>"},{"location":"architecture/network-structure/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"architecture/network-structure/#network-sharing","title":"Network Sharing","text":"<p>Multiple rules with common patterns share alpha memory nodes:</p> <pre><code># Rule 1\nCondition.new(:stock, { symbol: \"AAPL\" })\n\n# Rule 2\nCondition.new(:stock, { symbol: \"AAPL\" })\n\n# Both use the same AlphaMemory node\n# Only one pattern match, one fact storage\n</code></pre>"},{"location":"architecture/network-structure/#unlinking","title":"Unlinking","text":"<p>Empty nodes automatically disconnect to avoid wasted computation:</p> <pre><code># BetaMemory becomes empty\nbeta_memory.remove_token(last_token)\n# =&gt; Calls unlink!\n\n# Downstream nodes stop processing\njoin_node.left_activate(token)  # Returns early if !@left_linked\n</code></pre>"},{"location":"architecture/network-structure/#condition-ordering","title":"Condition Ordering","text":"<p>Place selective conditions first to minimize beta memory size:</p> <pre><code># Good: Specific condition first\nconditions = [\n  Condition.new(:critical_alert, { severity: \"critical\" }),  # Few matches\n  Condition.new(:stock, { symbol: :sym? })                   # Many matches\n]\n\n# Bad: General condition first\nconditions = [\n  Condition.new(:stock, { symbol: :sym? }),                  # Many matches\n  Condition.new(:critical_alert, { severity: \"critical\" })   # Few matches\n]\n</code></pre>"},{"location":"architecture/network-structure/#variable-binding-extraction","title":"Variable Binding Extraction","text":"<p>Variables create join tests automatically:</p> <pre><code># Rule with :sym? in two conditions\ntests = [\n  {\n    token_field_index: 0,     # First fact in token (stock)\n    token_field: :symbol,\n    fact_field: :symbol,      # New fact (threshold)\n    operation: :eq\n  }\n]\n</code></pre>"},{"location":"architecture/network-structure/#network-inspection","title":"Network Inspection","text":""},{"location":"architecture/network-structure/#debugging-network-structure","title":"Debugging Network Structure","text":"<pre><code># See all alpha memories\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern: #{pattern}\"\n  puts \"  Facts: #{memory.items.size}\"\n  puts \"  Linked: #{memory.linked}\"\n  puts \"  Successors: #{memory.successors.size}\"\nend\n\n# See production nodes\nengine.production_nodes.each do |name, node|\n  puts \"Rule: #{name}\"\n  puts \"  Tokens: #{node.tokens.size}\"\nend\n</code></pre>"},{"location":"architecture/network-structure/#visualizing-token-flow","title":"Visualizing Token Flow","text":"<p>Enable tracing in actions:</p> <pre><code>r.action = lambda do |facts, bindings|\n  puts \"Rule '#{rule.name}' fired\"\n  puts \"  Facts: #{facts.map(&amp;:to_s).join(', ')}\"\n  puts \"  Bindings: #{bindings.inspect}\"\nend\n</code></pre>"},{"location":"architecture/network-structure/#performance-implications","title":"Performance Implications","text":""},{"location":"architecture/network-structure/#time-complexity","title":"Time Complexity","text":"Operation Complexity Notes Add rule O(C \u00d7 F) C = conditions, F = facts Network sharing lookup O(1) Hash-based pattern cache Join test O(T) T = number of tests Token propagation O(S) S = successors"},{"location":"architecture/network-structure/#space-complexity","title":"Space Complexity","text":"Structure Space Notes Alpha memories O(P) P = unique patterns across all rules Beta memories O(R \u00d7 C) R = rules, C = avg conditions Tokens O(M \u00d7 C) M = complete matches Join nodes O(R \u00d7 C) One per condition"},{"location":"architecture/network-structure/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Maximize network sharing: Design rules to reuse common patterns</li> <li>Order conditions by selectivity: Specific first, general last</li> <li>Minimize negations: Expensive to maintain</li> <li>Use predicates sparingly: Can't be shared across rules</li> <li>Profile your rules: Use debugging to identify bottlenecks</li> </ol>"},{"location":"architecture/network-structure/#next-steps","title":"Next Steps","text":"<ul> <li>RETE Algorithm - Understand the full execution cycle</li> <li>Blackboard System - Persistent network state</li> <li>Performance Tuning - Optimize for production</li> <li>Debugging Guide - Inspect network state</li> </ul> <p>This document describes implementation details in <code>lib/kbs/rete_engine.rb:58</code> (network compilation) and related node classes.</p>"},{"location":"architecture/rete-algorithm/","title":"The RETE Algorithm in KBS","text":""},{"location":"architecture/rete-algorithm/#overview","title":"Overview","text":"<p>The RETE algorithm is a pattern matching algorithm for implementing production rule systems. Developed by Charles Forgy in 1979, RETE (Latin for \"network\") creates a discrimination network that efficiently matches rules against a working memory of facts. KBS implements the RETE algorithm with the critical unlinking optimization for improved performance.</p>"},{"location":"architecture/rete-algorithm/#why-rete","title":"Why RETE?","text":"<p>Traditional rule engines evaluate all rules against all facts on every cycle, resulting in O(R \u00d7 F) complexity where R is the number of rules and F is the number of facts. RETE achieves near-constant time per working memory change by:</p> <ol> <li>Sharing common patterns across rules in a compiled network</li> <li>Maintaining state between cycles (incremental matching)</li> <li>Processing only changes rather than re-evaluating everything</li> <li>Unlinking empty nodes to skip unnecessary computation (RETE optimization)</li> </ol>"},{"location":"architecture/rete-algorithm/#core-concepts","title":"Core Concepts","text":""},{"location":"architecture/rete-algorithm/#facts","title":"Facts","text":"<p>Facts are the fundamental units of knowledge in the system. Each fact has:</p> <ul> <li>Type: A symbol identifying the kind of fact (e.g., <code>:stock</code>, <code>:alert</code>, <code>:order</code>)</li> <li>Attributes: Key-value pairs containing the fact's data</li> <li>ID: A unique identifier (object_id for transient facts, UUID for persisted facts)</li> </ul> <pre><code># Creating a fact\nfact = engine.add_fact(:stock, symbol: \"AAPL\", price: 150.0, volume: 1000000)\n\n# Fact structure\n# =&gt; stock(symbol: AAPL, price: 150.0, volume: 1000000)\n</code></pre> <p>Implementation: <code>lib/kbs/fact.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#working-memory","title":"Working Memory","text":"<p>Working memory is the collection of all facts currently known to the system. It implements the Observer pattern to notify the RETE network when facts are added or removed.</p> <pre><code>class WorkingMemory\n  def add_fact(fact)\n    @facts &lt;&lt; fact\n    notify_observers(:add, fact)  # Triggers RETE propagation\n  end\n\n  def remove_fact(fact)\n    @facts.delete(fact)\n    notify_observers(:remove, fact)  # Triggers retraction\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/working_memory.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#conditions-and-patterns","title":"Conditions and Patterns","text":"<p>A condition specifies a pattern that facts must match. Patterns can include:</p> <ul> <li>Type matching: <code>{ type: :stock }</code></li> <li>Literal values: <code>{ symbol: \"AAPL\" }</code></li> <li>Variable bindings: <code>{ price: :price? }</code> (variables start with <code>?</code>)</li> <li>Predicates: <code>{ price: -&gt;(p) { p &gt; 100 } }</code></li> <li>Negation: <code>negated: true</code> (match when pattern is absent)</li> </ul> <pre><code># Match any stock with symbol \"AAPL\"\nCondition.new(:stock, { symbol: \"AAPL\" })\n\n# Match stock and bind price to ?price variable\nCondition.new(:stock, { symbol: \"AAPL\", price: :price? })\n\n# Match when there is NO alert for \"AAPL\"\nCondition.new(:alert, { symbol: \"AAPL\" }, negated: true)\n</code></pre> <p>Implementation: <code>lib/kbs/condition.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#rules","title":"Rules","text":"<p>Rules are production rules consisting of:</p> <ul> <li>Conditions (IF part): Patterns to match in working memory</li> <li>Action (THEN part): Code to execute when all conditions match</li> <li>Priority: Optional integer for conflict resolution (higher fires first)</li> </ul> <pre><code>rule = Rule.new(\"high_price_alert\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :symbol?, price: :price? }),\n    Condition.new(:threshold, { symbol: :symbol?, max: :max? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:price?] &gt; bindings[:max?]\n      puts \"Alert: #{bindings[:symbol?]} at #{bindings[:price?]}\"\n    end\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/rule.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#tokens","title":"Tokens","text":"<p>Tokens represent partial matches as they flow through the RETE network. A token is a linked list of facts that have matched conditions so far.</p> <pre><code>class Token\n  attr_accessor :parent, :fact, :node, :children\n\n  # Reconstruct the full chain of matched facts\n  def facts\n    facts = []\n    token = self\n    while token\n      facts.unshift(token.fact) if token.fact\n      token = token.parent\n    end\n    facts\n  end\nend\n</code></pre> <p>Key insights: - The root token has <code>parent = nil</code>, <code>fact = nil</code> and represents \"no conditions matched yet\" - Each join creates a new token linking to its parent token plus a new fact - Tokens form a tree structure via the <code>children</code> array, enabling efficient retraction</p> <p>Implementation: <code>lib/kbs/token.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#network-architecture","title":"Network Architecture","text":"<p>The RETE network is a directed acyclic graph (DAG) consisting of three layers:</p> <p></p> <p>The three-layer RETE network architecture showing alpha memories (pattern matching), beta network (join processing), and production nodes (rule firing).</p>"},{"location":"architecture/rete-algorithm/#layer-1-alpha-network","title":"Layer 1: Alpha Network","text":"<p>The alpha network performs intra-condition tests - matching individual facts against patterns. Each <code>AlphaMemory</code> node:</p> <ul> <li>Stores facts matching a specific pattern</li> <li>Is shared across all rules using the same pattern (network sharing)</li> <li>Propagates matches to successor join nodes</li> </ul> <pre><code>class AlphaMemory\n  attr_accessor :items, :successors, :pattern\n\n  def activate(fact)\n    return unless @linked\n    @items &lt;&lt; fact\n    @successors.each { |s| s.right_activate(fact) }\n  end\nend\n</code></pre> <p>Example: If three rules all match <code>stock(symbol: \"AAPL\")</code>, they share one <code>AlphaMemory</code> node for that pattern.</p> <p>Implementation: <code>lib/kbs/alpha_memory.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#layer-2-beta-network","title":"Layer 2: Beta Network","text":"<p>The beta network performs inter-condition tests - joining facts from different conditions. It consists of:</p>"},{"location":"architecture/rete-algorithm/#join-nodes","title":"Join Nodes","text":"<p><code>JoinNode</code> combines tokens from beta memory (left input) with facts from alpha memory (right input):</p> <pre><code>class JoinNode\n  def left_activate(token)\n    return unless @left_linked &amp;&amp; @right_linked\n\n    @alpha_memory.items.each do |fact|\n      if perform_join_tests(token, fact)\n        new_token = Token.new(token, fact, self)\n        @successors.each { |s| s.activate(new_token) }\n      end\n    end\n  end\n\n  def right_activate(fact)\n    return unless @left_linked &amp;&amp; @right_linked\n\n    @beta_memory.tokens.each do |token|\n      if perform_join_tests(token, fact)\n        new_token = Token.new(token, fact, self)\n        @successors.each { |s| s.activate(new_token) }\n      end\n    end\n  end\nend\n</code></pre> <p>Join tests verify: - Variable consistency (e.g., both conditions match same <code>:symbol?</code>) - Cross-condition predicates (e.g., price1 &gt; price2)</p> <p>Implementation: <code>lib/kbs/join_node.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#beta-memory","title":"Beta Memory","text":"<p><code>BetaMemory</code> stores tokens (partial matches) and implements the unlinking optimization:</p> <pre><code>class BetaMemory\n  def add_token(token)\n    @tokens &lt;&lt; token\n    unlink! if @tokens.empty?     # Unlink when empty\n    relink! if @tokens.size == 1  # Relink when first token arrives\n  end\n\n  def remove_token(token)\n    @tokens.delete(token)\n    unlink! if @tokens.empty?     # Unlink when last token removed\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/beta_memory.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#negation-nodes","title":"Negation Nodes","text":"<p><code>NegationNode</code> implements negated conditions (e.g., \"when there is NO matching fact\"):</p> <pre><code>class NegationNode\n  def left_activate(token)\n    matches = @alpha_memory.items.select { |fact| perform_join_tests(token, fact) }\n\n    if matches.empty?\n      # No inhibiting facts found - propagate the token\n      new_token = Token.new(token, nil, self)\n      @successors.each { |s| s.activate(new_token) }\n    else\n      # Found inhibiting facts - block propagation\n      @tokens_with_matches[token] = matches\n    end\n  end\n\n  def right_deactivate(fact)\n    # When an inhibiting fact is removed, check if we can now propagate\n    @beta_memory.tokens.each do |token|\n      if @tokens_with_matches[token].include?(fact)\n        @tokens_with_matches[token].delete(fact)\n\n        if @tokens_with_matches[token].empty?\n          new_token = Token.new(token, nil, self)\n          @successors.each { |s| s.activate(new_token) }\n        end\n      end\n    end\n  end\nend\n</code></pre> <p>Key insight: Negation nodes propagate tokens with <code>fact = nil</code> since there's no actual fact to include.</p> <p>Implementation: <code>lib/kbs/negation_node.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#layer-3-production-nodes","title":"Layer 3: Production Nodes","text":"<p><code>ProductionNode</code> is the terminal node for each rule. When a token reaches a production node, all rule conditions have been satisfied:</p> <pre><code>class ProductionNode\n  def activate(token)\n    @tokens &lt;&lt; token\n    # Don't fire immediately - wait for engine.run()\n  end\n\n  def fire_rule(token)\n    return if token.fired?\n    @rule.fire(token.facts)\n    token.mark_fired!\n  end\nend\n</code></pre> <p>Why delay firing? Negation nodes may need to deactivate tokens after they're created but before they fire. The two-phase approach (collect tokens, then fire) ensures correctness.</p> <p>Implementation: <code>lib/kbs/production_node.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#the-rete-cycle","title":"The RETE Cycle","text":""},{"location":"architecture/rete-algorithm/#1-network-construction","title":"1. Network Construction","text":"<p>When a rule is added via <code>engine.add_rule(rule)</code>, the network is built:</p> <pre><code>def build_network_for_rule(rule)\n  current_beta = @root_beta_memory\n\n  rule.conditions.each_with_index do |condition, index|\n    # Create or reuse alpha memory\n    pattern = condition.pattern.merge(type: condition.type)\n    alpha_memory = get_or_create_alpha_memory(pattern)\n\n    # Build join tests for variable consistency\n    tests = build_join_tests(condition, index)\n\n    # Create join or negation node\n    if condition.negated\n      negation_node = NegationNode.new(alpha_memory, current_beta, tests)\n      new_beta = BetaMemory.new\n      negation_node.successors &lt;&lt; new_beta\n      current_beta = new_beta\n    else\n      join_node = JoinNode.new(alpha_memory, current_beta, tests)\n      new_beta = BetaMemory.new\n      join_node.successors &lt;&lt; new_beta\n      current_beta = new_beta\n    end\n  end\n\n  # Terminal production node\n  production_node = ProductionNode.new(rule)\n  current_beta.successors &lt;&lt; production_node\n  @production_nodes[rule.name] = production_node\nend\n</code></pre> <p>Implementation: <code>lib/kbs/rete_engine.rb:58</code></p>"},{"location":"architecture/rete-algorithm/#2-fact-assertion","title":"2. Fact Assertion","text":"<p>When <code>engine.add_fact(:stock, symbol: \"AAPL\", price: 150)</code> is called:</p> <p></p> <p>Step-by-step flow showing how a fact propagates through the RETE network from working memory to production nodes.</p>"},{"location":"architecture/rete-algorithm/#3-pattern-matching-flow","title":"3. Pattern Matching Flow","text":"<p>Let's trace a fact through the network for this rule:</p> <pre><code># Rule: Alert when AAPL stock exists but no alert exists\nrule = Rule.new(\"no_alert\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: \"AAPL\" }),\n    Condition.new(:alert, { symbol: \"AAPL\" }, negated: true)\n  ]\n  r.action = -&gt;(facts) { puts \"No alert for AAPL!\" }\nend\n</code></pre> <p></p> <p>Complete trace showing how negation works: adding a stock fact fires the rule, adding an alert inhibits it, and removing the alert reactivates the rule.</p>"},{"location":"architecture/rete-algorithm/#4-rule-execution","title":"4. Rule Execution","text":"<p>The final phase is <code>engine.run()</code>:</p> <pre><code>def run\n  @production_nodes.values.each do |node|\n    node.tokens.each do |token|\n      node.fire_rule(token)\n    end\n  end\nend\n</code></pre> <p>Each production node fires its accumulated tokens. The <code>fired?</code> flag prevents duplicate firing.</p> <p>Implementation: <code>lib/kbs/rete_engine.rb:48</code></p>"},{"location":"architecture/rete-algorithm/#rete-optimization-unlinking","title":"RETE Optimization: Unlinking","text":""},{"location":"architecture/rete-algorithm/#the-problem","title":"The Problem","text":"<p>In basic RETE, join nodes always process activations even when one input is empty:</p> <pre><code>BetaMemory (0 tokens) \u2500\u2500\u2510\n                        \u251c\u2500\u2500\u2192 JoinNode \u2500\u2500\u2192 (does useless work!)\nAlphaMemory (100 facts) \u2518\n</code></pre> <p>If beta memory is empty, the join will produce zero results, wasting CPU cycles.</p>"},{"location":"architecture/rete-algorithm/#the-solution","title":"The Solution","text":"<p>RETE introduces dynamic unlinking: nodes automatically disconnect from the network when empty and reconnect when non-empty.</p> <pre><code>class BetaMemory\n  def add_token(token)\n    @tokens &lt;&lt; token\n    relink! if @tokens.size == 1  # Reconnect when first token arrives\n  end\n\n  def remove_token(token)\n    @tokens.delete(token)\n    unlink! if @tokens.empty?     # Disconnect when empty\n  end\n\n  def relink!\n    @linked = true\n    @successors.each { |s| s.left_relink! }\n  end\n\n  def unlink!\n    @linked = false\n    @successors.each { |s| s.left_unlink! }\n  end\nend\n</code></pre> <p>Join node respects linking state:</p> <pre><code>class JoinNode\n  def left_activate(token)\n    return unless @left_linked &amp;&amp; @right_linked  # Skip if unlinked!\n    # ... perform join ...\n  end\n\n  def right_activate(fact)\n    return unless @left_linked &amp;&amp; @right_linked  # Skip if unlinked!\n    # ... perform join ...\n  end\nend\n</code></pre>"},{"location":"architecture/rete-algorithm/#performance-impact","title":"Performance Impact","text":"<p>For rules with many conditions, unlinking can reduce RETE network activations by 90%+:</p> <ul> <li>Empty alpha memories don't trigger join operations</li> <li>Empty beta memories don't process fact assertions</li> <li>Network \"lights up\" only the relevant paths</li> </ul> <p>This is especially critical for: - Negated conditions (often have empty alpha memories) - Rare patterns (e.g., \"critical alert\" facts) - Complex rules (many conditions = more opportunities for empty nodes)</p>"},{"location":"architecture/rete-algorithm/#variable-binding","title":"Variable Binding","text":"<p>Variables (symbols starting with <code>?</code>) enable cross-condition constraints and action parameterization:</p>"},{"location":"architecture/rete-algorithm/#extraction-during-network-build","title":"Extraction During Network Build","text":"<pre><code>class Condition\n  def extract_variables(pattern)\n    vars = {}\n    pattern.each do |key, value|\n      if value.is_a?(Symbol) &amp;&amp; value.to_s.start_with?('?')\n        vars[value] = key  # { :symbol? =&gt; :symbol, :price? =&gt; :price }\n      end\n    end\n    vars\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/condition.rb:16</code></p>"},{"location":"architecture/rete-algorithm/#join-test-generation","title":"Join Test Generation","text":"<p>Variables create join tests to ensure consistency:</p> <pre><code># Rule with shared ?symbol variable\nconditions = [\n  Condition.new(:stock, { symbol: :symbol?, price: :price? }),\n  Condition.new(:order, { symbol: :symbol?, quantity: 100 })\n]\n\n# Generates join test:\n{\n  token_field_index: 0,      # Check first fact in token (stock)\n  token_field: :symbol,       # Get its :symbol attribute\n  fact_field: :symbol,        # Compare with order's :symbol attribute\n  operation: :eq              # Must be equal\n}\n</code></pre> <p>Implementation: <code>lib/kbs/join_node.rb:89</code></p>"},{"location":"architecture/rete-algorithm/#action-binding","title":"Action Binding","text":"<p>When a rule fires, bindings are extracted for the action:</p> <pre><code>def fire(facts)\n  bindings = extract_bindings(facts)\n  # bindings = { :symbol? =&gt; \"AAPL\", :price? =&gt; 150.0 }\n\n  @action.call(facts, bindings)\nend\n\ndef extract_bindings(facts)\n  bindings = {}\n  @conditions.each_with_index do |condition, index|\n    next if condition.negated  # Negated conditions have no fact\n    fact = facts[index]\n    condition.variable_bindings.each do |var, field|\n      bindings[var] = fact.attributes[field]\n    end\n  end\n  bindings\nend\n</code></pre> <p>Implementation: <code>lib/kbs/rule.rb:34</code></p>"},{"location":"architecture/rete-algorithm/#advanced-topics","title":"Advanced Topics","text":""},{"location":"architecture/rete-algorithm/#conflict-resolution","title":"Conflict Resolution","text":"<p>When multiple rules are activated simultaneously, KBS uses priority (higher values fire first):</p> <pre><code>rule1 = Rule.new(\"urgent\", priority: 10) { ... }\nrule2 = Rule.new(\"normal\", priority: 0) { ... }\n\n# rule1 fires before rule2\n</code></pre> <p>For same-priority rules, firing order is deterministic but unspecified (depends on hash ordering).</p>"},{"location":"architecture/rete-algorithm/#fact-retraction","title":"Fact Retraction","text":"<p>Removing facts triggers recursive token deletion:</p> <pre><code>class JoinNode\n  def right_deactivate(fact)\n    tokens_to_remove = []\n\n    @beta_memory.tokens.each do |token|\n      # Find child tokens containing this fact\n      token.children.select { |child| child.fact == fact }.each do |child|\n        tokens_to_remove &lt;&lt; child\n        @successors.each { |s| s.deactivate(child) }  # Recursive!\n      end\n    end\n\n    tokens_to_remove.each { |token| token.parent.children.delete(token) }\n  end\nend\n</code></pre> <p>This ensures truth maintenance: when a premise is removed, all derived conclusions are also removed.</p> <p>Implementation: <code>lib/kbs/join_node.rb:72</code></p>"},{"location":"architecture/rete-algorithm/#network-sharing","title":"Network Sharing","text":"<p>Alpha memories are shared across rules using pattern as the hash key:</p> <pre><code>def get_or_create_alpha_memory(pattern)\n  @alpha_memories[pattern] ||= AlphaMemory.new(pattern)\nend\n</code></pre> <p>If 10 rules all match <code>stock(symbol: \"AAPL\")</code>, they share one <code>AlphaMemory</code> node, reducing: - Memory usage (one fact store instead of 10) - Computation (one pattern match instead of 10)</p> <p>Implementation: <code>lib/kbs/rete_engine.rb:104</code></p>"},{"location":"architecture/rete-algorithm/#incremental-matching","title":"Incremental Matching","text":"<p>RETE is incremental: after the initial network build, only changes are processed. Adding a fact activates a small subgraph, not the entire network.</p> <p>Complexity: - Initial build: O(R \u00d7 F) where R = rules, F = facts - Per-fact addition: O(N) where N = activated nodes (typically &lt;&lt; R \u00d7 F) - Per-fact removal: O(T) where T = tokens to remove</p> <p>In practice, RETE can handle millions of facts with sub-millisecond updates.</p>"},{"location":"architecture/rete-algorithm/#debugging-rete-networks","title":"Debugging RETE Networks","text":""},{"location":"architecture/rete-algorithm/#visualizing-token-flow","title":"Visualizing Token Flow","text":"<p>Enable token tracing:</p> <pre><code>class Token\n  def to_s\n    \"Token(#{facts.map(&amp;:to_s).join(', ')})\"\n  end\nend\n\n# In your rule action:\nr.action = lambda do |facts, bindings|\n  puts \"Fired with facts: #{facts.map(&amp;:to_s).join(', ')}\"\n  puts \"Bindings: #{bindings.inspect}\"\nend\n</code></pre>"},{"location":"architecture/rete-algorithm/#inspecting-network-state","title":"Inspecting Network State","text":"<p>Check what's in memories:</p> <pre><code># Alpha memory contents\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern #{pattern}: #{memory.items.size} facts\"\n  memory.items.each { |f| puts \"  - #{f}\" }\nend\n\n# Beta memory contents (requires introspection)\ndef walk_beta_network(beta)\n  puts \"Beta memory: #{beta.tokens.size} tokens\"\n  beta.tokens.each { |t| puts \"  - #{t}\" }\n  beta.successors.each do |node|\n    if node.is_a?(BetaMemory)\n      walk_beta_network(node)\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/rete-algorithm/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Forgetting to call <code>engine.run()</code>: Tokens accumulate but rules don't fire</li> <li>Pattern mismatches: <code>{ type: :stock }</code> vs <code>Condition.new(:stock, {})</code> - the latter doesn't filter by type!</li> <li>Variable binding errors: Using <code>?symbol</code> (string) instead of <code>:symbol?</code> (symbol)</li> <li>Negation timing: Negated conditions only fire when facts are absent, not after they're removed (use <code>engine.run()</code> to re-evaluate)</li> </ol>"},{"location":"architecture/rete-algorithm/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/rete-algorithm/#time-complexity","title":"Time Complexity","text":"Operation Complexity Notes Add rule O(C \u00d7 F) C = conditions, F = existing facts Add fact O(N) N = activated nodes (avg &lt;&lt; total nodes) Remove fact O(T) T = tokens containing fact Run rules O(M) M = matched tokens in production nodes"},{"location":"architecture/rete-algorithm/#space-complexity","title":"Space Complexity","text":"Structure Space Notes Alpha memories O(F \u00d7 P) F = facts, P = unique patterns Beta memories O(T) T = partial match tokens Tokens O(C \u00d7 M) C = conditions, M = complete matches Network nodes O(R \u00d7 C) R = rules, C = avg conditions per rule"},{"location":"architecture/rete-algorithm/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Pattern specificity: Put most selective conditions first to reduce beta memory size</li> <li>Negation placement: Place negated conditions last (they don't add facts to tokens)</li> <li>Shared patterns: Design rules to share common patterns</li> <li>Fact pruning: Remove obsolete facts to trigger unlinking</li> <li>Priority tuning: Use priority to fire expensive rules last</li> </ol>"},{"location":"architecture/rete-algorithm/#comparison-with-other-algorithms","title":"Comparison with Other Algorithms","text":""},{"location":"architecture/rete-algorithm/#naive-match-all","title":"Naive Match-All","text":"<pre><code># O(R \u00d7 F) on every cycle\ndef naive_fire_rules\n  rules.each do |rule|\n    facts.each do |fact|\n      if rule.matches?(fact)\n        rule.fire(fact)\n      end\n    end\n  end\nend\n</code></pre> <p>Problem: Re-evaluates everything, no state preservation.</p>"},{"location":"architecture/rete-algorithm/#treat","title":"TREAT","text":"<p>TREAT eliminates alpha/beta network in favor of lazy evaluation: - Pros: Simpler implementation, lower memory - Cons: Slower for rules that fire frequently (no memoization)</p> <p>RETE is better when rules fire often; TREAT is better for sparse firing.</p>"},{"location":"architecture/rete-algorithm/#basic-rete-vs-rete-with-unlinking","title":"Basic RETE vs RETE with Unlinking","text":"<p>Early RETE implementations lacked unlinking: - Without unlinking: All nodes always active, many wasted join operations - With unlinking: Nodes disconnect when empty, up to 10\u00d7 faster</p> <p>KBS implements RETE with unlinking optimization.</p>"},{"location":"architecture/rete-algorithm/#implementation-files","title":"Implementation Files","text":"Component File Lines Core engine <code>lib/kbs/rete_engine.rb</code> ~110 Working memory <code>lib/kbs/working_memory.rb</code> ~35 Facts <code>lib/kbs/fact.rb</code> ~45 Tokens <code>lib/kbs/token.rb</code> ~40 Alpha memory <code>lib/kbs/alpha_memory.rb</code> ~40 Beta memory <code>lib/kbs/beta_memory.rb</code> ~60 Join nodes <code>lib/kbs/join_node.rb</code> ~120 Negation nodes <code>lib/kbs/negation_node.rb</code> ~90 Production nodes <code>lib/kbs/production_node.rb</code> ~30 Conditions <code>lib/kbs/condition.rb</code> ~30 Rules <code>lib/kbs/rule.rb</code> ~50 <p>Total: ~650 lines of core RETE implementation.</p>"},{"location":"architecture/rete-algorithm/#further-reading","title":"Further Reading","text":""},{"location":"architecture/rete-algorithm/#academic-papers","title":"Academic Papers","text":"<ul> <li>Forgy, C. (1982). \"Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem\". Artificial Intelligence, 19(1), 17-37.</li> <li>Forgy, C. (1989). \"Rete: A Fast Match Algorithm\". AI Expert, 4(1), 34-40.</li> </ul>"},{"location":"architecture/rete-algorithm/#textbooks","title":"Textbooks","text":"<ul> <li>Giarratano, J., &amp; Riley, G. (2004). Expert Systems: Principles and Programming (4<sup>th</sup> ed.). Course Technology.</li> <li>Russell, S., &amp; Norvig, P. (2020). Artificial Intelligence: A Modern Approach (4<sup>th</sup> ed.). Pearson. (Chapter on Rule-Based Systems)</li> </ul>"},{"location":"architecture/rete-algorithm/#online-resources","title":"Online Resources","text":"<ul> <li>RETE Algorithm Visualization - Jess documentation</li> <li>Production Systems - Wikipedia</li> <li>Rule-Based Expert Systems - University of Toronto</li> </ul>"},{"location":"architecture/rete-algorithm/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Guide: Learn how to write rules using KBS's Ruby DSL</li> <li>Blackboard Architecture: Understand persistent memory and multi-agent systems</li> <li>Examples: See RETE in action with stock trading and expert systems</li> <li>Performance Tuning: Optimize your rule-based system</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Real-world applications demonstrating KBS capabilities. Each example is available in both low-level API and DSL versions.</p>"},{"location":"examples/#getting-started","title":"Getting Started","text":""},{"location":"examples/#working-demo","title":"Working Demo","text":"<p>Files: <code>working_demo.rb</code> | <code>working_demo_dsl.rb</code></p> <p>Simple trading system demonstrating the basics of KBS with momentum signals, volume alerts, and price movement detection. Perfect starting point for learning KBS fundamentals.</p> <p>Features:</p> <ul> <li>Basic rule definition and pattern matching</li> <li>Stock momentum detection</li> <li>High volume alerts</li> <li>Price change notifications</li> </ul>"},{"location":"examples/#advanced-example","title":"Advanced Example","text":"<p>Files: <code>advanced_example.rb</code> | <code>advanced_example_dsl.rb</code></p> <p>More complex patterns including multi-condition rules, variable bindings, and negation patterns. Shows advanced RETE features and rule chaining.</p> <p>Features:</p> <ul> <li>Multi-condition pattern matching</li> <li>Variable binding and join tests</li> <li>Negation (NOT conditions)</li> <li>Rule priorities</li> </ul>"},{"location":"examples/#stock-trading-systems","title":"Stock Trading Systems","text":""},{"location":"examples/#basic-trading-demo","title":"Basic Trading Demo","text":"<p>Files: <code>trading_demo.rb</code> | <code>trading_demo_dsl.rb</code></p> <p>Foundational trading signals including momentum detection and volume analysis.</p> <p>Features:</p> <ul> <li>Buy/sell signal generation</li> <li>Volume-based alerts</li> <li>Price momentum tracking</li> </ul>"},{"location":"examples/#advanced-stock-trading","title":"Advanced Stock Trading","text":"<p>Files: <code>stock_trading_advanced.rb</code> | <code>stock_trading_advanced_dsl.rb</code></p> <p>Sophisticated trading system with technical indicators, portfolio management, and risk controls.</p> <p>Features:</p> <ul> <li>Golden cross detection (MA crossover)</li> <li>Momentum breakout signals</li> <li>RSI indicators</li> <li>Volume ratio analysis</li> <li>Risk management rules</li> </ul>"},{"location":"examples/#csv-trading-system","title":"CSV Trading System","text":"<p>Files: <code>csv_trading_system.rb</code> | <code>csv_trading_system_dsl.rb</code></p> <p>Complete trading system that processes historical stock data from CSV files, calculates technical indicators, and generates trading signals.</p> <p>Features:</p> <ul> <li>CSV data ingestion</li> <li>Moving average calculations</li> <li>Technical indicator generation</li> <li>Backtesting support</li> <li>Portfolio tracking</li> </ul>"},{"location":"examples/#portfolio-rebalancing-system","title":"Portfolio Rebalancing System","text":"<p>Files: <code>portfolio_rebalancing_system.rb</code> | <code>portfolio_rebalancing_system_dsl.rb</code></p> <p>Sector-based portfolio management with automatic rebalancing, drift detection, and underperformer replacement.</p> <p>Features:</p> <ul> <li>Target allocation management</li> <li>Sector drift detection</li> <li>Automatic rebalancing rules</li> <li>Underperformer identification</li> <li>Position replacement logic</li> </ul>"},{"location":"examples/#timestamped-trading","title":"Timestamped Trading","text":"<p>Files: <code>timestamped_trading.rb</code> | <code>timestamped_trading_dsl.rb</code></p> <p>Time-aware trading system demonstrating temporal reasoning and time-based rule activation.</p> <p>Features:</p> <ul> <li>Time-based rule conditions</li> <li>Stale data detection</li> <li>Market hours awareness</li> <li>Temporal pattern matching</li> </ul>"},{"location":"examples/#redis-high-frequency-trading","title":"Redis High-Frequency Trading","text":"<p>Files: <code>redis_trading_demo.rb</code> | <code>redis_trading_demo_dsl.rb</code></p> <p>High-performance trading system using Redis for fast in-memory fact storage, ideal for low-latency trading applications.</p> <p>Features:</p> <ul> <li>Redis-backed persistence</li> <li>High-frequency market data processing</li> <li>Fast fact lookup and updates</li> <li>Distributed knowledge base support</li> </ul>"},{"location":"examples/#expert-systems","title":"Expert Systems","text":""},{"location":"examples/#car-diagnostic-system","title":"Car Diagnostic System","text":"<p>Files: <code>car_diagnostic.rb</code> | <code>car_diagnostic_dsl.rb</code></p> <p>Expert system for diagnosing car problems based on symptoms. Demonstrates classic expert system pattern with IF-THEN diagnostic rules.</p> <p>Features:</p> <ul> <li>Symptom-based diagnosis</li> <li>Multiple diagnostic rules</li> <li>Recommendation generation</li> <li>Negation for ruling out conditions</li> </ul>"},{"location":"examples/#iot-monitoring-system","title":"IoT Monitoring System","text":"<p>File: <code>iot_demo_using_dsl.rb</code></p> <p>IoT sensor monitoring system with temperature alerts, inventory management, and customer VIP upgrades. Shows real-world DSL usage patterns.</p> <p>Features:</p> <ul> <li>Sensor monitoring</li> <li>Temperature threshold alerts</li> <li>Inventory tracking</li> <li>Multi-domain rules (IoT, inventory, CRM)</li> </ul>"},{"location":"examples/#ai-enhanced-systems","title":"AI-Enhanced Systems","text":""},{"location":"examples/#ai-enhanced-knowledge-base","title":"AI-Enhanced Knowledge Base","text":"<p>Files: <code>ai_enhanced_kbs.rb</code> | <code>ai_enhanced_kbs_dsl.rb</code></p> <p>Integration with Large Language Models (LLMs) for AI-powered sentiment analysis, market insights, and intelligent trading decisions.</p> <p>Features:</p> <ul> <li>LLM integration via <code>ruby_llm</code> gem</li> <li>News sentiment analysis</li> <li>AI-powered market insights</li> <li>MCP agent support</li> <li>Hybrid AI + rule-based reasoning</li> </ul> <p>Requirements:</p> <ul> <li>Ollama running locally (or compatible LLM provider)</li> <li><code>ruby_llm</code> and <code>ruby_llm-mcp</code> gems</li> </ul>"},{"location":"examples/#advanced-features","title":"Advanced Features","text":""},{"location":"examples/#blackboard-memory-system","title":"Blackboard Memory System","text":"<p>Files: <code>blackboard_demo.rb</code> | <code>blackboard_demo_dsl.rb</code></p> <p>Demonstrates persistent blackboard architecture with SQLite storage, message queues, audit logs, and fact history tracking.</p> <p>Features: + - SQLite-backed persistence - UUID-based fact tracking - Message queue (priority-based) - Complete audit trail - Fact update history - Database statistics</p>"},{"location":"examples/#concurrent-inference-patterns","title":"Concurrent Inference Patterns","text":"<p>Files: <code>concurrent_inference_demo.rb</code> | <code>concurrent_inference_demo_dsl.rb</code></p> <p>Advanced patterns for multi-threaded knowledge bases including reactive engines, background inference, and event-driven architectures.</p> <p>Features:</p> <ul> <li>Auto-inference mode (reactive)</li> <li>Background thread inference</li> <li>Event-driven processing</li> <li>Thread-safe fact addition</li> <li>Continuous reasoning loops</li> </ul>"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#run-individual-examples","title":"Run Individual Examples","text":"<p>Each example is executable from the command line:</p> <pre><code># Run a specific example\nruby examples/working_demo.rb\n\n# Run DSL version\nruby examples/working_demo_dsl.rb\n\n# Run AI-enhanced example (requires Ollama)\nOLLAMA_MODEL=gpt-oss:latest ruby examples/ai_enhanced_kbs.rb\n</code></pre>"},{"location":"examples/#run-all-examples","title":"Run All Examples","text":"<p>Run all examples at once:</p> <pre><code># Run all low-level API examples\nruby examples/run_all.rb\n\n# Run all DSL examples\nruby examples/run_all_dsl.rb\n</code></pre>"},{"location":"examples/#example-organization","title":"Example Organization","text":"<ul> <li>Low-level API examples (<code>*.rb</code>) - Direct use of <code>KBS::Engine</code>, <code>KBS::Rule</code>, <code>KBS::Condition</code></li> <li>DSL examples (<code>*_dsl.rb</code>) - Using <code>KBS.knowledge_base</code> and declarative syntax</li> <li>Both versions demonstrate the same functionality with different APIs</li> </ul>"},{"location":"examples/#further-reading","title":"Further Reading","text":"<ul> <li>Quick Start Guide - Step-by-step tutorial</li> <li>DSL Reference - Complete DSL syntax guide</li> <li>Writing Rules - Best practices for rule design</li> <li>Blackboard Memory - Persistence guide</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>Practical guides for using KBS effectively.</p>"},{"location":"guides/#getting-started","title":"Getting Started","text":"<ul> <li>Getting Started - Your first rule-based system</li> <li>Writing Rules - Rule authoring best practices</li> <li>DSL Reference - Complete syntax guide</li> </ul>"},{"location":"guides/#core-concepts","title":"Core Concepts","text":"<ul> <li>Facts - Working with facts and queries</li> <li>Pattern Matching - Pattern syntax and operators</li> <li>Variable Binding - Using variables in rules</li> <li>Negation - Matching absent patterns</li> </ul>"},{"location":"guides/#persistence","title":"Persistence","text":"<ul> <li>Blackboard Memory - Persistent shared memory</li> <li>Persistence Options - SQLite, Redis, and Hybrid backends</li> </ul>"},{"location":"guides/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - See KBS in action</li> <li>Advanced Topics - Production optimization</li> <li>API Reference - Complete class documentation</li> </ul>"},{"location":"guides/blackboard-memory/","title":"Blackboard Memory","text":"<p>The blackboard pattern enables multiple agents to collaborate through a shared persistent workspace. This guide covers using KBS's blackboard memory for multi-agent systems, audit trails, and persistent knowledge bases.</p>"},{"location":"guides/blackboard-memory/#what-is-blackboard-memory","title":"What is Blackboard Memory?","text":"<p>The blackboard architecture consists of three components:</p> <ol> <li>Blackboard (<code>KBS::Blackboard::Memory</code>) - Central shared workspace</li> <li>Knowledge Sources (Agents) - Independent specialists that read/write facts</li> <li>Control (Rules + Priority) - Determines which agent acts when</li> </ol> <p></p> <p>KBS uses the blackboard pattern for persistent, multi-agent reasoning with complete audit trails.</p>"},{"location":"guides/blackboard-memory/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/blackboard-memory/#creating-a-blackboard-engine","title":"Creating a Blackboard Engine","text":"<pre><code>require 'kbs'\n\n# With SQLite (default)\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\nkb = KBS.knowledge_base(engine: engine) do\n  # Facts persist across restarts\n  fact :sensor, id: \"bedroom\", temp: 28\nend\n\nkb.close\n\n# Next run\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nkb = KBS.knowledge_base(engine: engine)\nputs kb.engine.facts.size  # =&gt; 1\n</code></pre>"},{"location":"guides/blackboard-memory/#blackboard-vs-regular-engine","title":"Blackboard vs Regular Engine","text":"<pre><code># Regular engine (transient)\nkb_regular = KBS.knowledge_base do\n  fact :foo, bar: 1\nend\n# Lost on exit\n\n# Blackboard engine (persistent)\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nkb_blackboard = KBS.knowledge_base(engine: engine) do\n  fact :foo, bar: 1\nend\nkb_blackboard.close\n# Persisted to database\n</code></pre>"},{"location":"guides/blackboard-memory/#persistent-facts","title":"Persistent Facts","text":""},{"location":"guides/blackboard-memory/#fact-lifecycle","title":"Fact Lifecycle","text":"<pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# Create fact\nfact = engine.add_fact(:sensor, id: \"bedroom\", temp: 28)\n\n# Fact has UUID\nputs fact.id  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Update fact\nengine.update_fact(fact.id, temp: 30)\n\n# Query fact history\nhistory = engine.fact_history(fact.id)\nhistory.each do |entry|\n  puts \"#{entry[:timestamp]}: #{entry[:operation]} - #{entry[:attributes]}\"\nend\n\n# Delete fact\nengine.delete_fact(fact.id)\n</code></pre>"},{"location":"guides/blackboard-memory/#fact-attributes","title":"Fact Attributes","text":"<p>Blackboard facts support the same interface as regular facts:</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nfact = engine.add_fact(:stock, symbol: \"AAPL\", price: 150)\n\n# Access\nfact.type           # =&gt; :stock\nfact[:symbol]       # =&gt; \"AAPL\"\nfact.attributes     # =&gt; { symbol: \"AAPL\", price: 150 }\nfact.id             # =&gt; UUID string\n\n# Metadata\nfact.created_at     # =&gt; Time object\nfact.updated_at     # =&gt; Time object\n</code></pre>"},{"location":"guides/blackboard-memory/#message-queue","title":"Message Queue","text":"<p>The blackboard includes a priority-based message queue for agent communication:</p>"},{"location":"guides/blackboard-memory/#sending-messages","title":"Sending Messages","text":"<pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# Add message to queue\nengine.send_message(:alerts, \"High temperature detected\", priority: 10)\nengine.send_message(:alerts, \"Critical failure\", priority: 100)  # Higher priority\n</code></pre>"},{"location":"guides/blackboard-memory/#receiving-messages","title":"Receiving Messages","text":"<pre><code># Pop highest priority message\nmsg = engine.pop_message(:alerts)\nputs msg[:content]   # =&gt; \"Critical failure\"\nputs msg[:priority]  # =&gt; 100\n\n# Process all messages\nwhile (msg = engine.pop_message(:alerts))\n  process_alert(msg[:content])\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#message-topics","title":"Message Topics","text":"<p>Organize messages by topic:</p> <pre><code># Different topics for different concerns\nengine.send_message(:sensor_alerts, \"Temp spike\", priority: 50)\nengine.send_message(:system_events, \"Startup complete\", priority: 10)\nengine.send_message(:user_notifications, \"Welcome!\", priority: 1)\n\n# Agents process their own topics\nsensor_agent_msg = engine.pop_message(:sensor_alerts)\nsystem_msg = engine.pop_message(:system_events)\nuser_msg = engine.pop_message(:user_notifications)\n</code></pre>"},{"location":"guides/blackboard-memory/#audit-trail","title":"Audit Trail","text":"<p>Blackboard automatically logs all changes:</p>"},{"location":"guides/blackboard-memory/#fact-audit-log","title":"Fact Audit Log","text":"<pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# Add fact\nfact = engine.add_fact(:order, id: 1, status: \"pending\")\n\n# Update fact\nengine.update_fact(fact.id, status: \"processing\")\n\n# Delete fact\nengine.delete_fact(fact.id)\n\n# Query audit trail\nhistory = engine.fact_history(fact.id)\nhistory.each do |entry|\n  puts \"#{entry[:timestamp]}: #{entry[:operation]}\"\n  puts \"  Attributes: #{entry[:attributes]}\"\nend\n\n# Output:\n# 2025-01-15 10:00:00: add\n#   Attributes: {id: 1, status: \"pending\"}\n# 2025-01-15 10:01:00: update\n#   Attributes: {id: 1, status: \"processing\"}\n# 2025-01-15 10:02:00: delete\n#   Attributes: {id: 1, status: \"processing\"}\n</code></pre>"},{"location":"guides/blackboard-memory/#rule-firing-log","title":"Rule Firing Log","text":"<pre><code># Enable rule firing audit\nengine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',\n  audit_rules: true\n)\n\nkb = KBS.knowledge_base(engine: engine) do\n  rule \"my_rule\" do\n    on :trigger, {}\n    perform { }\n  end\n\n  fact :trigger, {}\n  run\nend\n\n# Query rule firings\nfirings = engine.rule_firings(rule_name: \"my_rule\")\nfirings.each do |firing|\n  puts \"Rule '#{firing[:rule_name]}' fired at #{firing[:timestamp]}\"\n  puts \"  Facts: #{firing[:fact_ids]}\"\n  puts \"  Bindings: #{firing[:bindings]}\"\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#multi-agent-systems","title":"Multi-Agent Systems","text":""},{"location":"guides/blackboard-memory/#agent-pattern","title":"Agent Pattern","text":"<pre><code>class Agent\n  def initialize(name, engine)\n    @name = name\n    @engine = engine\n  end\n\n  def observe\n    # Read facts from blackboard\n    @engine.facts.select { |f| relevant?(f) }\n  end\n\n  def decide(observations)\n    # Apply agent's expertise\n    # Return action or nil\n  end\n\n  def act(action)\n    # Write facts to blackboard\n    # Send messages to other agents\n  end\n\n  def run\n    observations = observe\n    action = decide(observations)\n    act(action) if action\n  end\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#example-trading-system","title":"Example: Trading System","text":"<pre><code>class MarketDataAgent &lt; Agent\n  def run\n    # Fetch market data\n    data = fetch_market_data()\n\n    # Post to blackboard\n    @engine.add_fact(:market_data, {\n      symbol: data[:symbol],\n      price: data[:price],\n      volume: data[:volume],\n      timestamp: Time.now\n    })\n  end\nend\n\nclass TradingAgent &lt; Agent\n  def run\n    # Observe market data\n    market_facts = @engine.facts.select { |f| f.type == :market_data }\n\n    market_facts.each do |fact|\n      # Apply trading strategy\n      if buy_signal?(fact)\n        @engine.add_fact(:order, {\n          symbol: fact[:symbol],\n          type: \"buy\",\n          quantity: calculate_quantity(fact),\n          price: fact[:price]\n        })\n\n        @engine.send_message(:execution, \"New buy order\", priority: 50)\n      end\n    end\n  end\n\n  def buy_signal?(fact)\n    # Agent's expertise\n    fact[:price] &lt; moving_average(fact[:symbol]) * 0.95\n  end\nend\n\nclass ExecutionAgent &lt; Agent\n  def run\n    # Check for execution messages\n    while (msg = @engine.pop_message(:execution))\n      # Find pending orders\n      orders = @engine.facts.select { |f|\n        f.type == :order &amp;&amp; !f[:executed]\n      }\n\n      orders.each do |order|\n        execute_order(order)\n\n        # Update fact\n        @engine.update_fact(order.id, executed: true)\n\n        # Notify\n        @engine.send_message(:notifications, \"Order executed\", priority: 10)\n      end\n    end\n  end\nend\n\n# Run agents in loop\nengine = KBS::Blackboard::Engine.new(db_path: 'trading.db')\n\nmarket_agent = MarketDataAgent.new(\"Market\", engine)\ntrading_agent = TradingAgent.new(\"Trading\", engine)\nexecution_agent = ExecutionAgent.new(\"Execution\", engine)\n\nloop do\n  market_agent.run      # Fetch data \u2192 blackboard\n  trading_agent.run     # Analyze \u2192 create orders\n  execution_agent.run   # Execute orders\n  sleep 1\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#transactions","title":"Transactions","text":"<p>Blackboard supports ACID transactions (SQLite backend):</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# Transaction succeeds\nengine.transaction do\n  engine.add_fact(:account, id: 1, balance: 1000)\n  engine.add_fact(:account, id: 2, balance: 500)\nend\n# Both facts committed\n\n# Transaction fails\nbegin\n  engine.transaction do\n    engine.add_fact(:account, id: 3, balance: 100)\n    raise \"Error!\"\n    engine.add_fact(:account, id: 4, balance: 200)  # Never reached\n  end\nrescue =&gt; e\n  puts \"Transaction rolled back\"\nend\n# No facts committed\n</code></pre>"},{"location":"guides/blackboard-memory/#observers","title":"Observers","text":"<p>Monitor blackboard changes in real-time:</p> <pre><code>class FactObserver\n  def update(operation, fact)\n    case operation\n    when :add\n      puts \"Fact added: #{fact.type} - #{fact.attributes}\"\n    when :remove\n      puts \"Fact removed: #{fact.type} - #{fact.attributes}\"\n    when :update\n      puts \"Fact updated: #{fact.type} - #{fact.attributes}\"\n    end\n  end\nend\n\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nobserver = FactObserver.new\nengine.memory.add_observer(observer)\n\nengine.add_fact(:sensor, temp: 28)\n# Output: Fact added: sensor - {:temp=&gt;28}\n</code></pre>"},{"location":"guides/blackboard-memory/#performance-tuning","title":"Performance Tuning","text":""},{"location":"guides/blackboard-memory/#sqlite-optimization","title":"SQLite Optimization","text":"<pre><code>engine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',\n  journal_mode: 'WAL',       # Write-Ahead Logging\n  synchronous: 'NORMAL',     # Balance durability/speed\n  cache_size: -64000,        # 64MB cache\n  busy_timeout: 5000         # Wait 5s for locks\n)\n</code></pre>"},{"location":"guides/blackboard-memory/#redis-for-speed","title":"Redis for Speed","text":"<pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n\n# 10-100x faster than SQLite\n# Perfect for high-frequency updates\n</code></pre>"},{"location":"guides/blackboard-memory/#hybrid-for-production","title":"Hybrid for Production","text":"<pre><code>require 'kbs/blackboard/persistence/hybrid_store'\n\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n\n# Fast access (Redis) + durable audit (SQLite)\n</code></pre>"},{"location":"guides/blackboard-memory/#best-practices","title":"Best Practices","text":""},{"location":"guides/blackboard-memory/#1-use-uuids-for-fact-references","title":"1. Use UUIDs for Fact References","text":"<pre><code># Good: Store fact UUID\norder_id = engine.add_fact(:order, { ... }).id\nengine.add_fact(:payment, order_id: order_id)\n\n# Bad: Use attribute as reference\nengine.add_fact(:order, id: 1)\nengine.add_fact(:payment, order_id: 1)  # Fragile\n</code></pre>"},{"location":"guides/blackboard-memory/#2-namespace-facts-by-agent","title":"2. Namespace Facts by Agent","text":"<pre><code># Good: Clear ownership\nengine.add_fact(:market_agent_data, { ... })\nengine.add_fact(:trading_agent_signal, { ... })\n\n# Bad: Generic names\nengine.add_fact(:data, { ... })\nengine.add_fact(:signal, { ... })\n</code></pre>"},{"location":"guides/blackboard-memory/#3-use-messages-for-coordination","title":"3. Use Messages for Coordination","text":"<pre><code># Good: Explicit coordination\nengine.send_message(:execution_queue, \"Process order #123\", priority: 50)\n\n# Bad: Polling facts\nloop do\n  orders = engine.facts.select { |f| f.type == :pending_order }\n  # Inefficient\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#4-clean-up-old-facts","title":"4. Clean Up Old Facts","text":"<pre><code># Remove stale data\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\nkb = KBS.knowledge_base(engine: engine) do\n  rule \"cleanup_old_facts\", priority: 1 do\n    on :market_data,\n      timestamp: :time?,\n      predicate: lambda { |f|\n        (Time.now - f[:timestamp]) &gt; 3600  # 1 hour old\n      }\n\n    perform do |facts, bindings|\n      engine.remove_fact(facts[0])\n    end\n  end\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#5-use-transactions-for-multi-fact-updates","title":"5. Use Transactions for Multi-Fact Updates","text":"<pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# Good: Atomic updates\nengine.transaction do\n  engine.update_fact(account1_id, balance: new_balance1)\n  engine.update_fact(account2_id, balance: new_balance2)\nend\n\n# Bad: Separate updates (not atomic)\nengine.update_fact(account1_id, balance: new_balance1)\nengine.update_fact(account2_id, balance: new_balance2)\n</code></pre>"},{"location":"guides/blackboard-memory/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/blackboard-memory/#leader-election","title":"Leader Election","text":"<pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\nkb = KBS.knowledge_base(engine: engine) do\n  # Agent attempts to become leader\n  rule \"become_leader\" do\n    on :agent, name: :name?\n    without :leader, {}\n\n    perform do |facts, bindings|\n      fact :leader, name: bindings[:name?]\n      puts \"#{bindings[:name?]} is now leader\"\n    end\n  end\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#distributed-locking","title":"Distributed Locking","text":"<pre><code># Acquire lock\ndef acquire_lock(engine, resource_id, agent_id)\n  engine.transaction do\n    lock = engine.facts.find { |f|\n      f.type == :lock &amp;&amp; f[:resource_id] == resource_id\n    }\n\n    if lock.nil?\n      engine.add_fact(:lock, {\n        resource_id: resource_id,\n        owner: agent_id,\n        acquired_at: Time.now\n      })\n      true\n    else\n      false\n    end\n  end\nend\n\n# Release lock\ndef release_lock(engine, resource_id, agent_id)\n  lock = engine.facts.find { |f|\n    f.type == :lock &amp;&amp;\n    f[:resource_id] == resource_id &amp;&amp;\n    f[:owner] == agent_id\n  }\n\n  engine.remove_fact(lock) if lock\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#event-sourcing","title":"Event Sourcing","text":"<pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# Store events as facts\nengine.add_fact(:event, {\n  type: \"order_created\",\n  aggregate_id: \"order-123\",\n  data: { item: \"Widget\", quantity: 5 },\n  timestamp: Time.now\n})\n\n# Reconstruct state from events\ndef rebuild_order(engine, order_id)\n  events = engine.facts\n    .select { |f| f.type == :event &amp;&amp; f[:aggregate_id] == order_id }\n    .sort_by { |f| f[:timestamp] }\n\n  state = {}\n  events.each do |event|\n    apply_event(state, event)\n  end\n  state\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#next-steps","title":"Next Steps","text":"<ul> <li>Persistence - Storage backend options</li> <li>Architecture - Blackboard implementation details</li> <li>Blackboard Examples - Complete multi-agent and blackboard systems</li> <li>API Reference - Complete blackboard API</li> </ul> <p>The blackboard pattern enables emergent intelligence through agent collaboration. Each agent contributes expertise to solve problems no single agent could solve alone.</p>"},{"location":"guides/dsl/","title":"DSL Reference Guide","text":"<p>Complete reference for the KBS Domain-Specific Language for defining knowledge bases and rules.</p>"},{"location":"guides/dsl/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Knowledge Base</li> <li>Rule Definition</li> <li>Condition Syntax</li> <li>Pattern Helpers</li> <li>Variable Binding</li> <li>Negation</li> <li>Actions</li> <li>Working with Facts</li> <li>Introspection</li> </ul>"},{"location":"guides/dsl/#quick-start","title":"Quick Start","text":"<p>The KBS DSL provides a natural, English-like syntax for defining knowledge-based systems:</p> <pre><code>require 'kbs'\n\nkb = KBS.knowledge_base do\n  # Define a rule\n  rule \"high_temperature_alert\" do\n    desc \"Alert when temperature exceeds threshold\"\n    priority 10\n\n    on :temperature, value: greater_than(80), location: :loc?\n\n    perform do |facts, bindings|\n      puts \"High temperature at #{bindings[:loc?]}\"\n    end\n  end\n\n  # Add facts\n  fact :temperature, value: 85, location: \"server_room\"\n\n  # Execute rules\n  run\nend\n</code></pre>"},{"location":"guides/dsl/#knowledge-base","title":"Knowledge Base","text":""},{"location":"guides/dsl/#creating-a-knowledge-base","title":"Creating a Knowledge Base","text":""},{"location":"guides/dsl/#kbsknowledge_baseblock","title":"<code>KBS.knowledge_base(&amp;block)</code>","text":"<p>Creates a new knowledge base and evaluates the block in its context.</p> <p>Returns: <code>KBS::DSL::KnowledgeBase</code> instance</p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  # Define rules and add facts here\nend\n\n# Access the underlying engine\nkb.engine  # =&gt; KBS::Engine\n\n# Access defined rules\nkb.rules   # =&gt; Hash of rule_name =&gt; KBS::Rule\n</code></pre></p>"},{"location":"guides/dsl/#knowledge-base-methods","title":"Knowledge Base Methods","text":""},{"location":"guides/dsl/#rulename-block-defrulename-block","title":"<code>rule(name, &amp;block)</code> / <code>defrule(name, &amp;block)</code>","text":"<p>Defines a new rule.</p> <p>Parameters: - <code>name</code> (String or Symbol) - Rule name - <code>&amp;block</code> - Block containing rule definition</p> <p>Returns: <code>KBS::DSL::RuleBuilder</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  rule \"example_rule\" do\n    # Rule definition here\n  end\n\n  # Alias\n  defrule \"another_rule\" do\n    # Rule definition here\n  end\nend\n</code></pre></p>"},{"location":"guides/dsl/#facttype-attributes-asserttype-attributes","title":"<code>fact(type, attributes = {})</code> / <code>assert(type, attributes = {})</code>","text":"<p>Adds a fact to working memory.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type - <code>attributes</code> (Hash) - Fact attributes</p> <p>Returns: <code>KBS::Fact</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85, location: \"server_room\"\n\n  # Alias\n  assert :sensor, id: 1, status: \"active\"\nend\n</code></pre></p>"},{"location":"guides/dsl/#retractfact","title":"<code>retract(fact)</code>","text":"<p>Removes a fact from working memory.</p> <p>Parameters: - <code>fact</code> (KBS::Fact) - Fact to remove</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  temp_fact = fact :temperature, value: 85\n\n  # Later...\n  retract temp_fact\nend\n</code></pre></p>"},{"location":"guides/dsl/#run","title":"<code>run()</code>","text":"<p>Executes all activated rules.</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  rule \"my_rule\" do\n    on :temperature, value: greater_than(80)\n    perform { puts \"High temperature!\" }\n  end\n\n  fact :temperature, value: 85\n\n  run  # Fires \"my_rule\"\nend\n</code></pre></p>"},{"location":"guides/dsl/#reset","title":"<code>reset()</code>","text":"<p>Clears all facts from working memory.</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85\n  fact :humidity, value: 60\n\n  reset  # All facts removed\n\n  puts facts.size  # =&gt; 0\nend\n</code></pre></p>"},{"location":"guides/dsl/#facts","title":"<code>facts()</code>","text":"<p>Returns all facts in working memory.</p> <p>Returns: <code>Array&lt;KBS::Fact&gt;</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85\n  fact :humidity, value: 60\n\n  puts facts.size  # =&gt; 2\n\n  facts.each do |f|\n    puts \"#{f.type}: #{f.attributes}\"\n  end\nend\n</code></pre></p>"},{"location":"guides/dsl/#querytype-pattern","title":"<code>query(type, pattern = {})</code>","text":"<p>Queries facts by type and attributes.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type to match - <code>pattern</code> (Hash) - Attribute key-value pairs to match</p> <p>Returns: <code>Array&lt;KBS::Fact&gt;</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85, location: \"server_room\"\n  fact :temperature, value: 75, location: \"lobby\"\n  fact :humidity, value: 60, location: \"server_room\"\n\n  # Find all temperature facts\n  temps = query(:temperature)\n  puts temps.size  # =&gt; 2\n\n  # Find temperature facts in server_room\n  server_temps = query(:temperature, location: \"server_room\")\n  puts server_temps.size  # =&gt; 1\n  puts server_temps.first[:value]  # =&gt; 85\nend\n</code></pre></p>"},{"location":"guides/dsl/#print_facts","title":"<code>print_facts()</code>","text":"<p>Displays all facts in working memory.</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85\n  fact :humidity, value: 60\n\n  print_facts\nend\n\n# Output:\n# Working Memory Contents:\n# ----------------------------------------\n# 1. temperature(value: 85)\n# 2. humidity(value: 60)\n# ----------------------------------------\n</code></pre></p>"},{"location":"guides/dsl/#print_rules","title":"<code>print_rules()</code>","text":"<p>Displays all defined rules with their conditions.</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  rule \"high_temp\" do\n    desc \"Alert on high temperature\"\n    priority 10\n    on :temperature, value: greater_than(80)\n    perform { puts \"High temp!\" }\n  end\n\n  print_rules\nend\n\n# Output:\n# Knowledge Base Rules:\n# ----------------------------------------\n# Rule: high_temp\n#   Description: Alert on high temperature\n#   Priority: 10\n#   Conditions: 1\n#     1. temperature({:value=&gt;#&lt;Proc:...&gt;})\n# ----------------------------------------\n</code></pre></p>"},{"location":"guides/dsl/#rule-definition","title":"Rule Definition","text":"<p>Rules are defined using the <code>rule</code> method with a block containing:</p> <ol> <li>Metadata: Description and priority</li> <li>Conditions: Patterns to match facts</li> <li>Action: Code to execute when all conditions match</li> </ol>"},{"location":"guides/dsl/#rule-structure","title":"Rule Structure","text":"<pre><code>rule \"rule_name\" do\n  desc \"Optional description\"\n  priority 10  # Optional, default: 0\n\n  # Conditions (one or more)\n  on :fact_type, attribute: value, other: :variable?\n  on :another_type, field: predicate\n\n  # Action\n  perform do |facts, bindings|\n    # Code to execute\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#rule-metadata","title":"Rule Metadata","text":""},{"location":"guides/dsl/#descdescription","title":"<code>desc(description)</code>","text":"<p>Sets the rule description (for documentation and debugging).</p> <p>Parameters: - <code>description</code> (String) - Human-readable description</p> <p>Returns: <code>self</code> (chainable)</p> <p>Example: <pre><code>rule \"temperature_alert\" do\n  desc \"Alerts when server room temperature exceeds safe threshold\"\n\n  on :temperature, location: \"server_room\", value: greater_than(80)\n  perform { puts \"High temperature alert!\" }\nend\n</code></pre></p>"},{"location":"guides/dsl/#prioritylevel","title":"<code>priority(level)</code>","text":"<p>Sets the rule priority (higher priority rules fire first).</p> <p>Parameters: - <code>level</code> (Integer) - Priority level (default: 0)</p> <p>Returns: <code>self</code> (chainable)</p> <p>Note: Priority only affects execution order in <code>KBS::Blackboard::Engine</code>, not <code>KBS::Engine</code>.</p> <p>Example: <pre><code>rule \"critical_shutdown\" do\n  priority 1000  # Highest priority\n  on :temperature, value: greater_than(120)\n  perform { shutdown_system! }\nend\n\nrule \"log_reading\" do\n  priority 1  # Low priority\n  on :temperature, value: :temp?\n  perform { |facts, b| log(b[:temp?]) }\nend\n</code></pre></p>"},{"location":"guides/dsl/#condition-syntax","title":"Condition Syntax","text":"<p>Conditions specify patterns that must match facts in working memory.</p>"},{"location":"guides/dsl/#condition-keywords","title":"Condition Keywords","text":"<p>All of these are aliases - use whichever reads best for your domain:</p> <ul> <li><code>on(type, pattern = {}, &amp;block)</code> - Primary keyword</li> <li><code>given(type, pattern = {})</code> - Alias for <code>on</code></li> <li><code>matches(type, pattern = {})</code> - Alias for <code>on</code></li> <li><code>fact(type, pattern = {})</code> - Alias for <code>on</code></li> <li><code>exists(type, pattern = {})</code> - Alias for <code>on</code></li> </ul> <p>Parameters: - <code>type</code> (Symbol) - Fact type to match - <code>pattern</code> (Hash) - Attribute constraints (key-value pairs) - <code>&amp;block</code> (optional) - Block-style pattern definition</p> <p>Returns: <code>self</code> (chainable)</p>"},{"location":"guides/dsl/#basic-condition-examples","title":"Basic Condition Examples","text":"<pre><code># Match any temperature fact\non :temperature\n\n# Match temperature with specific value\non :temperature, value: 85\n\n# Match temperature with multiple attributes\non :temperature, value: 85, location: \"server_room\"\n\n# Using aliases\ngiven :sensor, status: \"active\"\nmatches :order, status: \"pending\"\nfact :inventory, quantity: 0\nexists :alert, level: \"critical\"\n</code></pre>"},{"location":"guides/dsl/#literal-matching","title":"Literal Matching","text":"<p>Match exact attribute values:</p> <pre><code>on :temperature, location: \"server_room\"  # location must equal \"server_room\"\non :order, status: \"pending\", total: 100  # Both must match exactly\n</code></pre>"},{"location":"guides/dsl/#variable-binding","title":"Variable Binding","text":"<p>Capture attribute values in variables (symbols starting with <code>?</code>):</p> <pre><code>on :temperature, value: :temp?, location: :loc?\n\n# In action:\nperform do |facts, bindings|\n  puts \"Temperature: #{bindings[:temp?]}\"\n  puts \"Location: #{bindings[:loc?]}\"\nend\n</code></pre> <p>Join Test: Same variable in multiple conditions creates a join:</p> <pre><code>on :order, product_id: :pid?, quantity: :qty?\non :inventory, product_id: :pid?, available: :avail?\n\n# These conditions only match when product_id is the same in both facts\n</code></pre>"},{"location":"guides/dsl/#predicate-matching","title":"Predicate Matching","text":"<p>Use lambdas or helper methods for complex conditions:</p> <pre><code># Lambda predicate\non :temperature, value: -&gt;(v) { v &gt; 80 &amp;&amp; v &lt; 100 }\n\n# Helper method (see Pattern Helpers section)\non :temperature, value: greater_than(80)\non :order, total: between(100, 1000)\non :status, code: one_of(\"pending\", \"processing\", \"completed\")\n</code></pre>"},{"location":"guides/dsl/#block-style-patterns","title":"Block-Style Patterns","text":"<p>Define patterns using a block with method-missing magic:</p> <pre><code>on :temperature do\n  value &gt; 80        # Creates lambda: -&gt;(v) { v &gt; 80 }\n  location :loc?    # Binds variable\n  sensor_id 42      # Literal match\nend\n\n# Equivalent to:\non :temperature,\n   value: -&gt;(v) { v &gt; 80 },\n   location: :loc?,\n   sensor_id: 42\n</code></pre> <p>Available operators in blocks: - <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> - Comparison operators - <code>==</code> - Equality (same as literal value) - <code>!=</code> - Inequality - <code>between(min, max)</code> - Range check - <code>in(collection)</code> - Membership check - <code>matches(pattern)</code> - Regex match - <code>any(*values)</code> - Match any of the values - <code>all(*conditions)</code> - All conditions must be true</p> <p>Example: <pre><code>on :order do\n  total &gt; 1000\n  status in [\"pending\", \"processing\"]\n  customer_email matches(/@example\\.com$/)\n  priority any(1, 2, 3)\nend\n</code></pre></p>"},{"location":"guides/dsl/#pattern-helpers","title":"Pattern Helpers","text":"<p>Helper methods available in rule conditions (from <code>ConditionHelpers</code> module).</p>"},{"location":"guides/dsl/#comparison-helpers","title":"Comparison Helpers","text":""},{"location":"guides/dsl/#greater_thanvalue","title":"<code>greater_than(value)</code>","text":"<p>Matches values greater than the specified value.</p> <p>Example: <pre><code>on :temperature, value: greater_than(80)\n# Equivalent to: value: -&gt;(v) { v &gt; 80 }\n</code></pre></p>"},{"location":"guides/dsl/#less_thanvalue","title":"<code>less_than(value)</code>","text":"<p>Matches values less than the specified value.</p> <p>Example: <pre><code>on :inventory, quantity: less_than(10)\n# Equivalent to: quantity: -&gt;(q) { q &lt; 10 }\n</code></pre></p>"},{"location":"guides/dsl/#equalsvalue","title":"<code>equals(value)</code>","text":"<p>Explicitly matches an exact value (same as literal).</p> <p>Example: <pre><code>on :sensor, status: equals(\"active\")\n# Equivalent to: status: \"active\"\n</code></pre></p>"},{"location":"guides/dsl/#not_equalvalue","title":"<code>not_equal(value)</code>","text":"<p>Matches values not equal to the specified value.</p> <p>Example: <pre><code>on :order, status: not_equal(\"cancelled\")\n# Equivalent to: status: -&gt;(s) { s != \"cancelled\" }\n</code></pre></p>"},{"location":"guides/dsl/#range-helpers","title":"Range Helpers","text":""},{"location":"guides/dsl/#betweenmin-max-rangemin-max","title":"<code>between(min, max)</code> / <code>range(min, max)</code>","text":"<p>Matches values in an inclusive range.</p> <p>Example: <pre><code>on :temperature, value: between(70, 90)\n# Equivalent to: value: -&gt;(v) { v &gt;= 70 &amp;&amp; v &lt;= 90 }\n\n# Also works with Range objects:\non :temperature, value: range(70..90)\n</code></pre></p>"},{"location":"guides/dsl/#collection-helpers","title":"Collection Helpers","text":""},{"location":"guides/dsl/#one_ofvalues","title":"<code>one_of(*values)</code>","text":"<p>Matches if value is one of the specified values.</p> <p>Example: <pre><code>on :order, status: one_of(\"pending\", \"processing\", \"completed\")\n# Equivalent to: status: -&gt;(s) { [\"pending\", \"processing\", \"completed\"].include?(s) }\n</code></pre></p>"},{"location":"guides/dsl/#anyvalues","title":"<code>any(*values)</code>","text":"<ul> <li>With arguments: Same as <code>one_of</code></li> <li>Without arguments: Matches any value (always true)</li> </ul> <p>Example: <pre><code># Match one of several values\non :priority, level: any(1, 2, 3)\n\n# Match any value (always true)\non :metadata, extra_data: any\n</code></pre></p>"},{"location":"guides/dsl/#string-helpers","title":"String Helpers","text":""},{"location":"guides/dsl/#matchespattern","title":"<code>matches(pattern)</code>","text":"<p>Matches strings against a regular expression.</p> <p>Example: <pre><code>on :email, address: matches(/@example\\.com$/)\n# Equivalent to: address: -&gt;(a) { a.match?(/@example\\.com$/) }\n\non :sensor, name: matches(/^temp_\\d+$/)\n</code></pre></p>"},{"location":"guides/dsl/#custom-predicates","title":"Custom Predicates","text":""},{"location":"guides/dsl/#satisfiesblock","title":"<code>satisfies(&amp;block)</code>","text":"<p>Creates a custom predicate from a block.</p> <p>Example: <pre><code>on :order, total: satisfies { |t| t &gt; 100 &amp;&amp; t % 10 == 0 }\n# Equivalent to: total: -&gt;(t) { t &gt; 100 &amp;&amp; t % 10 == 0 }\n</code></pre></p>"},{"location":"guides/dsl/#variable-binding_1","title":"Variable Binding","text":"<p>Variables allow you to: 1. Capture attribute values for use in actions 2. Create join tests between conditions</p>"},{"location":"guides/dsl/#variable-syntax","title":"Variable Syntax","text":"<p>Variables are symbols ending with <code>?</code>:</p> <pre><code>:temp?      # Variable named \"temp\"\n:location?  # Variable named \"location\"\n:pid?       # Variable named \"pid\"\n</code></pre>"},{"location":"guides/dsl/#capturing-values","title":"Capturing Values","text":"<pre><code>rule \"temperature_report\" do\n  on :temperature, value: :temp?, location: :loc?, timestamp: :time?\n\n  perform do |facts, bindings|\n    puts \"Temperature at #{bindings[:loc?]}: #{bindings[:temp?]}\u00b0F\"\n    puts \"Recorded: #{bindings[:time?]}\"\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#join-tests","title":"Join Tests","text":"<p>Variables with the same name in different conditions create a join test:</p> <pre><code>rule \"check_inventory\" do\n  on :order, product_id: :pid?, quantity: :qty?\n  on :inventory, product_id: :pid?, available: :avail?\n\n  perform do |facts, bindings|\n    if bindings[:avail?] &lt; bindings[:qty?]\n      puts \"Insufficient inventory for product #{bindings[:pid?]}\"\n    end\n  end\nend\n\n# This rule only fires when:\n# 1. An order fact exists\n# 2. An inventory fact exists\n# 3. Both facts have the SAME product_id\n</code></pre>"},{"location":"guides/dsl/#multiple-bindings","title":"Multiple Bindings","text":"<pre><code>rule \"sensor_temperature_correlation\" do\n  on :sensor, id: :sensor_id?, location: :loc?, status: \"active\"\n  on :temperature, sensor_id: :sensor_id?, value: :temp?\n  on :reading, sensor_id: :sensor_id?, timestamp: :time?\n\n  perform do |facts, bindings|\n    # All three facts share the same sensor_id\n    puts \"Sensor #{bindings[:sensor_id?]} at #{bindings[:loc?]}\"\n    puts \"Reading: #{bindings[:temp?]}\u00b0F at #{bindings[:time?]}\"\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#negation","title":"Negation","text":"<p>Negation matches when a pattern is absent from working memory.</p>"},{"location":"guides/dsl/#negation-keywords","title":"Negation Keywords","text":"<p>All of these are aliases:</p> <ul> <li><code>without(type, pattern = {})</code> - Primary negation keyword</li> <li><code>absent(type, pattern = {})</code> - Alias</li> <li><code>missing(type, pattern = {})</code> - Alias</li> <li><code>lacks(type, pattern = {})</code> - Alias</li> </ul>"},{"location":"guides/dsl/#direct-negation","title":"Direct Negation","text":"<pre><code># Fire when there is NO alert fact\nrule \"all_clear\" do\n  on :system, status: \"running\"\n  without :alert\n  perform { puts \"All systems normal\" }\nend\n\n# Fire when there is NO critical alert\nrule \"no_critical_alerts\" do\n  without :alert, level: \"critical\"\n  perform { puts \"No critical alerts\" }\nend\n\n# Using aliases\nabsent :error\nmissing :problem, severity: \"high\"\nlacks :maintenance_flag\n</code></pre>"},{"location":"guides/dsl/#chained-negation","title":"Chained Negation","text":"<p>Use <code>without</code> (without arguments) followed by <code>on</code>:</p> <pre><code>rule \"example\" do\n  on :order, status: \"pending\"\n  without.on :inventory, quantity: 0\n  perform { puts \"Order can be fulfilled\" }\nend\n</code></pre>"},{"location":"guides/dsl/#negation-with-variables","title":"Negation with Variables","text":"<p>Variables in negated conditions create \"there is no fact with this value\" tests:</p> <pre><code>rule \"no_matching_inventory\" do\n  on :order, product_id: :pid?\n  without :inventory, product_id: :pid?\n\n  perform do |facts, bindings|\n    puts \"No inventory for product #{bindings[:pid?]}\"\n  end\nend\n\n# Fires when:\n# 1. An order exists with product_id=X\n# 2. NO inventory fact exists with product_id=X\n</code></pre>"},{"location":"guides/dsl/#negation-examples","title":"Negation Examples","text":"<pre><code># Guard condition - only process if no errors\nrule \"process_order\" do\n  on :order, status: \"pending\"\n  without :error\n  perform { process_order }\nend\n\n# Detect missing required fact\nrule \"missing_configuration\" do\n  on :system, initialized: true\n  without :config, loaded: true\n  perform { puts \"WARNING: Configuration not loaded\" }\nend\n\n# Timeout detection\nrule \"sensor_timeout\" do\n  on :sensor, id: :sensor_id?, expected: true\n  without :reading, sensor_id: :sensor_id?\n  perform { |facts, b| puts \"Sensor #{b[:sensor_id?]} timeout\" }\nend\n</code></pre>"},{"location":"guides/dsl/#actions","title":"Actions","text":"<p>Actions define what happens when all conditions match.</p>"},{"location":"guides/dsl/#action-keywords","title":"Action Keywords","text":"<p>All of these are aliases:</p> <ul> <li><code>perform(&amp;block)</code> - Primary action keyword</li> <li><code>action(&amp;block)</code> - Alias</li> <li><code>execute(&amp;block)</code> - Alias</li> <li><code>then(&amp;block)</code> - Alias  - TODO: isn't \"then\" a ruby keyword?</li> </ul>"},{"location":"guides/dsl/#action-block","title":"Action Block","text":"<p>Actions receive a <code>bindings</code> hash containing all variable bindings:</p> <pre><code>rule \"example\" do\n  on :temperature, value: :temp?, location: :loc?\n\n  perform do |facts, bindings|\n    temp = bindings[:temp?]\n    location = bindings[:loc?]\n    puts \"Temperature at #{location}: #{temp}\u00b0F\"\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#action-capabilities","title":"Action Capabilities","text":"<p>Actions can:</p> <ol> <li> <p>Read bindings: <pre><code>perform do |facts, bindings|\n  value = bindings[:temp?]\nend\n</code></pre></p> </li> <li> <p>Access the knowledge base (via closure): <pre><code>kb = KBS.knowledge_base do\n  rule \"add_fact_from_action\" do\n    on :trigger, event: \"start\"\n    perform do\n      fact :process, status: \"running\"  # Add new fact\n    end\n  end\nend\n</code></pre></p> </li> <li> <p>Call external methods: <pre><code>perform do |facts, bindings|\n  send_email_alert(bindings[:temp?])\n  log_to_database(bindings)\n  trigger_alarm if bindings[:level?] == \"critical\"\nend\n</code></pre></p> </li> <li> <p>Add/remove facts: <pre><code>perform do |facts, bindings|\n  # Add derived fact\n  fact :alert, level: \"high\", source: bindings[:sensor_id?]\n\n  # Remove triggering fact\n  old_fact = query(:trigger, event: \"start\").first\n  retract old_fact if old_fact\nend\n</code></pre></p> </li> </ol>"},{"location":"guides/dsl/#action-examples","title":"Action Examples","text":"<pre><code># Simple logging\nrule \"log_temperature\" do\n  on :temperature, value: :temp?\n  perform { |facts, b| puts \"Temperature: #{b[:temp?]}\" }\nend\n\n# State machine transition\nrule \"pending_to_processing\" do\n  on :order, id: :order_id?, status: \"pending\"\n  on :worker, status: \"available\", id: :worker_id?\n\n  perform do |facts, bindings|\n    # Update order status\n    order = query(:order, id: bindings[:order_id?]).first\n    retract order\n    fact :order, id: bindings[:order_id?],\n                 status: \"processing\",\n                 worker_id: bindings[:worker_id?]\n\n    # Update worker status\n    worker = query(:worker, id: bindings[:worker_id?]).first\n    retract worker\n    fact :worker, id: bindings[:worker_id?], status: \"busy\"\n  end\nend\n\n# Aggregation\nrule \"daily_summary\" do\n  on :trigger, event: \"end_of_day\"\n\n  perform do\n    temps = query(:temperature).map { |f| f[:value] }\n    avg = temps.sum / temps.size.to_f\n\n    fact :daily_summary,\n         date: Date.today,\n         avg_temp: avg,\n         max_temp: temps.max,\n         min_temp: temps.min\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#working-with-facts","title":"Working with Facts","text":""},{"location":"guides/dsl/#adding-facts","title":"Adding Facts","text":"<pre><code>kb = KBS.knowledge_base do\n  # During initialization\n  fact :temperature, value: 85, location: \"server_room\"\n  fact :sensor, id: 1, status: \"active\"\n\n  # Or from action blocks\n  rule \"add_derived_fact\" do\n    on :temperature, value: greater_than(80)\n    perform do\n      fact :alert, level: \"high\", timestamp: Time.now\n    end\n  end\nend\n\n# After creation\nkb.fact :temperature, value: 90\nkb.assert :humidity, value: 60  # Alias\n</code></pre>"},{"location":"guides/dsl/#removing-facts","title":"Removing Facts","text":"<pre><code>kb = KBS.knowledge_base do\n  temp = fact :temperature, value: 85\n\n  # Remove specific fact\n  retract temp\n\n  # Remove from action\n  rule \"cleanup\" do\n    on :temperature, timestamp: less_than(Time.now - 3600)\n    perform do\n      old_facts = query(:temperature)\n                   .select { |f| f[:timestamp] &lt; Time.now - 3600 }\n      old_facts.each { |f| retract f }\n    end\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#querying-facts","title":"Querying Facts","text":"<pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85, location: \"server_room\"\n  fact :temperature, value: 75, location: \"lobby\"\n  fact :humidity, value: 60, location: \"server_room\"\n\n  # Get all facts\n  all = facts\n\n  # Query by type\n  temps = query(:temperature)\n\n  # Query by type and attributes\n  server_room_temps = query(:temperature, location: \"server_room\")\n\n  # Use query results in actions\n  rule \"check_average\" do\n    on :trigger, event: \"calculate_average\"\n\n    perform do\n      temps = query(:temperature).map { |f| f[:value] }\n      avg = temps.sum / temps.size.to_f\n      puts \"Average temperature: #{avg.round(1)}\u00b0F\"\n    end\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#introspection","title":"Introspection","text":""},{"location":"guides/dsl/#inspecting-facts","title":"Inspecting Facts","text":"<pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85\n  fact :humidity, value: 60\n\n  print_facts\nend\n\n# Output:\n# Working Memory Contents:\n# ----------------------------------------\n# 1. temperature(value: 85)\n# 2. humidity(value: 60)\n# ----------------------------------------\n</code></pre>"},{"location":"guides/dsl/#inspecting-rules","title":"Inspecting Rules","text":"<pre><code>kb = KBS.knowledge_base do\n  rule \"high_temp\" do\n    desc \"Alert on high temperature\"\n    priority 10\n    on :temperature, value: greater_than(80)\n    perform { puts \"High!\" }\n  end\n\n  print_rules\nend\n\n# Output:\n# Knowledge Base Rules:\n# ----------------------------------------\n# Rule: high_temp\n#   Description: Alert on high temperature\n#   Priority: 10\n#   Conditions: 1\n#     1. temperature({:value=&gt;#&lt;Proc:...&gt;})\n# ----------------------------------------\n</code></pre>"},{"location":"guides/dsl/#programmatic-access","title":"Programmatic Access","text":"<pre><code>kb = KBS.knowledge_base do\n  rule \"example\" do\n    on :temperature, value: :temp?\n    perform { |facts, b| puts b[:temp?] }\n  end\nend\n\n# Access rules\nkb.rules  # =&gt; Hash { \"example\" =&gt; KBS::Rule }\nkb.rules[\"example\"]  # =&gt; KBS::Rule instance\n\n# Access engine\nkb.engine  # =&gt; KBS::Engine\nkb.engine.working_memory  # =&gt; KBS::WorkingMemory\nkb.engine.rules  # =&gt; Array&lt;KBS::Rule&gt;\n</code></pre>"},{"location":"guides/dsl/#complete-examples","title":"Complete Examples","text":""},{"location":"guides/dsl/#temperature-monitoring","title":"Temperature Monitoring","text":"<pre><code>require 'kbs'\n\nkb = KBS.knowledge_base do\n  # Rules\n  rule \"high_temperature_alert\" do\n    desc \"Alert when temperature exceeds safe threshold\"\n    priority 10\n\n    on :sensor, id: :sensor_id?, status: \"active\"\n    on :temperature, sensor_id: :sensor_id?, value: greater_than(80)\n    without :alert, sensor_id: :sensor_id?  # No existing alert\n\n    perform do |facts, bindings|\n      puts \"\u26a0\ufe0f  HIGH TEMPERATURE ALERT\"\n      puts \"Sensor: #{bindings[:sensor_id?]}\"\n      puts \"Temperature: #{bindings[:value?]}\u00b0F\"\n\n      # Create alert fact\n      fact :alert,\n           sensor_id: bindings[:sensor_id?],\n           level: \"high\",\n           timestamp: Time.now\n    end\n  end\n\n  rule \"temperature_normal\" do\n    desc \"Clear alert when temperature returns to normal\"\n    priority 5\n\n    on :temperature, sensor_id: :sensor_id?, value: less_than(75)\n    on :alert, sensor_id: :sensor_id?\n\n    perform do |facts, bindings|\n      puts \"\u2713 Temperature normal for sensor #{bindings[:sensor_id?]}\"\n\n      # Remove alert\n      alerts = query(:alert, sensor_id: bindings[:sensor_id?])\n      alerts.each { |a| retract a }\n    end\n  end\n\n  # Initial facts\n  fact :sensor, id: 1, status: \"active\", location: \"server_room\"\n  fact :sensor, id: 2, status: \"active\", location: \"lobby\"\n\n  # Simulate readings\n  fact :temperature, sensor_id: 1, value: 85  # Will trigger alert\n  fact :temperature, sensor_id: 2, value: 72  # Normal\n\n  run\n\n  print_facts\nend\n</code></pre>"},{"location":"guides/dsl/#order-processing-workflow","title":"Order Processing Workflow","text":"<pre><code>kb = KBS.knowledge_base do\n  rule \"validate_order\" do\n    priority 100\n\n    on :order, id: :order_id?, status: \"new\", product_id: :pid?, quantity: :qty?\n    on :inventory, product_id: :pid?, quantity: :available?\n\n    perform do |facts, bindings|\n      if bindings[:available?] &gt;= bindings[:qty?]\n        order = query(:order, id: bindings[:order_id?]).first\n        retract order\n        fact :order,\n             id: bindings[:order_id?],\n             status: \"validated\",\n             product_id: bindings[:pid?],\n             quantity: bindings[:qty?]\n      else\n        fact :alert,\n             type: \"insufficient_inventory\",\n             order_id: bindings[:order_id?]\n      end\n    end\n  end\n\n  rule \"fulfill_order\" do\n    priority 50\n\n    on :order, id: :order_id?, status: \"validated\",\n               product_id: :pid?, quantity: :qty?\n    on :inventory, product_id: :pid?, quantity: :available?\n\n    perform do |facts, bindings|\n      # Deduct inventory\n      inventory = query(:inventory, product_id: bindings[:pid?]).first\n      retract inventory\n      fact :inventory,\n           product_id: bindings[:pid?],\n           quantity: bindings[:available?] - bindings[:qty?]\n\n      # Update order status\n      order = query(:order, id: bindings[:order_id?]).first\n      retract order\n      fact :order,\n           id: bindings[:order_id?],\n           status: \"fulfilled\",\n           product_id: bindings[:pid?],\n           quantity: bindings[:qty?]\n\n      puts \"\u2713 Order #{bindings[:order_id?]} fulfilled\"\n    end\n  end\n\n  # Initial state\n  fact :inventory, product_id: \"ABC\", quantity: 100\n  fact :inventory, product_id: \"XYZ\", quantity: 50\n\n  fact :order, id: 1, status: \"new\", product_id: \"ABC\", quantity: 10\n  fact :order, id: 2, status: \"new\", product_id: \"XYZ\", quantity: 60  # Insufficient!\n\n  run\n  print_facts\nend\n</code></pre>"},{"location":"guides/dsl/#best-practices","title":"Best Practices","text":""},{"location":"guides/dsl/#1-use-descriptive-names","title":"1. Use Descriptive Names","text":"<pre><code># Good\nrule \"high_temperature_alert\" do\n  desc \"Alert when server room temperature exceeds 80\u00b0F\"\n  # ...\nend\n\n# Bad\nrule \"rule1\" do\n  # ...\nend\n</code></pre>"},{"location":"guides/dsl/#2-add-descriptions","title":"2. Add Descriptions","text":"<pre><code>rule \"complex_calculation\" do\n  desc \"Calculates portfolio value using current market prices and holdings\"\n  # ... complex logic ...\nend\n</code></pre>"},{"location":"guides/dsl/#3-order-conditions-by-selectivity","title":"3. Order Conditions by Selectivity","text":"<pre><code># Good - Most selective first\nrule \"specific_sensor_alert\" do\n  on :sensor, id: 42, status: \"active\"  # Very selective\n  on :temperature, sensor_id: 42, value: greater_than(80)\n  perform { puts \"Alert!\" }\nend\n\n# Less efficient - Unselective first\nrule \"specific_sensor_alert\" do\n  on :temperature, value: greater_than(80)  # Matches many facts\n  on :sensor, id: 42, status: \"active\"\n  perform { puts \"Alert!\" }\nend\n</code></pre>"},{"location":"guides/dsl/#4-use-pattern-helpers","title":"4. Use Pattern Helpers","text":"<pre><code># Good - Readable\non :temperature, value: between(70, 90)\non :order, status: one_of(\"pending\", \"processing\")\n\n# Less readable\non :temperature, value: -&gt;(v) { v &gt;= 70 &amp;&amp; v &lt;= 90 }\non :order, status: -&gt;(s) { [\"pending\", \"processing\"].include?(s) }\n</code></pre>"},{"location":"guides/dsl/#5-keep-actions-simple","title":"5. Keep Actions Simple","text":"<pre><code># Good - Simple, focused action\nrule \"log_temperature\" do\n  on :temperature, value: :temp?\n  perform { |facts, b| logger.info(\"Temperature: #{b[:temp?]}\") }\nend\n\n# Avoid - Complex logic in action\nrule \"complex_action\" do\n  on :temperature, value: :temp?\n  perform do |facts, b|\n    # 100 lines of complex logic...\n    # Better to extract to methods\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide - First tutorial</li> <li>Writing Rules Guide - Best practices for rules</li> <li>Pattern Matching Guide - Advanced pattern matching</li> <li>Variable Binding Guide - Join tests and bindings</li> <li>Negation Guide - Negation semantics</li> <li>Rules API - Programmatic rule creation</li> </ul>"},{"location":"guides/facts/","title":"Working with Facts","text":"<p>Facts are the fundamental units of knowledge in KBS. This guide covers the complete lifecycle of facts: creating, querying, updating, and removing them.</p>"},{"location":"guides/facts/#what-is-a-fact","title":"What is a Fact?","text":"<p>A fact represents an observation or piece of knowledge about your domain. Facts have:</p> <ul> <li>Type - A symbol categorizing the fact (e.g., <code>:stock</code>, <code>:sensor</code>, <code>:alert</code>)</li> <li>Attributes - Key-value pairs describing the fact (e.g., <code>{ symbol: \"AAPL\", price: 150 }</code>)</li> <li>Identity - Unique instance in working memory</li> </ul> <p>Example Facts:</p> <pre><code># Sensor reading\ntype: :sensor\nattributes: { id: \"bedroom\", temp: 28, humidity: 65 }\n\n# Stock quote\ntype: :stock\nattributes: { symbol: \"AAPL\", price: 150.50, volume: 1000000 }\n\n# Alert\ntype: :alert\nattributes: { sensor_id: \"bedroom\", message: \"High temperature\" }\n</code></pre>"},{"location":"guides/facts/#fact-types","title":"Fact Types","text":"<p>KBS provides two fact implementations:</p>"},{"location":"guides/facts/#1-transient-facts-kbsfact","title":"1. Transient Facts (<code>KBS::Fact</code>)","text":"<p>In-memory facts that disappear when your program exits.</p> <pre><code>engine = KBS::Engine.new\n\n# Add transient fact\nfact = engine.add_fact(:stock, { symbol: \"AAPL\", price: 150 })\n\n# Facts lost on restart\n</code></pre> <p>Use for: - Short-lived applications - Prototyping - Testing - Pure computation (no persistence needed)</p>"},{"location":"guides/facts/#2-persistent-facts-kbsblackboardfact","title":"2. Persistent Facts (<code>KBS::Blackboard::Fact</code>)","text":"<p>Database-backed facts with UUIDs that survive restarts.</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# Add persistent fact (saved to database)\nfact = engine.add_fact(:stock, { symbol: \"AAPL\", price: 150 })\nputs fact.id  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Facts reload on next run\nengine.close\n\n# Next run\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nputs engine.facts.size  # =&gt; 1 (fact persisted)\n</code></pre> <p>Use for: - Long-running systems - Systems requiring restart - Audit trails - Multi-agent collaboration</p> <p>Both types share the same interface, so code works identically:</p> <pre><code>fact.type           # =&gt; :stock\nfact[:symbol]       # =&gt; \"AAPL\"\nfact[:price]        # =&gt; 150\nfact.attributes     # =&gt; { symbol: \"AAPL\", price: 150 }\n</code></pre>"},{"location":"guides/facts/#creating-facts","title":"Creating Facts","text":""},{"location":"guides/facts/#basic-creation","title":"Basic Creation","text":"<pre><code># Method 1: Via engine (recommended)\nfact = engine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\n\n# Method 2: Direct instantiation\nfact = KBS::Fact.new(:sensor, { id: \"bedroom\", temp: 28 })\nengine.add_fact(fact)\n</code></pre> <p><code>add_fact</code> automatically: - Stores fact in working memory - Triggers pattern matching in RETE network - Notifies observers - Persists to database (if using Blackboard::Engine)</p>"},{"location":"guides/facts/#with-type-conversion","title":"With Type Conversion","text":"<p>Attributes are stored as-is:</p> <pre><code>engine.add_fact(:reading, {\n  value: 42,              # Integer\n  timestamp: Time.now,    # Time object\n  active: true,           # Boolean\n  metadata: { foo: 1 }    # Hash\n})\n</code></pre>"},{"location":"guides/facts/#bulk-creation","title":"Bulk Creation","text":"<pre><code>facts = [\n  [:stock, { symbol: \"AAPL\", price: 150 }],\n  [:stock, { symbol: \"GOOGL\", price: 2800 }],\n  [:stock, { symbol: \"MSFT\", price: 300 }]\n]\n\nfacts.each do |type, attrs|\n  engine.add_fact(type, attrs)\nend\n</code></pre>"},{"location":"guides/facts/#from-external-data","title":"From External Data","text":"<pre><code>require 'json'\n\n# Load from JSON\njson_data = File.read('sensors.json')\nsensor_data = JSON.parse(json_data, symbolize_names: true)\n\nsensor_data.each do |reading|\n  engine.add_fact(:sensor, {\n    id: reading[:sensor_id],\n    temp: reading[:temperature],\n    humidity: reading[:humidity]\n  })\nend\n</code></pre> <pre><code>require 'csv'\n\n# Load from CSV\nCSV.foreach('stocks.csv', headers: true) do |row|\n  engine.add_fact(:stock, {\n    symbol: row['symbol'],\n    price: row['price'].to_f,\n    volume: row['volume'].to_i\n  })\nend\n</code></pre>"},{"location":"guides/facts/#accessing-fact-attributes","title":"Accessing Fact Attributes","text":""},{"location":"guides/facts/#array-style-access","title":"Array-Style Access","text":"<pre><code>fact = engine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\n\n# Read attributes\nfact[:id]     # =&gt; \"bedroom\"\nfact[:temp]   # =&gt; 28\nfact[:missing] # =&gt; nil\n</code></pre>"},{"location":"guides/facts/#attributes-hash","title":"Attributes Hash","text":"<pre><code>fact.attributes\n# =&gt; { id: \"bedroom\", temp: 28 }\n\n# Iterate attributes\nfact.attributes.each do |key, value|\n  puts \"#{key}: #{value}\"\nend\n</code></pre>"},{"location":"guides/facts/#type-access","title":"Type Access","text":"<pre><code>fact.type  # =&gt; :sensor\n</code></pre>"},{"location":"guides/facts/#identity-persistent-facts-only","title":"Identity (Persistent Facts Only)","text":"<pre><code># Blackboard facts have UUIDs\nfact.id  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Transient facts use object_id\nfact.object_id  # =&gt; 70123456789000\n</code></pre>"},{"location":"guides/facts/#querying-facts","title":"Querying Facts","text":""},{"location":"guides/facts/#get-all-facts","title":"Get All Facts","text":"<pre><code>all_facts = engine.facts\n# =&gt; [#&lt;Fact type=:sensor&gt;, #&lt;Fact type=:stock&gt;, ...]\n</code></pre>"},{"location":"guides/facts/#filter-by-type","title":"Filter by Type","text":"<pre><code># Get all sensor facts\nsensors = engine.facts.select { |f| f.type == :sensor }\n\n# Get all stock facts\nstocks = engine.facts.select { |f| f.type == :stock }\n</code></pre>"},{"location":"guides/facts/#filter-by-attribute","title":"Filter by Attribute","text":"<pre><code># Find facts with specific attribute value\nhigh_temps = engine.facts.select { |f|\n  f.type == :sensor &amp;&amp; f[:temp] &amp;&amp; f[:temp] &gt; 30\n}\n\n# Find by multiple criteria\naapl_stocks = engine.facts.select { |f|\n  f.type == :stock &amp;&amp; f[:symbol] == \"AAPL\"\n}\n</code></pre>"},{"location":"guides/facts/#find-single-fact","title":"Find Single Fact","text":"<pre><code># Find first matching fact\nfact = engine.facts.find { |f|\n  f.type == :sensor &amp;&amp; f[:id] == \"bedroom\"\n}\n\n# Or return nil if not found\nfact = engine.facts.find { |f|\n  f.type == :alert &amp;&amp; f[:severity] == \"critical\"\n}\n</code></pre>"},{"location":"guides/facts/#complex-queries","title":"Complex Queries","text":"<pre><code># Count facts\nsensor_count = engine.facts.count { |f| f.type == :sensor }\n\n# Group by type\nfacts_by_type = engine.facts.group_by(&amp;:type)\n# =&gt; { sensor: [...], stock: [...], alert: [...] }\n\n# Map attributes\nsymbols = engine.facts\n  .select { |f| f.type == :stock }\n  .map { |f| f[:symbol] }\n  .uniq\n# =&gt; [\"AAPL\", \"GOOGL\", \"MSFT\"]\n</code></pre>"},{"location":"guides/facts/#query-helper-method","title":"Query Helper Method","text":"<p>Create reusable query methods:</p> <pre><code>class QueryHelper\n  def initialize(engine)\n    @engine = engine\n  end\n\n  def facts_of_type(type)\n    @engine.facts.select { |f| f.type == type }\n  end\n\n  def facts_where(type, &amp;block)\n    facts_of_type(type).select(&amp;block)\n  end\n\n  def fact_where(type, &amp;block)\n    facts_of_type(type).find(&amp;block)\n  end\nend\n\n# Usage\nhelper = QueryHelper.new(engine)\n\n# Get all high-temp sensors\nhigh_temps = helper.facts_where(:sensor) { |f| f[:temp] &gt; 30 }\n\n# Get specific sensor\nbedroom = helper.fact_where(:sensor) { |f| f[:id] == \"bedroom\" }\n</code></pre>"},{"location":"guides/facts/#updating-facts","title":"Updating Facts","text":"<p>Facts are immutable in KBS. To \"update\" a fact, remove the old one and add a new one.</p>"},{"location":"guides/facts/#update-pattern","title":"Update Pattern","text":"<pre><code># Find existing fact\nold_fact = engine.facts.find { |f|\n  f.type == :sensor &amp;&amp; f[:id] == \"bedroom\"\n}\n\nif old_fact\n  # Remove old fact\n  engine.remove_fact(old_fact)\n\n  # Add updated fact\n  engine.add_fact(:sensor, {\n    id: \"bedroom\",\n    temp: 30,  # Updated temperature\n    humidity: 65\n  })\n\n  # Re-run matching\n  engine.run\nend\n</code></pre>"},{"location":"guides/facts/#update-helper","title":"Update Helper","text":"<pre><code>def update_fact(engine, type, matcher, new_attrs)\n  old_fact = engine.facts.find { |f|\n    f.type == type &amp;&amp; matcher.call(f)\n  }\n\n  if old_fact\n    engine.remove_fact(old_fact)\n    engine.add_fact(type, new_attrs)\n  end\nend\n\n# Usage\nupdate_fact(engine, :sensor, -&gt;(f) { f[:id] == \"bedroom\" },\n  { id: \"bedroom\", temp: 30, humidity: 65 }\n)\n</code></pre>"},{"location":"guides/facts/#blackboard-update-persistent-facts","title":"Blackboard Update (Persistent Facts)","text":"<p>Blackboard facts support in-place updates:</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\nfact = engine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\n\n# Update attributes (saves to database)\nfact.update({ temp: 30 })\n\n# Or update via engine\nengine.update_fact(fact.id, { temp: 32 })\n</code></pre>"},{"location":"guides/facts/#removing-facts","title":"Removing Facts","text":""},{"location":"guides/facts/#remove-single-fact","title":"Remove Single Fact","text":"<pre><code># Find and remove\nfact = engine.facts.find { |f| f.type == :alert }\nengine.remove_fact(fact) if fact\n\n# Re-run to propagate changes\nengine.run\n</code></pre>"},{"location":"guides/facts/#remove-multiple-facts","title":"Remove Multiple Facts","text":"<pre><code># Remove all alerts\nalerts = engine.facts.select { |f| f.type == :alert }\nalerts.each { |fact| engine.remove_fact(fact) }\nengine.run\n</code></pre>"},{"location":"guides/facts/#remove-by-criteria","title":"Remove by Criteria","text":"<pre><code># Remove all stale sensor readings (older than 5 minutes)\nstale = engine.facts.select { |f|\n  f.type == :sensor &amp;&amp;\n  f[:timestamp] &amp;&amp;\n  (Time.now - f[:timestamp]) &gt; 300\n}\n\nstale.each { |fact| engine.remove_fact(fact) }\nengine.run\n</code></pre>"},{"location":"guides/facts/#clear-all-facts","title":"Clear All Facts","text":"<pre><code># Clear working memory\nengine.facts.dup.each { |f| engine.remove_fact(f) }\nengine.run\n</code></pre> <p>Note: Use <code>.dup</code> to avoid modifying array while iterating.</p>"},{"location":"guides/facts/#fact-lifecycle","title":"Fact Lifecycle","text":""},{"location":"guides/facts/#lifecycle-stages","title":"Lifecycle Stages","text":"<pre><code>1. Creation\n   \u251c\u2500&gt; engine.add_fact(:type, { ... })\n   \u2514\u2500&gt; Fact instantiated\n\n2. Storage\n   \u251c\u2500&gt; Added to WorkingMemory\n   \u2514\u2500&gt; Persisted (if Blackboard::Engine)\n\n3. Matching\n   \u251c\u2500&gt; Alpha network activation\n   \u251c\u2500&gt; Join network propagation\n   \u2514\u2500&gt; Production node tokens created\n\n4. Rule Firing\n   \u251c\u2500&gt; engine.run()\n   \u2514\u2500&gt; Actions execute with fact\n\n5. Update (Optional)\n   \u251c\u2500&gt; engine.remove_fact(old_fact)\n   \u251c\u2500&gt; engine.add_fact(:type, new_attrs)\n   \u2514\u2500&gt; Matching re-triggered\n\n6. Removal\n   \u251c\u2500&gt; engine.remove_fact(fact)\n   \u251c\u2500&gt; Removed from WorkingMemory\n   \u251c\u2500&gt; Deleted from database (if persistent)\n   \u2514\u2500&gt; Tokens invalidated\n</code></pre>"},{"location":"guides/facts/#observing-fact-changes","title":"Observing Fact Changes","text":"<p>Working memory uses the Observer pattern:</p> <pre><code>class FactObserver\n  def update(operation, fact)\n    case operation\n    when :add\n      puts \"Added: #{fact.type} - #{fact.attributes}\"\n    when :remove\n      puts \"Removed: #{fact.type} - #{fact.attributes}\"\n    end\n  end\nend\n\nobserver = FactObserver.new\nengine.working_memory.add_observer(observer)\n\nengine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\n# Output: Added: sensor - {:id=&gt;\"bedroom\", :temp=&gt;28}\n</code></pre>"},{"location":"guides/facts/#best-practices","title":"Best Practices","text":""},{"location":"guides/facts/#1-use-consistent-fact-types","title":"1. Use Consistent Fact Types","text":"<pre><code># Good: Consistent naming\n:sensor_reading\n:stock_quote\n:user_alert\n\n# Bad: Inconsistent\n:sensor\n:Stock\n:UserAlert\n</code></pre>"},{"location":"guides/facts/#2-keep-attributes-flat","title":"2. Keep Attributes Flat","text":"<pre><code># Good: Flat structure\nengine.add_fact(:sensor, {\n  sensor_id: \"bedroom\",\n  temp: 28,\n  humidity: 65\n})\n\n# Bad: Nested (harder to match)\nengine.add_fact(:sensor, {\n  id: \"bedroom\",\n  readings: { temp: 28, humidity: 65 }\n})\n</code></pre>"},{"location":"guides/facts/#3-include-timestamps","title":"3. Include Timestamps","text":"<pre><code># Good: Temporal reasoning enabled\nengine.add_fact(:reading, {\n  sensor_id: \"bedroom\",\n  value: 28,\n  timestamp: Time.now\n})\n</code></pre>"},{"location":"guides/facts/#4-validate-before-adding","title":"4. Validate Before Adding","text":"<pre><code>def add_sensor_reading(engine, id, temp)\n  # Validate\n  raise ArgumentError, \"Invalid temp\" unless temp.is_a?(Numeric)\n  raise ArgumentError, \"Temp out of range\" unless temp.between?(-50, 100)\n\n  # Add fact\n  engine.add_fact(:sensor, {\n    id: id,\n    temp: temp,\n    timestamp: Time.now\n  })\nend\n</code></pre>"},{"location":"guides/facts/#5-use-symbols-for-type","title":"5. Use Symbols for Type","text":"<pre><code># Good\nengine.add_fact(:sensor, { ... })\n\n# Bad\nengine.add_fact(\"sensor\", { ... })  # Strings not idiomatic\n</code></pre>"},{"location":"guides/facts/#6-namespace-fact-types","title":"6. Namespace Fact Types","text":"<pre><code># Good: Clear namespacing for large systems\n:trading_order\n:trading_execution\n:trading_alert\n\n:sensor_temp\n:sensor_humidity\n:sensor_pressure\n</code></pre>"},{"location":"guides/facts/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/facts/#fact-factory","title":"Fact Factory","text":"<pre><code>class SensorFactFactory\n  def self.create_reading(id, temp, humidity)\n    {\n      type: :sensor,\n      attributes: {\n        id: id,\n        temp: temp,\n        humidity: humidity,\n        timestamp: Time.now\n      }\n    }\n  end\nend\n\n# Usage\nreading = SensorFactFactory.create_reading(\"bedroom\", 28, 65)\nengine.add_fact(reading[:type], reading[:attributes])\n</code></pre>"},{"location":"guides/facts/#fact-builder","title":"Fact Builder","text":"<pre><code>class FactBuilder\n  def initialize(type)\n    @type = type\n    @attributes = {}\n  end\n\n  def with(key, value)\n    @attributes[key] = value\n    self\n  end\n\n  def build\n    [@type, @attributes]\n  end\nend\n\n# Usage\ntype, attrs = FactBuilder.new(:stock)\n  .with(:symbol, \"AAPL\")\n  .with(:price, 150)\n  .with(:volume, 1000000)\n  .build\n\nengine.add_fact(type, attrs)\n</code></pre>"},{"location":"guides/facts/#fact-repository","title":"Fact Repository","text":"<pre><code>class FactRepository\n  def initialize(engine)\n    @engine = engine\n  end\n\n  def add(type, attributes)\n    @engine.add_fact(type, attributes.merge(created_at: Time.now))\n  end\n\n  def find_by_id(type, id)\n    @engine.facts.find { |f| f.type == type &amp;&amp; f[:id] == id }\n  end\n\n  def where(type, &amp;block)\n    @engine.facts.select { |f| f.type == type &amp;&amp; block.call(f) }\n  end\n\n  def remove_where(type, &amp;block)\n    facts = where(type, &amp;block)\n    facts.each { |f| @engine.remove_fact(f) }\n    @engine.run\n  end\nend\n\n# Usage\nrepo = FactRepository.new(engine)\nrepo.add(:sensor, { id: \"bedroom\", temp: 28 })\n\nbedroom = repo.find_by_id(:sensor, \"bedroom\")\nhigh_temps = repo.where(:sensor) { |f| f[:temp] &gt; 30 }\nrepo.remove_where(:alert) { |f| f[:stale] }\n</code></pre>"},{"location":"guides/facts/#next-steps","title":"Next Steps","text":"<ul> <li>Pattern Matching - How facts match conditions</li> <li>Writing Rules - Using facts in rule conditions</li> <li>Blackboard Memory - Persistent fact storage</li> <li>Persistence Guide - SQLite, Redis, and hybrid storage</li> <li>API Reference - Complete Fact API documentation</li> </ul> <p>Facts are immutable knowledge. When facts change, replace them to trigger re-evaluation.</p>"},{"location":"guides/getting-started/","title":"Getting Started","text":"<p>Build your first knowledge-based system in 10 minutes. This hands-on tutorial teaches the fundamentals by creating a temperature monitoring system that alerts when sensors exceed thresholds.</p>"},{"location":"guides/getting-started/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Creating rules and facts</li> <li>Variable binding across conditions</li> <li>Using negation to prevent duplicate alerts</li> <li>Persisting facts with blackboard memory</li> <li>Controlling rule execution with priorities</li> </ul>"},{"location":"guides/getting-started/#installation","title":"Installation","text":"<p>Add KBS to your Gemfile:</p> <pre><code>gem 'kbs'\n</code></pre> <p>Or install directly:</p> <pre><code>gem install kbs\n</code></pre>"},{"location":"guides/getting-started/#your-first-rule","title":"Your First Rule","text":"<p>Let's create a simple rule that fires when temperature exceeds a threshold.</p>"},{"location":"guides/getting-started/#step-1-create-a-knowledge-base","title":"Step 1: Create a Knowledge Base","text":"<pre><code>require 'kbs'\n\n# Create a knowledge base with DSL\nkb = KBS.knowledge_base do\n  # Rules will be defined here\nend\n</code></pre> <p>The knowledge base manages rules, facts, and executes the pattern matching algorithm.</p>"},{"location":"guides/getting-started/#step-2-define-a-rule","title":"Step 2: Define a Rule","text":"<pre><code>kb = KBS.knowledge_base do\n  # Define a rule for high temperature alerts\n  rule \"high_temperature_alert\" do\n    on :sensor, id: :sensor_id?, temp: :temp?\n    on :threshold, id: :sensor_id?, max: :max?\n\n    perform do |facts, bindings|\n      if bindings[:temp?] &gt; bindings[:max?]\n        puts \"\ud83d\udea8 ALERT: Sensor #{bindings[:sensor_id?]} at #{bindings[:temp?]}\u00b0C\"\n      end\n    end\n  end\nend\n</code></pre> <p>What this rule does:</p> <ul> <li>Condition 1: Match any <code>:sensor</code> fact, binding its <code>id</code> to <code>:sensor_id?</code> and <code>temp</code> to <code>:temp?</code></li> <li>Condition 2: Match a <code>:threshold</code> fact with the same <code>id</code>, binding <code>max</code> to <code>:max?</code></li> <li>Action: When both conditions match, compare temperature against threshold</li> </ul> <p>Variable binding (<code>:sensor_id?</code>) ensures we only compare sensors with their own thresholds.</p>"},{"location":"guides/getting-started/#step-3-add-facts-and-run","title":"Step 3: Add Facts and Run","text":"<pre><code>kb = KBS.knowledge_base do\n  rule \"high_temperature_alert\" do\n    on :sensor, id: :sensor_id?, temp: :temp?\n    on :threshold, id: :sensor_id?, max: :max?\n\n    perform do |facts, bindings|\n      if bindings[:temp?] &gt; bindings[:max?]\n        puts \"\ud83d\udea8 ALERT: Sensor #{bindings[:sensor_id?]} at #{bindings[:temp?]}\u00b0C\"\n      end\n    end\n  end\n\n  # Add facts\n  fact :sensor, id: \"bedroom\", temp: 28\n  fact :threshold, id: \"bedroom\", max: 25\n\n  # Run inference\n  run\nend\n</code></pre> <p>Facts are observations about the world. The knowledge base automatically matches them against rule conditions.</p> <p>Output: <pre><code>\ud83d\udea8 ALERT: Sensor bedroom at 28\u00b0C\n</code></pre></p> <p>The rule fired because the bedroom temperature (28\u00b0C) exceeds its threshold (25\u00b0C).</p>"},{"location":"guides/getting-started/#understanding-variable-binding","title":"Understanding Variable Binding","text":"<p>Variable binding connects facts across conditions. Here's how it works:</p> <pre><code>rule \"example\" do\n  on :sensor, id: :sensor_id?, temp: :temp?\n  on :threshold, id: :sensor_id?, max: :max?\nend\n</code></pre> <p>Binding Process:</p> <ol> <li>Engine finds a <code>:sensor</code> fact: <code>{ id: \"bedroom\", temp: 28 }</code></li> <li>Binds <code>:sensor_id?</code> \u2192 <code>\"bedroom\"</code>, <code>:temp?</code> \u2192 <code>28</code></li> <li>Searches for <code>:threshold</code> fact where <code>id</code> also equals <code>\"bedroom\"</code></li> <li>Finds <code>{ id: \"bedroom\", max: 25 }</code></li> <li>Binds <code>:max?</code> \u2192 <code>25</code></li> <li>Both conditions satisfied \u2192 rule fires with bindings: <code>{ :sensor_id? =&gt; \"bedroom\", :temp? =&gt; 28, :max? =&gt; 25 }</code></li> </ol> <p>Without variable binding, the rule would incorrectly match bedroom sensors with kitchen thresholds.</p>"},{"location":"guides/getting-started/#preventing-duplicate-alerts-with-negation","title":"Preventing Duplicate Alerts with Negation","text":"<p>Let's prevent the same alert from firing repeatedly:</p> <pre><code>kb = KBS.knowledge_base do\n  rule \"smart_temperature_alert\" do\n    on :sensor, id: :sensor_id?, temp: :temp?\n    on :threshold, id: :sensor_id?, max: :max?\n    # Only fire if no alert already exists for this sensor\n    without :alert, sensor_id: :sensor_id?\n\n    perform do |facts, bindings|\n      if bindings[:temp?] &gt; bindings[:max?]\n        puts \"\ud83d\udea8 ALERT: Sensor #{bindings[:sensor_id?]} at #{bindings[:temp?]}\u00b0C\"\n        # Record that we sent this alert\n        fact :alert, sensor_id: bindings[:sensor_id?]\n      end\n    end\n  end\nend\n</code></pre> <p>Negated condition (<code>negated: true</code>): Rule fires only when NO <code>:alert</code> fact exists for this sensor.</p> <p>Flow:</p> <ol> <li>First execution: No <code>:alert</code> fact \u2192 rule fires, creates <code>:alert</code> fact</li> <li>Second execution: <code>:alert</code> fact exists \u2192 rule doesn't fire (negation blocks it)</li> </ol>"},{"location":"guides/getting-started/#persisting-facts-with-blackboard-memory","title":"Persisting Facts with Blackboard Memory","text":"<p>So far, facts disappear when your program exits. Use blackboard memory for persistence:</p> <pre><code>require 'kbs'\n\n# Create engine with SQLite persistence\nengine = KBS::Blackboard::Engine.new(db_path: 'sensors.db')\n\n# Add rules (same as before)\nengine.add_rule(smart_alert_rule)\n\n# Add facts - these are saved to database\nengine.add_fact(:sensor, id: \"bedroom\", temp: 28)\nengine.add_fact(:threshold, id: \"bedroom\", max: 25)\n\nengine.run\n\n# Facts survive program restart\nengine.close\n</code></pre> <p>Next time you run:</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'sensors.db')\n# Facts automatically loaded from database\nputs engine.facts.size  # =&gt; 2 (sensor + threshold)\n</code></pre> <p>Blackboard provides: - Persistence: Facts saved to SQLite/Redis - Audit Trail: Complete history of changes - Transactions: ACID guarantees for multi-fact updates</p> <p>Learn more: Blackboard Memory Guide</p>"},{"location":"guides/getting-started/#controlling-execution-with-priorities","title":"Controlling Execution with Priorities","text":"<p>When multiple rules match, control firing order with priorities:</p> <pre><code>kb = KBS.knowledge_base do\n  rule \"critical_alert\", priority: 100 do\n    on :sensor, temp: :temp?\n\n    perform do |facts, bindings|\n      if bindings[:temp?] &gt; 50\n        puts \"\ud83d\udd25 CRITICAL: Immediate shutdown required!\"\n        exit(1)\n      end\n    end\n  end\n\n  rule \"normal_alert\", priority: 10 do\n    on :sensor, temp: :temp?\n    # ... (less urgent alerts)\n    perform { |facts| puts \"Normal alert\" }\n  end\nend\n</code></pre> <p>Priority: Higher numbers fire first. Default is <code>0</code>.</p> <p>Execution order: 1. <code>critical_alert</code> (priority 100) - checks for emergency shutdown 2. <code>normal_alert</code> (priority 10) - handles routine alerts</p>"},{"location":"guides/getting-started/#complete-working-example","title":"Complete Working Example","text":"<p>Here's a complete temperature monitoring system:</p> <pre><code>require 'kbs'\n\nclass TemperatureMonitor\n  def initialize\n    @engine = KBS::Blackboard::Engine.new(db_path: 'sensors.db')\n    @kb = setup_rules\n  end\n\n  def setup_rules\n    engine = @engine\n    monitor = self\n\n    KBS.knowledge_base(engine: engine) do\n      # Rule 1: Send alert when temp exceeds threshold\n      rule \"temperature_alert\", priority: 50 do\n        on :sensor, id: :id?, temp: :temp?\n        on :threshold, id: :id?, max: :max?\n        without :alert, sensor_id: :id?\n\n        perform do |facts, bindings|\n          if bindings[:temp?] &gt; bindings[:max?]\n            monitor.send_alert(bindings[:id?], bindings[:temp?], bindings[:max?])\n            fact :alert, sensor_id: bindings[:id?]\n          end\n        end\n      end\n\n      # Rule 2: Clear alert when temp drops below threshold\n      rule \"clear_alert\", priority: 40 do\n        on :sensor, id: :id?, temp: :temp?\n        on :threshold, id: :id?, max: :max?\n        on :alert, sensor_id: :id?\n\n        perform do |facts, bindings|\n          if bindings[:temp?] &lt;= bindings[:max?]\n            monitor.clear_alert(bindings[:id?])\n            # Find and retract the alert fact\n            alert_fact = query(:alert, sensor_id: bindings[:id?]).first\n            retract alert_fact if alert_fact\n          end\n        end\n      end\n\n      # Rule 3: Emergency shutdown for extreme temps\n      rule \"emergency_shutdown\", priority: 100 do\n        on :sensor, temp: :temp?\n\n        perform do |facts, bindings|\n          if bindings[:temp?] &gt; 60\n            monitor.emergency_shutdown(bindings[:temp?])\n          end\n        end\n      end\n    end\n  end\n\n  def add_sensor(id, max_temp)\n    @kb.fact :threshold, id: id, max: max_temp\n  end\n\n  def update_reading(id, temp)\n    # Find and remove old reading\n    old = @kb.query(:sensor, id: id).first\n    @kb.retract old if old\n\n    # Add new reading\n    @kb.fact :sensor, id: id, temp: temp\n    @kb.run\n  end\n\n  def send_alert(sensor_id, temp, threshold)\n    puts \"\ud83d\udea8 ALERT: #{sensor_id} at #{temp}\u00b0C (threshold: #{threshold}\u00b0C)\"\n  end\n\n  def clear_alert(sensor_id)\n    puts \"\u2705 CLEAR: #{sensor_id} back to normal\"\n  end\n\n  def emergency_shutdown(temp)\n    puts \"\ud83d\udd25 EMERGENCY SHUTDOWN: Temperature #{temp}\u00b0C!\"\n    exit(1)\n  end\n\n  def close\n    @engine.close\n  end\nend\n\n# Usage\nmonitor = TemperatureMonitor.new\n\n# Register sensors with thresholds\nmonitor.add_sensor(\"bedroom\", 25)\nmonitor.add_sensor(\"server_room\", 30)\n\n# Simulate sensor readings\nmonitor.update_reading(\"bedroom\", 28)        # =&gt; \ud83d\udea8 ALERT\nmonitor.update_reading(\"server_room\", 45)    # =&gt; \ud83d\udea8 ALERT\nmonitor.update_reading(\"bedroom\", 22)        # =&gt; \u2705 CLEAR\nmonitor.update_reading(\"server_room\", 65)    # =&gt; \ud83d\udd25 EMERGENCY SHUTDOWN\n\nmonitor.close\n</code></pre>"},{"location":"guides/getting-started/#key-concepts-learned","title":"Key Concepts Learned","text":"<p>\u2705 Rules - Define patterns and actions \u2705 Facts - Observations stored in working memory \u2705 Conditions - Patterns that match facts \u2705 Variable Binding - Connect facts across conditions using <code>:variable?</code> \u2705 Negation - Match when patterns are absent \u2705 Priorities - Control rule firing order \u2705 Persistence - Save facts to database with blackboard memory</p>"},{"location":"guides/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/getting-started/#rule-not-firing","title":"Rule Not Firing","text":"<p>Problem: Added facts but rule doesn't fire</p> <p>Checklist: 1. Did you call <code>engine.run</code>? 2. Do variable bindings match? (<code>:sensor_id?</code> must appear in both conditions) 3. Check negated conditions - is there a blocking fact? 4. Verify fact types match condition types exactly (<code>:sensor</code> vs <code>:sensors</code>)</p>"},{"location":"guides/getting-started/#performance-issues","title":"Performance Issues","text":"<p>Problem: Slow when adding many facts</p> <p>Solutions: - Order conditions from most selective to least selective - Use Redis store for high-frequency updates: <code>KBS::Blackboard::Engine.new(store: KBS::Blackboard::Persistence::RedisStore.new)</code> - Minimize negated conditions</p>"},{"location":"guides/getting-started/#facts-not-persisting","title":"Facts Not Persisting","text":"<p>Problem: Facts disappear after restart</p> <p>Check: - Using <code>KBS::Blackboard::Engine</code> (not <code>KBS::Engine</code>)? - Provided <code>db_path</code> parameter? - Called <code>engine.close</code> before exit?</p>"},{"location":"guides/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore:</p> <ul> <li>Writing Rules - Advanced rule patterns and techniques</li> <li>Pattern Matching - Deep dive into condition syntax</li> <li>Blackboard Memory - Multi-agent collaboration</li> <li>Stock Trading Examples - Real-world applications</li> <li>API Reference - Complete method documentation</li> </ul> <p>Questions? Open an issue at github.com/madbomber/kbs</p>"},{"location":"guides/negation/","title":"Negation","text":"<p>Negated conditions match when a pattern is absent from working memory. This guide explains negation semantics, use cases, performance implications, and common pitfalls.</p>"},{"location":"guides/negation/#negation-basics","title":"Negation Basics","text":""},{"location":"guides/negation/#syntax","title":"Syntax","text":"<pre><code>KBS::Condition.new(:alert, { sensor_id: :id? }, negated: true)\n</code></pre> <p>Semantics: Condition satisfied when NO fact matches the pattern.</p>"},{"location":"guides/negation/#simple-example","title":"Simple Example","text":"<pre><code>KBS::Rule.new(\"send_first_alert\") do |r|\n  r.conditions = [\n    # Positive: High temperature detected\n    KBS::Condition.new(:high_temp, { sensor_id: :id? }),\n\n    # Negative: No alert sent yet\n    KBS::Condition.new(:alert_sent, { sensor_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    send_alert(bindings[:id?])\n    engine.add_fact(:alert_sent, { sensor_id: bindings[:id?] })\n  end\nend\n</code></pre> <p>Behavior: - First run: <code>:high_temp</code> exists, <code>:alert_sent</code> doesn't \u2192 rule fires - Second run: Both <code>:high_temp</code> and <code>:alert_sent</code> exist \u2192 rule doesn't fire</p>"},{"location":"guides/negation/#negation-semantics","title":"Negation Semantics","text":""},{"location":"guides/negation/#open-world-assumption","title":"Open World Assumption","text":"<p>Negation means \"no matching fact exists\", not \"fact is explicitly false\":</p> <pre><code># Negated condition\nKBS::Condition.new(:error, { id: :id? }, negated: true)\n\n# Matches when:\n# - No :error fact exists with that id\n# - Working memory is empty\n# - :error facts exist but with different ids\n\n# Does NOT match when:\n# - Any :error fact with matching id exists\n</code></pre>"},{"location":"guides/negation/#variable-binding-in-negation","title":"Variable Binding in Negation","text":"<p>Variables in negated conditions still create join constraints:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n  KBS::Condition.new(:alert, { sensor_id: :id? }, negated: true)\n]\n\n# For each sensor fact:\n#   Check if NO alert exists with sensor_id == sensor's id\n#   If no such alert: rule fires\n</code></pre>"},{"location":"guides/negation/#negation-node-behavior","title":"Negation Node Behavior","text":"<pre><code>1. Token arrives with bindings { :id? =&gt; \"bedroom\" }\n2. Check alpha memory for :alert facts\n3. Filter for matches where sensor_id == \"bedroom\"\n4. If count == 0: propagate token (condition satisfied)\n5. If count &gt; 0: block token (condition not satisfied)\n</code></pre>"},{"location":"guides/negation/#use-cases","title":"Use Cases","text":""},{"location":"guides/negation/#1-guard-conditions","title":"1. Guard Conditions","text":"<p>Prevent duplicate actions:</p> <pre><code>KBS::Rule.new(\"process_order\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:order, { id: :id?, status: \"pending\" }),\n    KBS::Condition.new(:processing, { order_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Only process if not already processing\n    engine.add_fact(:processing, { order_id: bindings[:id?] })\n    process_order(bindings[:id?])\n  end\nend\n</code></pre>"},{"location":"guides/negation/#2-missing-information-detection","title":"2. Missing Information Detection","text":"<p>Alert when expected data is absent:</p> <pre><code>KBS::Rule.new(\"missing_threshold\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { id: :id? }),\n    KBS::Condition.new(:threshold, { sensor_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    alert(\"Sensor #{bindings[:id?]} has no threshold configured!\")\n  end\nend\n</code></pre>"},{"location":"guides/negation/#3-state-transitions","title":"3. State Transitions","text":"<p>Ensure prerequisites before transitioning:</p> <pre><code>KBS::Rule.new(\"activate_account\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:user, { id: :id?, email_verified: true }),\n    KBS::Condition.new(:account_active, { user_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.add_fact(:account_active, { user_id: bindings[:id?] })\n  end\nend\n</code></pre>"},{"location":"guides/negation/#4-timeout-detection","title":"4. Timeout Detection","text":"<p>Fire when response hasn't arrived:</p> <pre><code>KBS::Rule.new(\"timeout_alert\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:request, {\n      id: :req_id?,\n      created_at: :created?\n    }, predicate: lambda { |f|\n      (Time.now - f[:created_at]) &gt; 300  # 5 minutes\n    }),\n\n    KBS::Condition.new(:response, { request_id: :req_id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    alert(\"Request #{bindings[:req_id?]} timed out!\")\n  end\nend\n</code></pre>"},{"location":"guides/negation/#5-mutual-exclusion","title":"5. Mutual Exclusion","text":"<p>Ensure only one option selected:</p> <pre><code>KBS::Rule.new(\"select_default\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:user, { id: :id? }),\n    KBS::Condition.new(:preference, { user_id: :id?, theme: :theme? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # No preference set \u2192 use default\n    engine.add_fact(:preference, { user_id: bindings[:id?], theme: \"light\" })\n  end\nend\n</code></pre>"},{"location":"guides/negation/#multiple-negations","title":"Multiple Negations","text":""},{"location":"guides/negation/#conjunction-and","title":"Conjunction (AND)","text":"<p>All negations must be satisfied:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {}, negated: true),\n  KBS::Condition.new(:c, {}, negated: true)\n]\n\n# Fires when: a exists AND b doesn't exist AND c doesn't exist\n</code></pre>"},{"location":"guides/negation/#complex-negation","title":"Complex Negation","text":"<pre><code>KBS::Rule.new(\"unique_error\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:error, { type: :type? }),\n    KBS::Condition.new(:error_handled, { type: :type? }, negated: true),\n    KBS::Condition.new(:error_ignored, { type: :type? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Error exists but neither handled nor ignored\n    handle_new_error(bindings[:type?])\n  end\nend\n</code></pre>"},{"location":"guides/negation/#performance-implications","title":"Performance Implications","text":""},{"location":"guides/negation/#negation-is-expensive","title":"Negation is Expensive","text":"<p>Reason: Must check alpha memory on every token arrival.</p> <pre><code># Expensive: Large alpha memory to search\nKBS::Condition.new(:log_entry, {}, negated: true)\n# Must check all log_entry facts for each token\n\n# Better: Specific pattern\nKBS::Condition.new(:error_log, { severity: \"critical\" }, negated: true)\n# Smaller alpha memory, fewer checks\n</code></pre>"},{"location":"guides/negation/#negation-node-overhead","title":"Negation Node Overhead","text":"<pre><code>class NegationNode\n  def left_activate(token)\n    # For EVERY token:\n    matching_facts = @alpha_memory.items.select { |fact|\n      perform_join_tests(token, fact)\n    }\n\n    if matching_facts.empty?\n      propagate(token)  # No matches = condition satisfied\n    else\n      block(token)      # Matches exist = condition not satisfied\n      track_inhibitors(token, matching_facts)\n    end\n  end\nend\n</code></pre> <p>Cost: O(A \u00d7 T) where A = alpha memory size, T = join test cost</p>"},{"location":"guides/negation/#optimization-strategies","title":"Optimization Strategies","text":"<p>1. Order negations last:</p> <pre><code># Good: Positive conditions first\nr.conditions = [\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {}),\n  KBS::Condition.new(:c, {}, negated: true)  # Last\n]\n\n# Bad: Negation first\nr.conditions = [\n  KBS::Condition.new(:c, {}, negated: true),  # First\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {})\n]\n</code></pre> <p>2. Minimize negations:</p> <pre><code># Bad: Multiple negations\nr.conditions = [\n  KBS::Condition.new(:foo, {}, negated: true),\n  KBS::Condition.new(:bar, {}, negated: true),\n  KBS::Condition.new(:baz, {}, negated: true)\n]\n\n# Better: Single positive condition\n# Add fact when conditions met:\nunless foo_exists? || bar_exists? || baz_exists?\n  engine.add_fact(:conditions_clear, {})\nend\n\nr.conditions = [\n  KBS::Condition.new(:conditions_clear, {})\n]\n</code></pre> <p>3. Use specific patterns:</p> <pre><code># Expensive\nKBS::Condition.new(:event, {}, negated: true)\n\n# Cheaper\nKBS::Condition.new(:event, { type: \"error\", severity: \"critical\" }, negated: true)\n</code></pre>"},{"location":"guides/negation/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guides/negation/#1-forgetting-variable-binding","title":"1. Forgetting Variable Binding","text":"<pre><code># Bad: Variables don't connect\nr.conditions = [\n  KBS::Condition.new(:sensor, { id: :id1? }),\n  KBS::Condition.new(:alert, { id: :id2? }, negated: true)  # Different variable!\n]\n\n# Good: Consistent variables\nr.conditions = [\n  KBS::Condition.new(:sensor, { id: :id? }),\n  KBS::Condition.new(:alert, { sensor_id: :id? }, negated: true)  # Same :id?\n]\n</code></pre>"},{"location":"guides/negation/#2-infinite-loops","title":"2. Infinite Loops","text":"<pre><code># Bad: Rule fires forever\nKBS::Rule.new(\"infinite_loop\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:start, {}),\n    KBS::Condition.new(:done, {}, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Never adds :done fact!\n    do_something()\n  end\nend\n\n# Good: Add termination fact\nKBS::Rule.new(\"runs_once\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:start, {}),\n    KBS::Condition.new(:done, {}, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    do_something()\n    engine.add_fact(:done, {})  # Prevents re-firing\n  end\nend\n</code></pre>"},{"location":"guides/negation/#3-negation-of-missing-attributes","title":"3. Negation of Missing Attributes","text":"<pre><code># Doesn't work as expected\nKBS::Condition.new(:sensor, { error: nil }, negated: true)\n\n# Better: Check for absence of error fact\nKBS::Condition.new(:sensor, { id: :id? }),\nKBS::Condition.new(:sensor_error, { sensor_id: :id? }, negated: true)\n</code></pre>"},{"location":"guides/negation/#4-over-using-negation","title":"4. Over-Using Negation","text":"<pre><code># Bad: Many negations\nKBS::Rule.new(\"many_negations\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:a, {}, negated: true),\n    KBS::Condition.new(:b, {}, negated: true),\n    KBS::Condition.new(:c, {}, negated: true),\n    KBS::Condition.new(:d, {}, negated: true)\n  ]\n  # Expensive! Checks 4 alpha memories per token\nend\n\n# Good: Refactor to positive logic\n# Add a single fact representing \"all clear\" state\n</code></pre>"},{"location":"guides/negation/#negation-patterns","title":"Negation Patterns","text":""},{"location":"guides/negation/#default-values","title":"Default Values","text":"<pre><code># If no preference, use default\nKBS::Rule.new(\"set_default_theme\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:user, { id: :id? }),\n    KBS::Condition.new(:theme_preference, { user_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.add_fact(:theme_preference, { user_id: bindings[:id?], theme: \"dark\" })\n  end\nend\n</code></pre>"},{"location":"guides/negation/#cleanup-rules","title":"Cleanup Rules","text":"<pre><code># Remove orphaned records\nKBS::Rule.new(\"cleanup_orphaned_comments\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:comment, { post_id: :pid? }),\n    KBS::Condition.new(:post, { id: :pid? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    comment = facts[0]\n    engine.remove_fact(comment)\n  end\nend\n</code></pre>"},{"location":"guides/negation/#prerequisite-checking","title":"Prerequisite Checking","text":"<pre><code># Ensure all prerequisites met\nKBS::Rule.new(\"deploy_application\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:deploy_requested, {}),\n    KBS::Condition.new(:tests_passed, {}),\n    KBS::Condition.new(:build_succeeded, {}),\n    KBS::Condition.new(:deployment_blocked, {}, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    deploy()\n  end\nend\n</code></pre>"},{"location":"guides/negation/#debugging-negations","title":"Debugging Negations","text":""},{"location":"guides/negation/#trace-negation-checks","title":"Trace Negation Checks","text":"<pre><code>class DebugNegationNode &lt; KBS::NegationNode\n  def left_activate(token)\n    matches = @alpha_memory.items.select { |f| perform_join_tests(token, f) }\n    puts \"Negation check:\"\n    puts \"  Pattern: #{@alpha_memory.pattern}\"\n    puts \"  Token: #{token.inspect}\"\n    puts \"  Matching facts: #{matches.size}\"\n    puts \"  Result: #{matches.empty? ? 'PASS' : 'BLOCK'}\"\n    super\n  end\nend\n</code></pre>"},{"location":"guides/negation/#count-inhibitors","title":"Count Inhibitors","text":"<pre><code># Check how many facts are blocking tokens\nengine.production_nodes.each do |name, node|\n  # Find negation nodes in network\n  # Count tokens blocked by each\nend\n</code></pre>"},{"location":"guides/negation/#validate-negation-logic","title":"Validate Negation Logic","text":"<pre><code># Test: Rule should fire when condition absent\nengine.add_fact(:trigger, {})\nengine.run\nassert rule_fired, \"Should fire when negated condition absent\"\n\n# Test: Rule should NOT fire when condition present\nengine.add_fact(:blocker, {})\nengine.run\nrefute rule_fired, \"Should not fire when negated condition present\"\n</code></pre>"},{"location":"guides/negation/#alternatives-to-negation","title":"Alternatives to Negation","text":"<p>Sometimes positive logic is clearer and faster:</p>"},{"location":"guides/negation/#pattern-explicit-state","title":"Pattern: Explicit State","text":"<pre><code># Instead of:\nKBS::Condition.new(:processing, { id: :id? }, negated: true)\n\n# Use explicit state:\nKBS::Condition.new(:status, { id: :id?, value: \"idle\" })\n</code></pre>"},{"location":"guides/negation/#pattern-status-flags","title":"Pattern: Status Flags","text":"<pre><code># Instead of:\nKBS::Condition.new(:error, {}, negated: true)\n\n# Use status flag:\nKBS::Condition.new(:system_status, { healthy: true })\n</code></pre>"},{"location":"guides/negation/#pattern-computed-facts","title":"Pattern: Computed Facts","text":"<pre><code># Instead of checking absence in rule:\nKBS::Condition.new(:response, { req_id: :id? }, negated: true)\n\n# Add a fact when timeout occurs:\nKBS::Rule.new(\"detect_timeout\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:request, {\n      id: :id?,\n      created_at: :time?\n    }, predicate: lambda { |f| (Time.now - f[:created_at]) &gt; 300 })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.add_fact(:timeout, { request_id: bindings[:id?] })\n  end\nend\n\n# Then use positive check:\nKBS::Condition.new(:timeout, { request_id: :id? })\n</code></pre>"},{"location":"guides/negation/#next-steps","title":"Next Steps","text":"<ul> <li>Pattern Matching - How negation fits with pattern matching</li> <li>Variable Binding - Variables in negated conditions</li> <li>Network Structure - Negation node implementation</li> <li>Performance Guide - Optimizing negation performance</li> </ul> <p>Negation is powerful but expensive. Use sparingly and order last for best performance.</p>"},{"location":"guides/pattern-matching/","title":"Pattern Matching","text":"<p>Deep dive into KBS pattern matching semantics. Learn how the RETE algorithm matches facts against condition patterns efficiently.</p>"},{"location":"guides/pattern-matching/#matching-fundamentals","title":"Matching Fundamentals","text":"<p>Pattern matching determines whether a fact satisfies a condition. A match occurs when:</p> <ol> <li>Type matches - Fact type equals condition type</li> <li>Attributes match - All pattern constraints satisfied</li> <li>Predicate passes - Custom predicate (if present) returns truthy</li> </ol> <pre><code># Condition pattern\nKBS::Condition.new(:sensor, {\n  id: \"bedroom\",\n  temp: :temp?\n})\n\n# Matching fact\nfact = { type: :sensor, id: \"bedroom\", temp: 28 }\n# \u2713 Type: :sensor == :sensor\n# \u2713 Attribute id: \"bedroom\" == \"bedroom\"\n# \u2713 Attribute temp: :temp? binds to 28\n# MATCH!\n\n# Non-matching fact\nfact = { type: :sensor, id: \"kitchen\", temp: 28 }\n# \u2713 Type: :sensor == :sensor\n# \u2717 Attribute id: \"kitchen\" != \"bedroom\"\n# NO MATCH\n</code></pre>"},{"location":"guides/pattern-matching/#type-matching","title":"Type Matching","text":"<p>Facts match only when types are identical:</p> <pre><code># Condition\nKBS::Condition.new(:stock, {})\n\n# Matches\nengine.add_fact(:stock, { symbol: \"AAPL\" })  # \u2713\n\n# Does not match\nengine.add_fact(:stocks, { symbol: \"AAPL\" })  # \u2717 (:stocks != :stock)\nengine.add_fact(\"stock\", { symbol: \"AAPL\" })  # \u2717 (String != Symbol)\n</code></pre> <p>Type comparison uses <code>==</code>, so symbols and strings never match.</p>"},{"location":"guides/pattern-matching/#literal-value-matching","title":"Literal Value Matching","text":""},{"location":"guides/pattern-matching/#exact-equality","title":"Exact Equality","text":"<pre><code># Match exact value\nKBS::Condition.new(:sensor, { id: \"bedroom\" })\n\n# Matches\n{ type: :sensor, id: \"bedroom\" }  # \u2713\n\n# Does not match\n{ type: :sensor, id: \"kitchen\" }   # \u2717\n{ type: :sensor, id: :bedroom }     # \u2717 (Symbol != String)\n</code></pre>"},{"location":"guides/pattern-matching/#multiple-literals","title":"Multiple Literals","text":"<pre><code># All must match\nKBS::Condition.new(:stock, {\n  symbol: \"AAPL\",\n  exchange: \"NASDAQ\"\n})\n\n# Matches\n{ type: :stock, symbol: \"AAPL\", exchange: \"NASDAQ\" }  # \u2713\n\n# Does not match\n{ type: :stock, symbol: \"AAPL\", exchange: \"NYSE\" }    # \u2717\n{ type: :stock, symbol: \"GOOGL\", exchange: \"NASDAQ\" } # \u2717\n</code></pre>"},{"location":"guides/pattern-matching/#nil-values","title":"Nil Values","text":"<pre><code># Match nil explicitly\nKBS::Condition.new(:sensor, { error: nil })\n\n# Matches\n{ type: :sensor, error: nil }  # \u2713\n\n# Does not match\n{ type: :sensor }  # \u2717 (missing key != nil)\n{ type: :sensor, error: false }  # \u2717 (false != nil)\n</code></pre>"},{"location":"guides/pattern-matching/#variable-binding","title":"Variable Binding","text":""},{"location":"guides/pattern-matching/#basic-binding","title":"Basic Binding","text":"<p>Variables start with <code>?</code> and bind to fact attribute values:</p> <pre><code># Condition with variable\nKBS::Condition.new(:sensor, { temp: :t? })\n\n# Matching fact\nfact = { type: :sensor, temp: 28 }\n\n# After matching:\nbindings = { :t? =&gt; 28 }\n</code></pre>"},{"location":"guides/pattern-matching/#multiple-bindings","title":"Multiple Bindings","text":"<pre><code>KBS::Condition.new(:stock, {\n  symbol: :sym?,\n  price: :p?,\n  volume: :v?\n})\n\n# Fact\n{ type: :stock, symbol: \"AAPL\", price: 150, volume: 1000 }\n\n# Bindings\n{\n  :sym? =&gt; \"AAPL\",\n  :p? =&gt; 150,\n  :v? =&gt; 1000\n}\n</code></pre>"},{"location":"guides/pattern-matching/#mixed-literals-and-variables","title":"Mixed Literals and Variables","text":"<pre><code>KBS::Condition.new(:sensor, {\n  id: \"bedroom\",     # Literal (must equal \"bedroom\")\n  temp: :temp?       # Variable (binds to any value)\n})\n\n# Matches only bedroom sensor, binds temp\n{ type: :sensor, id: \"bedroom\", temp: 28 }  # \u2713 binds :temp? =&gt; 28\n{ type: :sensor, id: \"kitchen\", temp: 28 }  # \u2717 id doesn't match\n</code></pre>"},{"location":"guides/pattern-matching/#cross-condition-binding","title":"Cross-Condition Binding","text":"<p>Variables create join constraints across conditions:</p> <pre><code>r.conditions = [\n  # Condition 1: Binds :sym?\n  KBS::Condition.new(:stock, { symbol: :sym?, price: :price? }),\n\n  # Condition 2: Tests :sym? (must be same value)\n  KBS::Condition.new(:watchlist, { symbol: :sym? })\n]\n\n# Facts\nstock1 = { type: :stock, symbol: \"AAPL\", price: 150 }\nstock2 = { type: :stock, symbol: \"GOOGL\", price: 2800 }\nwatchlist = { type: :watchlist, symbol: \"AAPL\" }\n\n# Matches\n# stock1 + watchlist: \u2713 (:sym? = \"AAPL\" in both)\n\n# Does not match\n# stock2 + watchlist: \u2717 (:sym? = \"GOOGL\" in stock, \"AAPL\" in watchlist)\n</code></pre>"},{"location":"guides/pattern-matching/#binding-semantics","title":"Binding Semantics","text":"<ol> <li>First occurrence binds - Variable's first use establishes the value</li> <li>Subsequent uses test - Later uses check equality</li> <li>Scope is per-rule - Variables don't cross rules</li> </ol> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, { x: :v? }),  # Binds :v?\n  KBS::Condition.new(:b, { y: :v? }),  # Tests :v? (must equal)\n  KBS::Condition.new(:c, { z: :v? })   # Tests :v? (must equal)\n]\n\n# All three facts must have same value for x, y, z\n</code></pre>"},{"location":"guides/pattern-matching/#empty-patterns","title":"Empty Patterns","text":""},{"location":"guides/pattern-matching/#match-any","title":"Match Any","text":"<p>Empty pattern <code>{}</code> matches all facts of that type:</p> <pre><code># Matches ALL sensor facts\nKBS::Condition.new(:sensor, {})\n\n# Matches these\n{ type: :sensor, id: \"bedroom\", temp: 28 }\n{ type: :sensor, id: \"kitchen\", temp: 22 }\n{ type: :sensor, foo: \"bar\", baz: 123 }\n</code></pre>"},{"location":"guides/pattern-matching/#selectivity-warning","title":"Selectivity Warning","text":"<p>Empty patterns have minimal selectivity:</p> <pre><code># Bad: Very unselective (matches thousands)\nr.conditions = [\n  KBS::Condition.new(:log_entry, {}),     # Matches 10,000 facts\n  KBS::Condition.new(:error, { id: 1 })   # Matches 1 fact\n]\n# Creates 10,000 partial matches!\n\n# Good: Specific first\nr.conditions = [\n  KBS::Condition.new(:error, { id: 1 }),    # Matches 1 fact\n  KBS::Condition.new(:log_entry, {})        # Joins with 10,000\n]\n# Creates 1 partial match\n</code></pre>"},{"location":"guides/pattern-matching/#custom-predicates","title":"Custom Predicates","text":"<p>Predicates add complex matching beyond equality:</p>"},{"location":"guides/pattern-matching/#basic-predicate","title":"Basic Predicate","text":"<pre><code>KBS::Condition.new(:stock, { price: :price? },\n  predicate: lambda { |fact|\n    fact[:price] &gt; 100\n  }\n)\n\n# Matches\n{ type: :stock, price: 150 }  # \u2713 (150 &gt; 100)\n\n# Does not match\n{ type: :stock, price: 50 }   # \u2717 (50 &lt;= 100)\n</code></pre>"},{"location":"guides/pattern-matching/#predicate-execution-order","title":"Predicate Execution Order","text":"<ol> <li>Type check</li> <li>Attribute equality checks</li> <li>Variable binding</li> <li>Predicate evaluation (last)</li> </ol> <pre><code>KBS::Condition.new(:sensor, { id: \"bedroom\", temp: :temp? },\n  predicate: lambda { |fact|\n    fact[:temp].between?(20, 30)\n  }\n)\n\n# Evaluation order:\n# 1. type == :sensor? \u2713\n# 2. id == \"bedroom\"? \u2713\n# 3. temp exists? \u2713 \u2192 bind :temp?\n# 4. predicate(fact)? \u2713\n# MATCH!\n</code></pre>"},{"location":"guides/pattern-matching/#predicate-limitations","title":"Predicate Limitations","text":"<p>Predicates disable network sharing:</p> <pre><code># Rule 1\nKBS::Condition.new(:stock, {},\n  predicate: lambda { |f| f[:price] &gt; 100 }\n)\n\n# Rule 2 (different predicate)\nKBS::Condition.new(:stock, {},\n  predicate: lambda { |f| f[:price] &lt; 50 }\n)\n\n# These create SEPARATE alpha memories\n# Cannot share pattern matching computation\n</code></pre> <p>Use pattern matching when possible:</p> <pre><code># Bad: Predicate for simple equality\nKBS::Condition.new(:stock, {},\n  predicate: lambda { |f| f[:symbol] == \"AAPL\" }\n)\n\n# Good: Pattern matching\nKBS::Condition.new(:stock, { symbol: \"AAPL\" })\n</code></pre>"},{"location":"guides/pattern-matching/#matching-strategies","title":"Matching Strategies","text":""},{"location":"guides/pattern-matching/#conjunctive-matching-and","title":"Conjunctive Matching (AND)","text":"<p>All conditions must match:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {}),\n  KBS::Condition.new(:c, {})\n]\n\n# Rule fires when:\n# a_fact exists AND b_fact exists AND c_fact exists\n</code></pre>"},{"location":"guides/pattern-matching/#disjunctive-matching-or","title":"Disjunctive Matching (OR)","text":"<p>Use multiple rules:</p> <pre><code># Fire when A OR B\nrule1 = KBS::Rule.new(\"fire_on_a\") do |r|\n  r.conditions = [KBS::Condition.new(:a, {})]\n  r.action = lambda { |f, b| common_action }\nend\n\nrule2 = KBS::Rule.new(\"fire_on_b\") do |r|\n  r.conditions = [KBS::Condition.new(:b, {})]\n  r.action = lambda { |f, b| common_action }\nend\n</code></pre> <p>Or use predicates:</p> <pre><code>KBS::Condition.new(:event, {},\n  predicate: lambda { |f|\n    f[:type] == \"a\" || f[:type] == \"b\"\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#negation-not","title":"Negation (NOT)","text":"<p>Match when pattern is absent:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {}, negated: true)  # NOT B\n]\n\n# Fires when: a_fact exists AND no b_fact exists\n</code></pre> <p>See Negation Guide for details.</p>"},{"location":"guides/pattern-matching/#pattern-matching-examples","title":"Pattern Matching Examples","text":""},{"location":"guides/pattern-matching/#range-checks","title":"Range Checks","text":"<pre><code># Temperature in range 20-30\nKBS::Condition.new(:sensor, { temp: :temp? },\n  predicate: lambda { |f|\n    f[:temp].between?(20, 30)\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#string-matching","title":"String Matching","text":"<pre><code># Symbol starts with \"TECH\"\nKBS::Condition.new(:stock, { symbol: :sym? },\n  predicate: lambda { |f|\n    f[:symbol].start_with?(\"TECH\")\n  }\n)\n\n# Regex match\nKBS::Condition.new(:log, { message: :msg? },\n  predicate: lambda { |f|\n    f[:message] =~ /ERROR|FATAL/\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#collection-membership","title":"Collection Membership","text":"<pre><code># Status is one of pending, processing, approved\nKBS::Condition.new(:order, { status: :status? },\n  predicate: lambda { |f|\n    %w[pending processing approved].include?(f[:status])\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#temporal-conditions","title":"Temporal Conditions","text":"<pre><code># Reading older than 5 minutes\nKBS::Condition.new(:sensor, { timestamp: :time? },\n  predicate: lambda { |f|\n    (Time.now - f[:timestamp]) &gt; 300\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#computed-values","title":"Computed Values","text":"<pre><code># Price changed more than 10%\nKBS::Condition.new(:stock, {\n  symbol: :sym?,\n  current_price: :curr?,\n  previous_price: :prev?\n}, predicate: lambda { |f|\n  change = ((f[:current_price] - f[:previous_price]).abs / f[:previous_price].to_f)\n  change &gt; 0.10\n})\n</code></pre>"},{"location":"guides/pattern-matching/#nested-attribute-access","title":"Nested Attribute Access","text":"<pre><code># Access nested hash\nKBS::Condition.new(:event, { data: :data? },\n  predicate: lambda { |f|\n    f[:data].is_a?(Hash) &amp;&amp;\n    f[:data][:severity] == \"critical\"\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#performance-implications","title":"Performance Implications","text":""},{"location":"guides/pattern-matching/#alpha-network","title":"Alpha Network","text":"<p>Facts are tested against patterns in alpha memory:</p> <pre><code># Pattern\n{ type: :stock, symbol: \"AAPL\" }\n\n# 10,000 facts tested\n# Only matching facts stored in alpha memory\n# O(N) where N = total facts\n</code></pre>"},{"location":"guides/pattern-matching/#join-network","title":"Join Network","text":"<p>Partial matches combine in beta network:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, {}),  # 100 matches\n  KBS::Condition.new(:b, {})   # 200 matches\n]\n\n# Worst case: 100 \u00d7 200 = 20,000 join tests\n# Actual: Usually much fewer (variable bindings reduce combinations)\n</code></pre>"},{"location":"guides/pattern-matching/#optimization-strategies","title":"Optimization Strategies","text":"<p>1. Specific patterns first:</p> <pre><code># Good\nr.conditions = [\n  KBS::Condition.new(:critical, {}),  # 1 match\n  KBS::Condition.new(:sensor, {})     # 1000 matches\n]\n# Beta memory size: 1\n\n# Bad\nr.conditions = [\n  KBS::Condition.new(:sensor, {}),     # 1000 matches\n  KBS::Condition.new(:critical, {})    # 1 match\n]\n# Beta memory size: 1000\n</code></pre> <p>2. Use literals over predicates:</p> <pre><code># Good: O(1) hash lookup\nKBS::Condition.new(:stock, { exchange: \"NASDAQ\" })\n\n# Bad: O(N) linear scan\nKBS::Condition.new(:stock, {},\n  predicate: lambda { |f| f[:exchange] == \"NASDAQ\" }\n)\n</code></pre> <p>3. Minimize empty patterns:</p> <pre><code># Expensive\nKBS::Condition.new(:log_entry, {})  # Matches everything\n\n# Better\nKBS::Condition.new(:log_entry, { level: \"ERROR\" })  # More selective\n</code></pre>"},{"location":"guides/pattern-matching/#debugging-patterns","title":"Debugging Patterns","text":""},{"location":"guides/pattern-matching/#trace-matching","title":"Trace Matching","text":"<pre><code>class DebugCondition &lt; KBS::Condition\n  def matches?(fact)\n    result = super\n    puts \"#{pattern} vs #{fact.attributes}: #{result}\"\n    result\n  end\nend\n\n# Use for debugging\nr.conditions = [\n  DebugCondition.new(:sensor, { id: \"bedroom\" })\n]\n</code></pre>"},{"location":"guides/pattern-matching/#inspect-alpha-memories","title":"Inspect Alpha Memories","text":"<pre><code>engine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern: #{pattern}\"\n  puts \"  Matches: #{memory.items.size}\"\n  memory.items.each do |fact|\n    puts \"    #{fact.attributes}\"\n  end\nend\n</code></pre>"},{"location":"guides/pattern-matching/#test-patterns-in-isolation","title":"Test Patterns in Isolation","text":"<pre><code>condition = KBS::Condition.new(:sensor, { temp: :t? },\n  predicate: lambda { |f| f[:temp] &gt; 30 }\n)\n\nfact = KBS::Fact.new(:sensor, { temp: 35 })\n\n# Manually test\ncondition.matches?(fact)  # =&gt; true\n</code></pre>"},{"location":"guides/pattern-matching/#next-steps","title":"Next Steps","text":"<ul> <li>Variable Binding - Join tests and binding extraction</li> <li>Negation - Negated condition behavior</li> <li>RETE Algorithm - How matching works internally</li> <li>Performance Guide - Optimization techniques</li> </ul> <p>Pattern matching is the heart of the RETE algorithm. Efficient patterns = fast rule systems.</p>"},{"location":"guides/persistence/","title":"Persistence Options","text":"<p>KBS offers multiple storage backends for persistent facts. This guide helps you choose and configure the right storage for your use case.</p>"},{"location":"guides/persistence/#storage-backends","title":"Storage Backends","text":""},{"location":"guides/persistence/#1-no-persistence-default","title":"1. No Persistence (Default)","text":"<p>Transient in-memory facts using <code>KBS::Engine</code>:</p> <pre><code>engine = KBS::Engine.new\n\n# Facts exist only in memory\nengine.add_fact(:sensor, { temp: 28 })\n\n# Lost on exit\n</code></pre> <p>When to use: - Prototyping - Short-lived processes - Pure computation (no state retention needed) - Testing</p> <p>Pros: - \u2705 Fastest (no I/O) - \u2705 Zero configuration - \u2705 Simple</p> <p>Cons: - \u274c No persistence - \u274c Lost on crash - \u274c No audit trail</p>"},{"location":"guides/persistence/#2-sqlite-default-persistent","title":"2. SQLite (Default Persistent)","text":"<p>Embedded database using <code>KBS::Blackboard::Engine</code>:</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\nengine.add_fact(:sensor, { temp: 28 })\nengine.close\n\n# Next run\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nputs engine.facts.size  # =&gt; 1 (persisted)\n</code></pre> <p>When to use: - Single-process applications - Moderate fact volumes (&lt; 1M facts) - ACID transaction requirements - Complete audit trails - No external dependencies</p> <p>Pros: - \u2705 Embedded (no server) - \u2705 ACID guarantees - \u2705 Durable - \u2705 Full audit trail - \u2705 SQL queries available</p> <p>Cons: - \u274c Slower than Redis - \u274c Single writer - \u274c Not distributed</p> <p>Configuration:</p> <pre><code>engine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',          # Database file path\n  journal_mode: 'WAL'        # WAL mode for better concurrency\n)\n</code></pre>"},{"location":"guides/persistence/#3-redis-high-performance","title":"3. Redis (High Performance)","text":"<p>In-memory data structure store:</p> <pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>When to use: - High-frequency updates (&gt; 1000 writes/sec) - Real-time systems (trading, IoT) - Distributed systems (multiple engines) - Large fact volumes - Speed is critical</p> <p>Pros: - \u2705 100x faster than SQLite - \u2705 Distributed (multiple engines share data) - \u2705 Perfect for real-time - \u2705 Scalable</p> <p>Cons: - \u274c Requires Redis server - \u274c Volatile by default (enable RDB/AOF for persistence) - \u274c No ACID across keys - \u274c Less audit trail</p> <p>Configuration:</p> <pre><code>store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  namespace: 'kbs',              # Key prefix\n  ttl: 86400                     # Expire facts after 24h (optional)\n)\n</code></pre> <p>Redis Persistence Options:</p> <pre><code># In redis.conf:\n\n# RDB: Point-in-time snapshots\nsave 900 1      # Save after 900s if 1 key changed\nsave 300 10     # Save after 300s if 10 keys changed\n\n# AOF: Append-only file (durability)\nappendonly yes\nappendfsync everysec  # Sync to disk every second\n</code></pre>"},{"location":"guides/persistence/#4-hybrid-best-of-both","title":"4. Hybrid (Best of Both)","text":"<p>Combines Redis (speed) with SQLite (durability):</p> <pre><code>require 'kbs/blackboard/persistence/hybrid_store'\n\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>How it works: - Facts: Stored in Redis (fast access) - Audit log: Written to SQLite (durable history) - Messages: Redis sorted sets (fast priority queue)</p> <p>When to use: - Production systems requiring both speed and auditing - Regulatory compliance (need audit trail) - High-frequency updates with history requirements - Distributed systems needing accountability</p> <p>Pros: - \u2705 Fast fact access (Redis) - \u2705 Durable audit trail (SQLite) - \u2705 Best of both worlds - \u2705 Can reconstruct from audit log</p> <p>Cons: - \u274c Requires both Redis and SQLite - \u274c More complex setup - \u274c Slightly slower writes (dual write)</p> <p>Configuration:</p> <pre><code>store = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db',\n  audit_facts: true,        # Log fact changes to SQLite\n  audit_rules: true         # Log rule firings to SQLite\n)\n</code></pre>"},{"location":"guides/persistence/#choosing-a-backend","title":"Choosing a Backend","text":""},{"location":"guides/persistence/#decision-tree","title":"Decision Tree","text":"<pre><code>Need persistence?\n\u251c\u2500 No \u2192 KBS::Engine (default)\n\u2514\u2500 Yes\n   \u2502\n   \u251c\u2500 Need speed &gt; 1000 ops/sec?\n   \u2502  \u251c\u2500 Yes\n   \u2502  \u2502  \u251c\u2500 Need audit trail?\n   \u2502  \u2502  \u2502  \u251c\u2500 Yes \u2192 Hybrid Store\n   \u2502  \u2502  \u2502  \u2514\u2500 No \u2192 Redis Store\n   \u2502  \u2502  \u2514\u2500 No \u2192 Redis Store\n   \u2502  \u2502\n   \u2502  \u2514\u2500 No\n   \u2502     \u251c\u2500 Need distributed access?\n   \u2502     \u2502  \u2514\u2500 Yes \u2192 Redis Store\n   \u2502     \u2514\u2500 No \u2192 SQLite Store\n   \u2502\n   \u2514\u2500 Single machine, moderate load?\n      \u2514\u2500 SQLite Store\n</code></pre>"},{"location":"guides/persistence/#by-use-case","title":"By Use Case","text":"<p>IoT / Real-Time Sensors: <pre><code># High frequency, need speed\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\n</code></pre></p> <p>Trading Systems: <pre><code># Speed + audit trail for compliance\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'trading_audit.db'\n)\n</code></pre></p> <p>Expert Systems: <pre><code># Moderate load, need durability\nengine = KBS::Blackboard::Engine.new(db_path: 'expert.db')\n</code></pre></p> <p>Development / Testing: <pre><code># No persistence needed\nengine = KBS::Engine.new\n</code></pre></p>"},{"location":"guides/persistence/#migration-between-backends","title":"Migration Between Backends","text":""},{"location":"guides/persistence/#sqlite-redis","title":"SQLite \u2192 Redis","text":"<pre><code># 1. Load from SQLite\nsqlite_engine = KBS::Blackboard::Engine.new(db_path: 'old.db')\nfacts = sqlite_engine.facts\n\n# 2. Save to Redis\nredis_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nredis_engine = KBS::Blackboard::Engine.new(store: redis_store)\n\nfacts.each do |fact|\n  redis_engine.add_fact(fact.type, fact.attributes)\nend\n</code></pre>"},{"location":"guides/persistence/#redis-sqlite","title":"Redis \u2192 SQLite","text":"<pre><code># 1. Load from Redis\nredis_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nredis_engine = KBS::Blackboard::Engine.new(store: redis_store)\nfacts = redis_engine.facts\n\n# 2. Save to SQLite\nsqlite_engine = KBS::Blackboard::Engine.new(db_path: 'new.db')\n\nfacts.each do |fact|\n  sqlite_engine.add_fact(fact.type, fact.attributes)\nend\n\nsqlite_engine.close\n</code></pre>"},{"location":"guides/persistence/#performance-comparison","title":"Performance Comparison","text":""},{"location":"guides/persistence/#write-performance","title":"Write Performance","text":"<pre><code>require 'benchmark'\n\n# SQLite\nsqlite_engine = KBS::Blackboard::Engine.new(db_path: 'perf.db')\nBenchmark.bm do |x|\n  x.report(\"SQLite writes:\") do\n    10_000.times { |i| sqlite_engine.add_fact(:test, { value: i }) }\n  end\nend\n# ~5,000 ops/sec\n\n# Redis\nredis_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nredis_engine = KBS::Blackboard::Engine.new(store: redis_store)\nBenchmark.bm do |x|\n  x.report(\"Redis writes:\") do\n    10_000.times { |i| redis_engine.add_fact(:test, { value: i }) }\n  end\nend\n# ~50,000 ops/sec (10x faster)\n</code></pre>"},{"location":"guides/persistence/#read-performance","title":"Read Performance","text":"<pre><code># SQLite\nBenchmark.bm do |x|\n  x.report(\"SQLite reads:\") do\n    10_000.times { sqlite_engine.facts }\n  end\nend\n# ~10,000 ops/sec\n\n# Redis\nBenchmark.bm do |x|\n  x.report(\"Redis reads:\") do\n    10_000.times { redis_engine.facts }\n  end\nend\n# ~100,000 ops/sec (10x faster)\n</code></pre>"},{"location":"guides/persistence/#custom-persistence","title":"Custom Persistence","text":"<p>Implement your own backend by subclassing <code>KBS::Blackboard::Persistence::Store</code>:</p> <pre><code>class PostgresStore &lt; KBS::Blackboard::Persistence::Store\n  def save_fact(fact)\n    # Insert into PostgreSQL\n  end\n\n  def load_facts(type = nil)\n    # Query from PostgreSQL\n  end\n\n  def delete_fact(id)\n    # Delete from PostgreSQL\n  end\n\n  def save_message(topic, message, priority)\n    # Store message\n  end\n\n  def pop_message(topic)\n    # Retrieve highest priority message\n  end\n\n  def log_fact_change(operation, fact)\n    # Audit logging\n  end\n\n  def fact_history(fact_id)\n    # Get change history\n  end\nend\n\n# Use custom store\nstore = PostgresStore.new(connection_string: \"...\")\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>See Custom Persistence for details.</p>"},{"location":"guides/persistence/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"guides/persistence/#sqlite","title":"SQLite","text":"<pre><code># Enable WAL mode for better concurrency\nengine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',\n  journal_mode: 'WAL',\n  synchronous: 'NORMAL',  # Trade some durability for speed\n  cache_size: -64000      # 64MB cache\n)\n</code></pre>"},{"location":"guides/persistence/#redis","title":"Redis","text":"<pre><code># Connection pooling for high concurrency\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  pool_size: 10,          # Connection pool size\n  pool_timeout: 5         # Timeout in seconds\n)\n</code></pre>"},{"location":"guides/persistence/#hybrid","title":"Hybrid","text":"<pre><code># Balance between speed and durability\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db',\n  batch_audit_writes: true,   # Batch SQLite writes\n  audit_batch_size: 100       # Flush every 100 changes\n)\n</code></pre>"},{"location":"guides/persistence/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/persistence/#sqlite-database-locked","title":"SQLite Database Locked","text":"<pre><code># Increase busy timeout\nengine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',\n  busy_timeout: 5000  # Wait up to 5 seconds\n)\n</code></pre>"},{"location":"guides/persistence/#redis-connection-issues","title":"Redis Connection Issues","text":"<pre><code># Enable retry logic\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  reconnect_attempts: 3,\n  reconnect_delay: 1.0\n)\n</code></pre>"},{"location":"guides/persistence/#hybrid-sync-issues","title":"Hybrid Sync Issues","text":"<pre><code># Force synchronous audit writes\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db',\n  sync_audit_writes: true  # Don't batch, write immediately\n)\n</code></pre>"},{"location":"guides/persistence/#next-steps","title":"Next Steps","text":"<ul> <li>Blackboard Memory - Using persistent blackboard</li> <li>Custom Persistence - Implementing custom stores</li> <li>Performance Guide - Optimizing storage performance</li> <li>API Reference - Complete blackboard API</li> </ul> <p>Choose your backend based on speed, durability, and distribution requirements.</p>"},{"location":"guides/variable-binding/","title":"Variable Binding","text":"<p>Variables connect facts across conditions, enabling join constraints in the RETE network. This guide explains how binding works, join tests, and optimization strategies.</p>"},{"location":"guides/variable-binding/#variable-syntax","title":"Variable Syntax","text":"<p>Variables start with <code>?</code> and are symbols:</p> <pre><code>:temp?      # Variable named \"temp\"\n:sensor_id? # Variable named \"sensor_id\"\n:x?         # Variable named \"x\"\n</code></pre> <p>Naming conventions: - Use lowercase with underscores - Be descriptive - Match domain terminology</p>"},{"location":"guides/variable-binding/#basic-binding","title":"Basic Binding","text":""},{"location":"guides/variable-binding/#single-variable","title":"Single Variable","text":"<pre><code>KBS::Condition.new(:sensor, { temp: :t? })\n\n# Matches fact:\n{ type: :sensor, temp: 28 }\n\n# Creates binding:\n{ :t? =&gt; 28 }\n</code></pre>"},{"location":"guides/variable-binding/#multiple-variables","title":"Multiple Variables","text":"<pre><code>KBS::Condition.new(:stock, {\n  symbol: :sym?,\n  price: :price?,\n  volume: :vol?\n})\n\n# Matches:\n{ type: :stock, symbol: \"AAPL\", price: 150, volume: 1000 }\n\n# Bindings:\n{\n  :sym? =&gt; \"AAPL\",\n  :price? =&gt; 150,\n  :vol? =&gt; 1000\n}\n</code></pre>"},{"location":"guides/variable-binding/#cross-condition-binding","title":"Cross-Condition Binding","text":""},{"location":"guides/variable-binding/#join-constraints","title":"Join Constraints","text":"<p>Variables with the same name create equality constraints:</p> <pre><code>r.conditions = [\n  # Condition 1: Binds :id? to sensor's id\n  KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n\n  # Condition 2: Must match same :id?\n  KBS::Condition.new(:threshold, { sensor_id: :id?, max: :max? })\n]\n</code></pre> <p>Join test: <pre><code>sensor[:id] == threshold[:sensor_id]\n</code></pre></p>"},{"location":"guides/variable-binding/#multiple-joins","title":"Multiple Joins","text":"<pre><code>r.conditions = [\n  KBS::Condition.new(:a, { x: :v1?, y: :v2? }),\n  KBS::Condition.new(:b, { p: :v1?, q: :v3? }),\n  KBS::Condition.new(:c, { m: :v2?, n: :v3? })\n]\n\n# Join tests:\n# a[:x] == b[:p]  (via :v1?)\n# a[:y] == c[:m]  (via :v2?)\n# b[:q] == c[:n]  (via :v3?)\n</code></pre>"},{"location":"guides/variable-binding/#visual-example","title":"Visual Example","text":"<pre><code>Condition 1: stock(symbol: :sym?, price: :p?)\nCondition 2: watchlist(symbol: :sym?)\nCondition 3: alert_config(symbol: :sym?, threshold: :t?)\n\nVariable :sym? creates two joins:\n\u251c\u2500 stock[:symbol] == watchlist[:symbol]\n\u2514\u2500 stock[:symbol] == alert_config[:symbol]\n</code></pre>"},{"location":"guides/variable-binding/#binding-lifecycle","title":"Binding Lifecycle","text":""},{"location":"guides/variable-binding/#1-first-occurrence-bind","title":"1. First Occurrence: Bind","text":"<pre><code># First condition with :sym?\nKBS::Condition.new(:stock, { symbol: :sym? })\n\n# Fact matches\n{ type: :stock, symbol: \"AAPL\" }\n\n# Binding created:\n{ :sym? =&gt; \"AAPL\" }\n</code></pre>"},{"location":"guides/variable-binding/#2-subsequent-occurrences-test","title":"2. Subsequent Occurrences: Test","text":"<pre><code># Second condition with :sym?\nKBS::Condition.new(:watchlist, { symbol: :sym? })\n\n# Checks if symbol == \"AAPL\" (from previous binding)\n# Matches:\n{ type: :watchlist, symbol: \"AAPL\" }  # \u2713\n\n# Does not match:\n{ type: :watchlist, symbol: \"GOOGL\" }  # \u2717\n</code></pre>"},{"location":"guides/variable-binding/#3-action-access","title":"3. Action: Access","text":"<pre><code>r.action = lambda do |facts, bindings|\n  # Access bound variables\n  symbol = bindings[:sym?]\n  price = bindings[:p?]\n\n  puts \"#{symbol} at $#{price}\"\nend\n</code></pre>"},{"location":"guides/variable-binding/#join-tests","title":"Join Tests","text":""},{"location":"guides/variable-binding/#what-is-a-join-test","title":"What is a Join Test?","text":"<p>A join test verifies that variable values match across facts:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, { x: :v? }),\n  KBS::Condition.new(:b, { y: :v? })\n]\n\n# Join test structure:\n{\n  token_field_index: 0,     # Index of fact in token (first condition)\n  token_field: :x,          # Attribute name in first fact\n  fact_field: :y,           # Attribute name in new fact\n  operation: :eq            # Equality test\n}\n</code></pre>"},{"location":"guides/variable-binding/#join-test-execution","title":"Join Test Execution","text":"<pre><code>def perform_join_test(token, new_fact, test)\n  # Get value from token (previous facts)\n  token_fact = token.facts[test[:token_field_index]]\n  token_value = token_fact[test[:token_field]]\n\n  # Get value from new fact\n  fact_value = new_fact[test[:fact_field]]\n\n  # Test equality\n  token_value == fact_value\nend\n</code></pre>"},{"location":"guides/variable-binding/#example-execution","title":"Example Execution","text":"<pre><code># Rule\nr.conditions = [\n  KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n  KBS::Condition.new(:threshold, { sensor_id: :id?, max: :max? })\n]\n\n# Facts\nsensor = { type: :sensor, id: \"bedroom\", temp: 28 }\nthreshold = { type: :threshold, sensor_id: \"bedroom\", max: 25 }\n\n# Join execution:\n# 1. sensor matches \u2192 token created\ntoken = Token.new(parent: root, fact: sensor)\n# Bindings: { :id? =&gt; \"bedroom\", :temp? =&gt; 28 }\n\n# 2. threshold tested against token\ntest = {\n  token_field_index: 0,       # sensor is first fact\n  token_field: :id,           # sensor's id attribute\n  fact_field: :sensor_id,     # threshold's sensor_id attribute\n  operation: :eq\n}\n\n# 3. Perform join\ntoken_value = sensor[:id]              # \"bedroom\"\nfact_value = threshold[:sensor_id]     # \"bedroom\"\nresult = token_value == fact_value     # true\n# \u2713 Join succeeds \u2192 new token created\n</code></pre>"},{"location":"guides/variable-binding/#binding-strategies","title":"Binding Strategies","text":""},{"location":"guides/variable-binding/#pattern-1-primary-key-join","title":"Pattern 1: Primary Key Join","text":"<p>Connect facts via identifier:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:order, {\n    id: :order_id?,\n    status: \"pending\"\n  }),\n\n  KBS::Condition.new(:payment, {\n    order_id: :order_id?,\n    verified: true\n  })\n]\n\n# Matches orders with verified payments\n</code></pre>"},{"location":"guides/variable-binding/#pattern-2-multi-attribute-join","title":"Pattern 2: Multi-Attribute Join","text":"<p>Join on multiple fields:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:trade, {\n    symbol: :sym?,\n    date: :date?,\n    volume: :vol?\n  }),\n\n  KBS::Condition.new(:settlement, {\n    symbol: :sym?,\n    trade_date: :date?\n  })\n]\n\n# Joins on both symbol AND date\n</code></pre>"},{"location":"guides/variable-binding/#pattern-3-transitive-binding","title":"Pattern 3: Transitive Binding","text":"<p>Chain bindings across three+ conditions:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, { id: :x? }),\n  KBS::Condition.new(:b, { a_id: :x?, id: :y? }),\n  KBS::Condition.new(:c, { b_id: :y? })\n]\n\n# a[:id] == b[:a_id]\n# b[:id] == c[:b_id]\n# Creates chain: a \u2192 b \u2192 c\n</code></pre>"},{"location":"guides/variable-binding/#pattern-4-fan-out-join","title":"Pattern 4: Fan-Out Join","text":"<p>One fact joins with multiple:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:sensor, { id: :id?, temp: :t? }),\n  KBS::Condition.new(:threshold, { sensor_id: :id? }),\n  KBS::Condition.new(:alert_config, { sensor_id: :id? }),\n  KBS::Condition.new(:location, { sensor_id: :id? })\n]\n\n# All join on :id?\n</code></pre>"},{"location":"guides/variable-binding/#performance-implications","title":"Performance Implications","text":""},{"location":"guides/variable-binding/#join-cardinality","title":"Join Cardinality","text":"<pre><code># Condition 1: 100 sensor facts\nKBS::Condition.new(:sensor, { temp: :t? })\n\n# Condition 2: 200 threshold facts\nKBS::Condition.new(:threshold, { max: :m? })\n\n# Without variable binding:\n# Potential matches: 100 \u00d7 200 = 20,000\n\n# With variable binding:\nKBS::Condition.new(:sensor, { id: :id?, temp: :t? })\nKBS::Condition.new(:threshold, { sensor_id: :id?, max: :m? })\n\n# Actual matches: ~100 (1:1 relationship)\n</code></pre> <p>Variable bindings dramatically reduce join size.</p>"},{"location":"guides/variable-binding/#beta-memory-size","title":"Beta Memory Size","text":"<pre><code># Bad: No shared variables\nr.conditions = [\n  KBS::Condition.new(:a, {}),  # 1000 facts\n  KBS::Condition.new(:b, {}),  # 1000 facts\n  KBS::Condition.new(:c, {})   # 1000 facts\n]\n# Beta memory: 1000 \u00d7 1000 \u00d7 1000 = 1,000,000,000 tokens!\n\n# Good: Shared variables\nr.conditions = [\n  KBS::Condition.new(:a, { id: :id? }),\n  KBS::Condition.new(:b, { a_id: :id? }),\n  KBS::Condition.new(:c, { a_id: :id? })\n]\n# Beta memory: ~1000 tokens (assuming 1:1:1 relationship)\n</code></pre>"},{"location":"guides/variable-binding/#optimization-tips","title":"Optimization Tips","text":"<p>1. Use specific bindings:</p> <pre><code># Good: Binds sensor to specific readings\nKBS::Condition.new(:sensor, { id: :id? })\nKBS::Condition.new(:reading, { sensor_id: :id? })\n\n# Bad: No binding (cross product)\nKBS::Condition.new(:sensor, {})\nKBS::Condition.new(:reading, {})\n</code></pre> <p>2. Order by selectivity:</p> <pre><code># Good: Specific first\nr.conditions = [\n  KBS::Condition.new(:critical_alert, { id: :id? }),  # 1 fact\n  KBS::Condition.new(:sensor, { id: :id? })          # 1000 facts\n]\n# Beta memory: 1 token\n\n# Bad: General first\nr.conditions = [\n  KBS::Condition.new(:sensor, { id: :id? }),          # 1000 facts\n  KBS::Condition.new(:critical_alert, { id: :id? })   # 1 fact\n]\n# Beta memory: 1000 tokens\n</code></pre> <p>3. Minimize cross products:</p> <pre><code># Bad: No shared variables between first two conditions\nr.conditions = [\n  KBS::Condition.new(:a, { x: :v1? }),\n  KBS::Condition.new(:b, { y: :v2? }),  # No :v1?!\n  KBS::Condition.new(:c, { p: :v1?, q: :v2? })\n]\n# Creates a \u00d7 b cross product\n\n# Good: Progressive joining\nr.conditions = [\n  KBS::Condition.new(:a, { x: :v1? }),\n  KBS::Condition.new(:c, { p: :v1?, q: :v2? }),\n  KBS::Condition.new(:b, { y: :v2? })\n]\n# Each condition reduces search space\n</code></pre>"},{"location":"guides/variable-binding/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/variable-binding/#one-to-many-relationship","title":"One-to-Many Relationship","text":"<pre><code># One customer, many orders\nr.conditions = [\n  KBS::Condition.new(:customer, {\n    id: :cust_id?,\n    status: \"active\"\n  }),\n\n  KBS::Condition.new(:order, {\n    customer_id: :cust_id?,\n    status: \"pending\"\n  })\n]\n\n# Fires once per pending order for active customers\n</code></pre>"},{"location":"guides/variable-binding/#many-to-many-relationship","title":"Many-to-Many Relationship","text":"<pre><code># Students enrolled in courses\nr.conditions = [\n  KBS::Condition.new(:student, { id: :student_id? }),\n  KBS::Condition.new(:enrollment, {\n    student_id: :student_id?,\n    course_id: :course_id?\n  }),\n  KBS::Condition.new(:course, { id: :course_id? })\n]\n\n# Fires for each student-course pair\n</code></pre>"},{"location":"guides/variable-binding/#hierarchical-join","title":"Hierarchical Join","text":"<pre><code># Parent \u2192 Child \u2192 Grandchild\nr.conditions = [\n  KBS::Condition.new(:category, { id: :cat_id? }),\n  KBS::Condition.new(:product, {\n    category_id: :cat_id?,\n    id: :prod_id?\n  }),\n  KBS::Condition.new(:review, {\n    product_id: :prod_id?,\n    rating: :rating?\n  })\n]\n</code></pre>"},{"location":"guides/variable-binding/#debugging-bindings","title":"Debugging Bindings","text":""},{"location":"guides/variable-binding/#print-bindings","title":"Print Bindings","text":"<pre><code>r.action = lambda do |facts, bindings|\n  puts \"Bindings: #{bindings.inspect}\"\n  puts \"Facts:\"\n  facts.each_with_index do |fact, i|\n    puts \"  #{i}: #{fact.type} #{fact.attributes}\"\n  end\nend\n</code></pre>"},{"location":"guides/variable-binding/#trace-join-tests","title":"Trace Join Tests","text":"<pre><code>class DebugJoinNode &lt; KBS::JoinNode\n  def perform_join_tests(token, fact)\n    result = super\n    puts \"Join test: #{@tests.inspect}\"\n    puts \"  Token: #{token.inspect}\"\n    puts \"  Fact: #{fact.inspect}\"\n    puts \"  Result: #{result}\"\n    result\n  end\nend\n</code></pre>"},{"location":"guides/variable-binding/#validate-bindings","title":"Validate Bindings","text":"<pre><code>r.action = lambda do |facts, bindings|\n  # Ensure expected bindings exist\n  required = [:sensor_id?, :temp?, :max?]\n  missing = required - bindings.keys\n\n  if missing.any?\n    raise \"Missing bindings: #{missing}\"\n  end\n\n  # Proceed with action\n  # ...\nend\n</code></pre>"},{"location":"guides/variable-binding/#next-steps","title":"Next Steps","text":"<ul> <li>Pattern Matching - How facts match conditions</li> <li>Negation - Negated conditions and binding</li> <li>Network Structure - How joins compile into networks</li> <li>Performance Guide - Optimizing join performance</li> </ul> <p>Variable binding is the glue that connects facts. Master bindings, master rule performance.</p>"},{"location":"guides/writing-rules/","title":"Writing Rules","text":"<p>Master the art of authoring production rules. This guide covers best practices, patterns, and strategies for writing effective, maintainable, and performant rules in KBS.</p>"},{"location":"guides/writing-rules/#rule-anatomy","title":"Rule Anatomy","text":"<p>Every rule consists of three parts:</p> <pre><code>KBS.knowledge_base do\n  rule \"rule_name\", priority: 0 do\n    # 1. CONDITIONS - Pattern matching\n    on :fact_type, attr: value\n\n    # 2. ACTION - What to do when conditions match\n    perform do |facts, bindings|\n      # Execute logic\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#1-rule-name","title":"1. Rule Name","text":"<p>Choose descriptive, actionable names:</p> <pre><code># Good: Clear intent\n\"send_high_temperature_alert\"\n\"cancel_duplicate_orders\"\n\"escalate_critical_issues\"\n\n# Bad: Vague or cryptic\n\"rule1\"\n\"process\"\n\"check_stuff\"\n</code></pre> <p>Naming Conventions: - Use snake_case - Start with verb (action-oriented) - Be specific about what the rule does - Include domain context</p>"},{"location":"guides/writing-rules/#2-priority","title":"2. Priority","text":"<p>Control execution order when multiple rules match:</p> <pre><code>KBS.knowledge_base do\n  rule \"critical_safety_check\", priority: 100 do  # Fires first\n    # ...\n  end\n\n  rule \"normal_processing\", priority: 50 do\n    # ...\n  end\n\n  rule \"cleanup_task\", priority: 10 do            # Fires last\n    # ...\n  end\nend\n</code></pre> <p>Priority Guidelines: - 100+ - Safety checks, emergency shutdowns - 50-99 - Business logic, processing - 1-49 - Monitoring, logging, cleanup - 0 - Default priority (no preference)</p>"},{"location":"guides/writing-rules/#3-conditions","title":"3. Conditions","text":"<p>Patterns that must match for the rule to fire. Order matters for performance.</p> <pre><code>KBS.knowledge_base do\n  rule \"example\" do\n    # Most selective first (fewest matches)\n    on :critical_alert, severity: \"critical\"\n\n    # Less selective last (more matches)\n    on :sensor, id: :sensor_id?\n\n    perform do |facts, bindings|\n      # Action\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#4-action","title":"4. Action","text":"<p>Code executed when all conditions match:</p> <pre><code>KBS.knowledge_base do\n  rule \"example\" do\n    on :alert, message: :msg?\n    on :sensor, id: :sensor_id?\n\n    perform do |facts, bindings|\n      # Access matched facts\n      alert = facts[0]\n      sensor = facts[1]\n\n      # Access variable bindings\n      sensor_id = bindings[:sensor_id?]\n\n      # Perform action\n      notify_operator(sensor_id, alert[:message])\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#condition-ordering","title":"Condition Ordering","text":"<p>Golden Rule: Order conditions from most selective to least selective.</p>"},{"location":"guides/writing-rules/#why-order-matters","title":"Why Order Matters","text":"<pre><code># Bad: General condition first\nKBS.knowledge_base do\n  rule \"inefficient\" do\n    on :sensor, {}           # 1000 matches\n    on :critical_alert, {}   # 1 match\n    perform { }\n  end\nend\n# Creates 1000 partial matches, wastes memory\n\n# Good: Specific condition first\nKBS.knowledge_base do\n  rule \"efficient\" do\n    on :critical_alert, {}   # 1 match\n    on :sensor, {}           # Joins with 1000\n    perform { }\n  end\nend\n# Creates 1 partial match, efficient joins\n</code></pre>"},{"location":"guides/writing-rules/#selectivity-examples","title":"Selectivity Examples","text":"<pre><code># Most selective (few facts)\non :emergency, level: \"critical\"\non :user, role: \"admin\"\n\n# Moderate selectivity\non :order, status: \"pending\"\non :stock, exchange: \"NYSE\"\n\n# Least selective (many facts)\non :sensor, {}\non :log_entry, {}\n</code></pre>"},{"location":"guides/writing-rules/#measuring-selectivity","title":"Measuring Selectivity","text":"<pre><code>def measure_selectivity(kb, type, pattern)\n  kb.engine.facts.count { |f|\n    f.type == type &amp;&amp;\n    pattern.all? { |k, v| f[k] == v }\n  }\nend\n\n# Compare\nputs measure_selectivity(kb, :critical_alert, {})  # =&gt; 1\nputs measure_selectivity(kb, :sensor, {})          # =&gt; 1000\n\n# Order: critical_alert first, sensor second\n</code></pre>"},{"location":"guides/writing-rules/#action-design","title":"Action Design","text":""},{"location":"guides/writing-rules/#single-responsibility","title":"Single Responsibility","text":"<p>One action, one purpose:</p> <pre><code># Good: Focused action\nKBS.knowledge_base do\n  rule \"send_email\" do\n    on :alert, email: :email?, message: :message?\n    perform do |facts, bindings|\n      send_email_alert(bindings[:email?], bindings[:message?])\n    end\n  end\nend\n\n# Bad: Multiple responsibilities\nKBS.knowledge_base do\n  rule \"do_everything\" do\n    on :trigger, email: :email?, id: :id?, data: :data?, msg: :msg?\n    perform do |facts, bindings|\n      send_email_alert(bindings[:email?])\n      update_database(bindings[:id?])\n      call_external_api(bindings[:data?])\n      write_log_file(bindings[:msg?])\n    end\n  end\nend\n</code></pre> <p>Split complex actions into multiple rules:</p> <pre><code>KBS.knowledge_base do\n  # Rule 1: Detect condition\n  rule \"detect_high_temp\", priority: 50 do\n    on :sensor, temp: :temp?, predicate: greater_than(30)\n\n    perform do |facts, bindings|\n      fact :high_temp_detected, temp: bindings[:temp?]\n    end\n  end\n\n  # Rule 2: Send alert\n  rule \"send_temp_alert\", priority: 40 do\n    on :high_temp_detected, temp: :temp?\n\n    perform do |facts, bindings|\n      send_email(\"High temp: #{bindings[:temp?]}\")\n    end\n  end\n\n  # Rule 3: Log event\n  rule \"log_temp_event\", priority: 30 do\n    on :high_temp_detected, temp: :temp?\n\n    perform do |facts, bindings|\n      logger.info(\"Temperature spike: #{bindings[:temp?]}\")\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#avoid-side-effects","title":"Avoid Side Effects","text":"<p>Actions should be deterministic and idempotent when possible:</p> <pre><code># Good: Idempotent (safe to run multiple times)\nkb = KBS.knowledge_base do\n  rule \"update_alert\" do\n    on :trigger, id: :id?\n\n    perform do |facts, bindings|\n      # Remove old alert if exists\n      old = engine.facts.find { |f| f.type == :alert &amp;&amp; f[:id] == bindings[:id?] }\n      engine.remove_fact(old) if old\n\n      # Add new alert\n      fact :alert, id: bindings[:id?], message: \"Alert!\"\n    end\n  end\nend\n\n# Bad: Non-idempotent (creates duplicates)\nkb = KBS.knowledge_base do\n  rule \"duplicate_alerts\" do\n    on :trigger, id: :id?\n\n    perform do |facts, bindings|\n      # Always adds, even if alert already exists\n      fact :alert, id: bindings[:id?], message: \"Alert!\"\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#error-handling","title":"Error Handling","text":"<p>Protect against failures:</p> <pre><code>KBS.knowledge_base do\n  rule \"safe_email\" do\n    on :alert, email: :email?, message: :message?\n\n    perform do |facts, bindings|\n      begin\n        send_email(bindings[:email?], bindings[:message?])\n      rescue Net::SMTPError =&gt; e\n        logger.error(\"Failed to send email: #{e.message}\")\n        # Add failure fact for retry logic\n        fact :email_failure,\n          email: bindings[:email?],\n          error: e.message,\n          timestamp: Time.now\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#variable-binding-strategies","title":"Variable Binding Strategies","text":""},{"location":"guides/writing-rules/#consistent-naming","title":"Consistent Naming","text":"<p>Use descriptive, consistent variable names:</p> <pre><code># Good: Clear intent\n:sensor_id?\n:temperature_celsius?\n:alert_threshold?\n:user_email?\n\n# Bad: Cryptic\n:s?\n:t?\n:x?\n</code></pre>"},{"location":"guides/writing-rules/#join-patterns","title":"Join Patterns","text":"<p>Connect facts through shared variables:</p> <pre><code>KBS.knowledge_base do\n  # Pattern: Join sensor reading with threshold\n  rule \"check_threshold\" do\n    on :sensor,\n      id: :sensor_id?,\n      temp: :current_temp?\n\n    on :threshold,\n      sensor_id: :sensor_id?,  # Same variable = join constraint\n      max_temp: :max_temp?\n\n    perform do |facts, bindings|\n      # Only matches when sensor_id is same in both facts\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#computed-bindings","title":"Computed Bindings","text":"<p>Derive values in actions:</p> <pre><code>KBS.knowledge_base do\n  rule \"calculate_diff\" do\n    on :sensor, temp: :current_temp?\n    on :threshold, max_temp: :max_temp?\n\n    perform do |facts, bindings|\n      current = bindings[:current_temp?]\n      max = bindings[:max_temp?]\n\n      # Compute derived values\n      diff = current - max\n      percentage_over = ((current / max.to_f) - 1) * 100\n\n      puts \"#{diff}\u00b0C over threshold (#{percentage_over.round(1)}%)\"\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#rule-composition-patterns","title":"Rule Composition Patterns","text":""},{"location":"guides/writing-rules/#state-machine","title":"State Machine","text":"<p>Model state transitions:</p> <pre><code>KBS.knowledge_base do\n  # Transition: pending \u2192 processing\n  rule \"start_processing\" do\n    on :order,\n      id: :order_id?,\n      status: \"pending\"\n\n    perform do |facts, bindings|\n      old_order = facts[0]\n      engine.remove_fact(old_order)\n      fact :order,\n        id: bindings[:order_id?],\n        status: \"processing\",\n        started_at: Time.now\n    end\n  end\n\n  # Transition: processing \u2192 completed\n  rule \"complete_processing\" do\n    on :order,\n      id: :order_id?,\n      status: \"processing\"\n    on :processing_done,\n      order_id: :order_id?\n\n    perform do |facts, bindings|\n      order = facts[0]\n      engine.remove_fact(order)\n      engine.remove_fact(facts[1])  # Remove trigger\n      fact :order,\n        id: bindings[:order_id?],\n        status: \"completed\",\n        completed_at: Time.now\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#guard-conditions","title":"Guard Conditions","text":"<p>Prevent duplicate actions:</p> <pre><code>KBS.knowledge_base do\n  rule \"send_alert_once\" do\n    on :high_temp, sensor_id: :id?\n\n    # Guard: Only fire if alert not already sent\n    without :alert_sent, sensor_id: :id?\n\n    perform do |facts, bindings|\n      send_alert(bindings[:id?])\n\n      # Record that we sent this alert\n      fact :alert_sent, sensor_id: bindings[:id?]\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#cleanup-rules","title":"Cleanup Rules","text":"<p>Remove stale facts:</p> <pre><code>KBS.knowledge_base do\n  rule \"cleanup_stale_alerts\", priority: 1 do\n    on :alert,\n      timestamp: :time?,\n      predicate: lambda { |f|\n        (Time.now - f[:timestamp]) &gt; 3600  # 1 hour old\n      }\n\n    perform do |facts, bindings|\n      engine.remove_fact(facts[0])\n      logger.info(\"Removed stale alert\")\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#aggregation-rules","title":"Aggregation Rules","text":"<p>Compute over multiple facts:</p> <pre><code>KBS.knowledge_base do\n  rule \"compute_average_temp\" do\n    on :compute_avg_requested, {}\n\n    perform do |facts, bindings|\n      temps = engine.facts\n        .select { |f| f.type == :sensor }\n        .map { |f| f[:temp] }\n        .compact\n\n      avg = temps.sum / temps.size.to_f\n\n      fact :average_temp, value: avg\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#temporal-rules","title":"Temporal Rules","text":"<p>React to time-based conditions:</p> <pre><code>KBS.knowledge_base do\n  rule \"detect_delayed_response\" do\n    on :request,\n      id: :req_id?,\n      created_at: :created?\n\n    without :response,\n      request_id: :req_id?\n\n    on :request, {},\n      predicate: lambda { |f|\n        (Time.now - f[:created_at]) &gt; 300  # 5 minutes\n      }\n\n    perform do |facts, bindings|\n      alert(\"Request #{bindings[:req_id?]} delayed!\")\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#priority-management","title":"Priority Management","text":""},{"location":"guides/writing-rules/#priority-levels","title":"Priority Levels","text":"<p>Establish consistent priority levels for your domain:</p> <pre><code># Define priority constants\nmodule Priority\n  CRITICAL = 100   # Emergency, safety\n  HIGH = 75        # Important business logic\n  NORMAL = 50      # Standard processing\n  LOW = 25         # Cleanup, logging\n  MONITORING = 10  # Metrics, diagnostics\nend\n\n# Use in rules\nKBS.knowledge_base do\n  rule \"emergency_shutdown\", priority: Priority::CRITICAL do\n    # ...\n  end\n\n  rule \"process_order\", priority: Priority::NORMAL do\n    # ...\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#priority-inversion","title":"Priority Inversion","text":"<p>Avoid priority inversions where low-priority rules block high-priority rules:</p> <pre><code># Bad: Low priority rule creates fact needed by high priority rule\nKBS.knowledge_base do\n  rule \"compute_risk\", priority: 10 do\n    on :data, value: :v?\n    perform do |facts, bindings|\n      fact :risk_score, value: calculate_risk(bindings[:v?])\n    end\n  end\n\n  rule \"emergency_check\", priority: 100 do\n    on :risk_score, value: :risk?  # Depends on low priority rule!\n    perform do |facts, bindings|\n      emergency_shutdown if bindings[:risk?] &gt; 90\n    end\n  end\nend\n\n# Fix: Make dependency higher priority\nKBS.knowledge_base do\n  rule \"compute_risk\", priority: 110 do  # Now runs before emergency_check\n    on :data, value: :v?\n    perform do |facts, bindings|\n      fact :risk_score, value: calculate_risk(bindings[:v?])\n    end\n  end\n\n  rule \"emergency_check\", priority: 100 do\n    on :risk_score, value: :risk?\n    perform do |facts, bindings|\n      emergency_shutdown if bindings[:risk?] &gt; 90\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#testing-strategies","title":"Testing Strategies","text":""},{"location":"guides/writing-rules/#unit-test-rules-in-isolation","title":"Unit Test Rules in Isolation","text":"<pre><code>require 'minitest/autorun'\nrequire 'kbs'\n\nclass TestTemperatureRules &lt; Minitest::Test\n  def test_fires_when_temp_exceeds_threshold\n    alert_fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_alert\" do\n        on :sensor, id: :id?, temp: :temp?\n        on :threshold, id: :id?, max: :max?\n\n        perform do |facts, bindings|\n          alert_fired = true if bindings[:temp?] &gt; bindings[:max?]\n        end\n      end\n\n      fact :sensor, id: \"bedroom\", temp: 30\n      fact :threshold, id: \"bedroom\", max: 25\n      run\n    end\n\n    assert alert_fired, \"Rule should fire when temp &gt; threshold\"\n  end\n\n  def test_does_not_fire_when_temp_below_threshold\n    alert_fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_alert\" do\n        on :sensor, id: :id?, temp: :temp?\n        on :threshold, id: :id?, max: :max?\n\n        perform do |facts, bindings|\n          alert_fired = true if bindings[:temp?] &gt; bindings[:max?]\n        end\n      end\n\n      fact :sensor, id: \"bedroom\", temp: 20\n      fact :threshold, id: \"bedroom\", max: 25\n      run\n    end\n\n    refute alert_fired, \"Rule should not fire when temp &lt;= threshold\"\n  end\n\n  def test_only_fires_for_matching_sensor\n    alert_fired = false\n\n    kb = KBS.knowledge_base do\n      rule \"high_temp_alert\" do\n        on :sensor, id: :id?, temp: :temp?\n        on :threshold, id: :id?, max: :max?\n\n        perform do |facts, bindings|\n          alert_fired = true if bindings[:temp?] &gt; bindings[:max?]\n        end\n      end\n\n      fact :sensor, id: \"bedroom\", temp: 30\n      fact :threshold, id: \"kitchen\", max: 25\n      run\n    end\n\n    refute alert_fired, \"Rule should not fire for different sensors\"\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#integration-tests","title":"Integration Tests","text":"<p>Test multiple rules working together:</p> <pre><code>def test_state_machine_workflow\n  kb = KBS.knowledge_base do\n    # Add state transition rules\n    rule \"start_processing\" do\n      on :order, id: :id?, status: \"pending\"\n      perform do |facts, bindings|\n        engine.remove_fact(facts[0])\n        fact :order, id: bindings[:id?], status: \"processing\"\n      end\n    end\n\n    rule \"complete_processing\" do\n      on :order, id: :id?, status: \"processing\"\n      on :processing_done, order_id: :id?\n      perform do |facts, bindings|\n        engine.remove_fact(facts[0])\n        engine.remove_fact(facts[1])\n        fact :order, id: bindings[:id?], status: \"completed\"\n      end\n    end\n\n    # Add initial state\n    fact :order, id: 1, status: \"pending\"\n    run\n  end\n\n  # Should not transition yet\n  order = kb.engine.facts.find { |f| f.type == :order &amp;&amp; f[:id] == 1 }\n  assert_equal \"pending\", order[:status]\n\n  # Trigger transition\n  kb.fact :processing_done, order_id: 1\n  kb.run\n\n  # Should transition to completed\n  order = kb.engine.facts.find { |f| f.type == :order &amp;&amp; f[:id] == 1 }\n  assert_equal \"completed\", order[:status]\nend\n</code></pre>"},{"location":"guides/writing-rules/#property-based-testing","title":"Property-Based Testing","text":"<p>Test rule invariants:</p> <pre><code>def test_no_duplicate_alerts\n  kb = KBS.knowledge_base do\n    rule \"send_alert_once\" do\n      on :high_temp, sensor_id: :id?\n      without :alert_sent, sensor_id: :id?\n\n      perform do |facts, bindings|\n        send_alert(bindings[:id?])\n        fact :alert_sent, sensor_id: bindings[:id?]\n      end\n    end\n\n    # Add facts\n    100.times do |i|\n      fact :high_temp, sensor_id: i\n    end\n\n    # Run engine multiple times\n    10.times { run }\n  end\n\n  # Property: At most one alert per sensor\n  alert_counts = kb.engine.facts\n    .select { |f| f.type == :alert_sent }\n    .group_by { |f| f[:sensor_id] }\n    .transform_values(&amp;:count)\n\n  alert_counts.each do |sensor_id, count|\n    assert_equal 1, count, \"Sensor #{sensor_id} has #{count} alerts, expected 1\"\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guides/writing-rules/#minimize-negations","title":"Minimize Negations","text":"<p>Negations are expensive:</p> <pre><code># Expensive: 3 negations\nKBS.knowledge_base do\n  rule \"many_negations\" do\n    without :foo, {}\n    without :bar, {}\n    without :baz, {}\n    perform { }\n  end\nend\n\n# Better: Combine into positive condition\nKBS.knowledge_base do\n  rule \"positive_logic\" do\n    on :conditions_met, {}\n    perform { }\n  end\n\n  # Add conditions_met fact if foo, bar, baz don't exist\n  unless engine.facts.any? { |f| [:foo, :bar, :baz].include?(f.type) }\n    fact :conditions_met, {}\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#avoid-predicates-for-simple-checks","title":"Avoid Predicates for Simple Checks","text":"<pre><code># Expensive: Predicate disables network sharing\nKBS.knowledge_base do\n  rule \"with_predicate\" do\n    on :stock, {}, predicate: lambda { |f| f[:symbol] == \"AAPL\" }\n    perform { }\n  end\nend\n\n# Better: Use pattern matching\nKBS.knowledge_base do\n  rule \"with_pattern\" do\n    on :stock, symbol: \"AAPL\"\n    perform { }\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#cache-computed-values","title":"Cache Computed Values","text":"<pre><code># Bad: Recomputes every time rule fires\nKBS.knowledge_base do\n  rule \"check_average\" do\n    on :sensor, temp: :temp?\n\n    perform do |facts, bindings|\n      avg = compute_expensive_average(engine.facts)\n      alert(avg) if avg &gt; threshold\n    end\n  end\nend\n\n# Good: Cache as fact, recompute only when needed\nKBS.knowledge_base do\n  rule \"update_average\", priority: 100 do\n    on :sensor, temp: :temp?  # Triggers when sensor added\n\n    perform do |facts, bindings|\n      avg = compute_expensive_average(engine.facts)\n      fact :cached_average, value: avg\n    end\n  end\n\n  rule \"check_average\", priority: 50 do\n    on :cached_average, value: :avg?\n\n    perform do |facts, bindings|\n      alert(bindings[:avg?]) if bindings[:avg?] &gt; threshold\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guides/writing-rules/#1-infinite-loops","title":"1. Infinite Loops","text":"<pre><code># Bad: Rule fires itself indefinitely\nKBS.knowledge_base do\n  rule \"infinite_loop\" do\n    on :sensor, temp: :temp?\n\n    perform do |facts, bindings|\n      # This triggers the rule again!\n      fact :sensor, temp: bindings[:temp?] + 1\n    end\n  end\nend\n\n# Fix: Add termination condition\nKBS.knowledge_base do\n  rule \"limited_increment\" do\n    on :sensor, temp: :temp?\n    without :increment_done, {}\n\n    perform do |facts, bindings|\n      fact :sensor, temp: bindings[:temp?] + 1\n      fact :increment_done, {}\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#2-variable-scope-confusion","title":"2. Variable Scope Confusion","text":"<pre><code># Bad: Closure captures wrong variable\nrules = []\n%w[sensor1 sensor2 sensor3].each do |sensor|\n  # All rules reference same 'sensor' variable (last value!)\n  kb = KBS.knowledge_base do\n    rule \"process_#{sensor}\" do\n      on :reading, {}\n      perform { puts sensor }  # Wrong!\n    end\n  end\nend\n\n# Fix: Force closure with parameter\n%w[sensor1 sensor2 sensor3].each do |sensor_name|\n  captured_sensor = sensor_name  # Force capture\n\n  kb = KBS.knowledge_base do\n    rule \"process_#{captured_sensor}\" do\n      on :reading, {}\n      perform { puts captured_sensor }  # Correct\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#3-forgetting-to-call-run","title":"3. Forgetting to Call <code>run</code>","text":"<pre><code># Bad: Facts added but never matched\nkb = KBS.knowledge_base do\n  rule \"example\" do\n    on :sensor, temp: :temp?\n    on :threshold, max: :max?\n    perform { }\n  end\n\n  fact :sensor, temp: 30\n  fact :threshold, max: 25\n  # Rules never fire!\nend\n\n# Good: Run after adding facts\nkb = KBS.knowledge_base do\n  rule \"example\" do\n    on :sensor, temp: :temp?\n    on :threshold, max: :max?\n    perform { }\n  end\n\n  fact :sensor, temp: 30\n  fact :threshold, max: 25\n  run  # Match and fire rules\nend\n</code></pre>"},{"location":"guides/writing-rules/#next-steps","title":"Next Steps","text":"<ul> <li>Pattern Matching - Deep dive into condition matching</li> <li>Variable Binding - Join tests and binding extraction</li> <li>Negation - Negated condition behavior</li> <li>Performance Guide - Profiling and optimization</li> <li>Testing Guide - Comprehensive test strategies</li> </ul> <p>Well-designed rules are self-documenting. If a rule is hard to understand, it's probably doing too much.</p>"}]}