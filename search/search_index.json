{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#kbs-knowledge-based-systems-for-ruby","title":"KBS - Knowledge-Based Systems for Ruby","text":"<p>A Ruby implementation of the RETE algorithm for building intelligent, rule-based systems with persistent memory.</p> <p> </p>"},{"location":"#what-is-kbs","title":"What is KBS?","text":"<p>KBS (Knowledge-Based Systems) is a powerful Ruby gem that brings production rule systems to your applications. At its core is the RETE algorithm, a highly optimized pattern-matching engine originally developed for expert systems and now used in modern applications ranging from trading systems to IoT automation.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 RETE Algorithm: State-of-the-art pattern matching with unlinking optimization</li> <li>\ud83d\udcbe Persistent Blackboard Memory: SQLite, Redis, or hybrid storage for facts and audit trails</li> <li>\ud83c\udfaf Declarative DSL: Write rules in natural, readable Ruby syntax</li> <li>\ud83d\udd04 Incremental Matching: Process only changes, not entire fact sets</li> <li>\ud83d\udeab Negation Support: Express \"absence of pattern\" conditions naturally</li> <li>\ud83d\udcca Multi-Agent Systems: Build collaborative systems with message passing</li> <li>\ud83d\udd0d Full Auditability: Complete history of fact changes and rule firings</li> <li>\u26a1 High Performance: Handle millions of facts with sub-millisecond updates</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>require 'kbs'\n\n# Create a rule-based trading system\nengine = KBS::Engine.new\n\n# Define a rule using the DSL\nengine.add_rule(Rule.new(\"buy_signal\") do |r|\n  r.conditions = [\n    # Stock price is below threshold\n    Condition.new(:stock, { symbol: :symbol?, price: :price? }),\n    Condition.new(:threshold, { symbol: :symbol?, buy_below: :threshold? }),\n\n    # No pending order exists (negation)\n    Condition.new(:order, { symbol: :symbol? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:price?] &lt; bindings[:threshold?]\n      puts \"BUY #{bindings[:symbol?]} at #{bindings[:price?]}\"\n    end\n  end\nend)\n\n# Add facts to working memory\nengine.add_fact(:stock, symbol: \"AAPL\", price: 145.50)\nengine.add_fact(:threshold, symbol: \"AAPL\", buy_below: 150.0)\n\n# Fire matching rules\nengine.run  # =&gt; BUY AAPL at 145.5\n</code></pre>"},{"location":"#why-rete","title":"Why RETE?","text":"<p>Traditional rule engines re-evaluate all rules against all facts on every change\u2014extremely inefficient. RETE solves this through:</p> <ol> <li>Network Compilation: Rules are compiled into a discrimination network that shares common patterns</li> <li>State Preservation: Partial matches are cached between cycles</li> <li>Incremental Updates: Only changed facts propagate through the network</li> <li>Unlinking Optimization (RETE): Empty nodes automatically disconnect to skip unnecessary work</li> </ol> <p>Result: Near-constant time per fact change, regardless of rule set size.</p>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#algorithmic-trading","title":"\ud83d\udcb9 Algorithmic Trading","text":"<p>Real-time market analysis, signal detection, and automated order execution with complex multi-condition rules.</p>"},{"location":"#industrial-automation","title":"\ud83c\udfed Industrial Automation","text":"<p>IoT sensor monitoring, predictive maintenance, and automated control systems with temporal reasoning.</p>"},{"location":"#expert-systems","title":"\ud83c\udfe5 Expert Systems","text":"<p>Medical diagnosis, troubleshooting assistants, and decision support systems with knowledge representation.</p>"},{"location":"#multi-agent-systems","title":"\ud83e\udd16 Multi-Agent Systems","text":"<p>Collaborative agents with shared blackboard memory for distributed problem-solving.</p>"},{"location":"#business-rules-engines","title":"\ud83d\udce7 Business Rules Engines","text":"<p>Policy enforcement, workflow automation, and compliance checking with auditable decision trails.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>KBS consists of several integrated components:</p> <ul> <li>RETE Engine: Core pattern matching and rule execution</li> <li>Working Memory: Transient in-memory fact storage</li> <li>Blackboard System: Persistent memory with SQLite/Redis backends</li> <li>DSL: Natural language rule definition syntax</li> <li>Message Queue: Priority-based inter-agent communication</li> <li>Audit Log: Complete history for compliance and debugging</li> </ul> <p>See Architecture Overview for details.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Installation - Add KBS to your project</li> <li>Quick Start - Build your first rule-based system in 5 minutes</li> <li>RETE Algorithm - Deep dive into how it works</li> <li>Writing Rules - Master the DSL and pattern matching</li> <li>Examples - Learn from real-world applications</li> </ol>"},{"location":"#performance","title":"Performance","text":"<p>KBS is built for production workloads:</p> <ul> <li>Fact Addition: O(N) where N = activated nodes (typically &lt;&lt; total nodes)</li> <li>Rule Firing: O(M) where M = matched tokens</li> <li>Memory Efficient: Network sharing reduces redundant storage</li> <li>Scalable: Tested with millions of facts, thousands of rules</li> </ul> <p>Benchmarks on M2 Max: - Add 100,000 facts: ~500ms - Match complex 5-condition rule: &lt;1ms per fact - Redis backend: 100x faster than SQLite for high-frequency updates</p>"},{"location":"#project-status","title":"Project Status","text":"<p>KBS is actively maintained:</p> <ul> <li>\u2705 Core RETE implementation complete</li> <li>\u2705 Persistent blackboard with multiple backends</li> <li>\u2705 Full DSL support with negation</li> <li>\u2705 Comprehensive test coverage</li> <li>\u2705 Real-world usage in trading systems</li> <li>\ud83d\udea7 Additional examples and guides in progress</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: madbomber/kbs</li> <li>RubyGems: kbs</li> <li>Issues: Report bugs or request features</li> <li>Discussions: Ask questions</li> </ul>"},{"location":"#license","title":"License","text":"<p>KBS is released under the MIT License.</p> <p>Copyright \u00a9 2024 Dewayne VanHoozer</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>The RETE algorithm was invented by Charles Forgy in 1979. This implementation draws inspiration from:</p> <ul> <li>Forgy, C. (1982). \"Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem\"</li> <li>Doorenbos, R. (1995). \"Production Matching for Large Learning Systems\" (RETE/UL)</li> <li>Modern production rule systems: Drools, Jess, CLIPS</li> </ul> <p>Ready to build intelligent systems? Start with the Quick Start Guide!</p>"},{"location":"DOCUMENTATION_STATUS/","title":"KBS Documentation Status","text":"<p>This document tracks the comprehensive documentation effort for the KBS gem.</p>"},{"location":"DOCUMENTATION_STATUS/#completed-documents","title":"\u2705 Completed Documents","text":""},{"location":"DOCUMENTATION_STATUS/#core-pages","title":"Core Pages","text":"<ul> <li> <code>index.md</code> - Main landing page with features, quick example, use cases</li> <li> <code>installation.md</code> - Installation guide with all backends</li> <li> <code>quick-start.md</code> - 5-minute getting started guide</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#architecture","title":"Architecture","text":"<ul> <li> <code>architecture/index.md</code> - Architecture overview with system layers</li> <li> <code>architecture/rete-algorithm.md</code> - COMPREHENSIVE deep dive into RETE (650+ lines)</li> <li> <code>architecture/blackboard.md</code> - COMPREHENSIVE blackboard pattern implementation</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#svg-graphics-created","title":"SVG Graphics Created","text":"<ul> <li> <code>assets/images/rete-network-layers.svg</code> - 3-layer RETE architecture</li> <li> <code>assets/images/fact-assertion-flow.svg</code> - Step-by-step fact propagation</li> <li> <code>assets/images/pattern-matching-trace.svg</code> - Complete negation example</li> <li> <code>assets/images/blackboard-architecture.svg</code> - Multi-agent blackboard system</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#supporting-files","title":"Supporting Files","text":"<ul> <li> <code>assets/css/custom.css</code> - Dark theme styling for SVGs and code</li> <li> <code>assets/js/mathjax.js</code> - Mathematical notation support</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#remaining-documents","title":"\ud83d\udccb Remaining Documents","text":""},{"location":"DOCUMENTATION_STATUS/#architecture_1","title":"Architecture","text":"<ul> <li> <code>architecture/network-structure.md</code> - Network compilation details, node types, optimization</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#guides-10-files","title":"Guides (10 files)","text":"<ul> <li> <code>guides/index.md</code> - Guides landing page</li> <li> <code>guides/getting-started.md</code> - Expanded tutorial</li> <li> <code>guides/writing-rules.md</code> - Rule authoring best practices</li> <li> <code>guides/dsl.md</code> - Complete DSL reference with all aliases</li> <li> <code>guides/facts.md</code> - Fact lifecycle, queries, updates</li> <li> <code>guides/pattern-matching.md</code> - Pattern syntax, predicates, operators</li> <li> <code>guides/variable-binding.md</code> - Variables, join tests, extraction</li> <li> <code>guides/negation.md</code> - Negation semantics, use cases, pitfalls</li> <li> <code>guides/blackboard-memory.md</code> - Persistence guide</li> <li> <code>guides/persistence.md</code> - Backend comparison, configuration</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#examples-3-files","title":"Examples (3 files)","text":"<ul> <li> <code>examples/index.md</code> - Examples landing page</li> <li> <code>examples/stock-trading.md</code> - Trading system walkthrough</li> <li> <code>examples/expert-systems.md</code> - Diagnostic expert system</li> <li> <code>examples/multi-agent.md</code> - Collaborative agents</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#advanced-4-files","title":"Advanced (4 files)","text":"<ul> <li> <code>advanced/index.md</code> - Advanced topics landing page</li> <li> <code>advanced/performance.md</code> - Profiling, optimization, benchmarks</li> <li> <code>advanced/custom-persistence.md</code> - Building custom stores</li> <li> <code>advanced/debugging.md</code> - Network inspection, tracing</li> <li> <code>advanced/testing.md</code> - Testing strategies for rules</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#api-reference-5-files","title":"API Reference (5 files)","text":"<ul> <li> <code>api/index.md</code> - API overview</li> <li> <code>api/rete-engine.md</code> - Engine class reference</li> <li> <code>api/facts.md</code> - Fact and Condition classes</li> <li> <code>api/rules.md</code> - Rule class reference</li> <li> <code>api/blackboard.md</code> - Blackboard::* classes</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#documentation-metrics","title":"\ud83d\udcca Documentation Metrics","text":"<ul> <li>Total Pages Planned: 35</li> <li>Pages Completed: 9 (26%)</li> <li>SVG Graphics Created: 4</li> <li>Total Lines Written: ~4,500+</li> <li>Estimated Remaining: ~6,000 lines</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#documentation-priorities","title":"\ud83c\udfaf Documentation Priorities","text":""},{"location":"DOCUMENTATION_STATUS/#high-priority-core-learning-path","title":"High Priority (Core Learning Path)","text":"<ol> <li><code>guides/writing-rules.md</code> - Essential for users</li> <li><code>guides/dsl.md</code> - Complete reference</li> <li><code>examples/stock-trading.md</code> - Real-world application</li> <li><code>architecture/network-structure.md</code> - Complete architecture coverage</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#medium-priority-advanced-users","title":"Medium Priority (Advanced Users)","text":"<ol> <li><code>advanced/performance.md</code> - Production optimization</li> <li><code>guides/pattern-matching.md</code> - Deep pattern knowledge</li> <li><code>examples/multi-agent.md</code> - Advanced architecture</li> <li><code>advanced/debugging.md</code> - Troubleshooting</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#lower-priority-reference","title":"Lower Priority (Reference)","text":"<ol> <li>API documentation files - Generated from code</li> <li>Remaining guides - Nice-to-have expansions</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#svg-graphics-roadmap","title":"\ud83c\udfa8 SVG Graphics Roadmap","text":""},{"location":"DOCUMENTATION_STATUS/#completed","title":"Completed","text":"<ul> <li>\u2705 RETE network layers diagram</li> <li>\u2705 Fact assertion flow diagram</li> <li>\u2705 Pattern matching trace (negation)</li> <li>\u2705 Blackboard architecture diagram</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#planned","title":"Planned","text":"<ul> <li> Network compilation process (for <code>network-structure.md</code>)</li> <li> Variable binding flow (for <code>guides/variable-binding.md</code>)</li> <li> Token tree structure (for <code>advanced/debugging.md</code>)</li> <li> Performance comparison chart (for <code>advanced/performance.md</code>)</li> <li> Multi-agent message flow (for <code>examples/multi-agent.md</code>)</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#content-guidelines","title":"\ud83d\udcdd Content Guidelines","text":""},{"location":"DOCUMENTATION_STATUS/#every-document-should-include","title":"Every Document Should Include:","text":"<ol> <li>Clear introduction - What this document covers</li> <li>Code examples - Real, runnable Ruby code</li> <li>Visual aids - SVG diagrams where helpful</li> <li>Cross-references - Links to related docs</li> <li>Implementation references - Line numbers for source code</li> <li>Best practices - Dos and don'ts</li> <li>Next steps - Where to go from here</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#svg-requirements","title":"SVG Requirements:","text":"<ul> <li>Dark theme with transparent background</li> <li>Consistent color palette:</li> <li>Purple <code>#bb86fc</code> - Core components/control</li> <li>Teal <code>#03dac6</code> - Data/storage</li> <li>Pink <code>#cf6679</code> - Agents/actions</li> <li>Gold <code>#ffd700</code> - Important/production</li> <li>Monospace fonts for code</li> <li>Clear arrows and flow indicators</li> <li>Legends where needed</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#next-session-tasks","title":"\ud83d\ude80 Next Session Tasks","text":"<p>Based on build warnings, create in this order:</p> <ol> <li>Stub all missing files (eliminate build warnings)</li> <li>Complete guides/ (highest user value)</li> <li>Complete examples/ (practical learning)</li> <li>Complete advanced/ (production users)</li> <li>Complete api/ (reference documentation)</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#documentation-style","title":"\ud83d\udcda Documentation Style","text":"<ul> <li>Tone: Technical but accessible</li> <li>Code: Always include complete, runnable examples</li> <li>Length: Comprehensive where needed (RETE doc is 650+ lines and that's perfect)</li> <li>Format: Markdown with code blocks, SVGs, tables</li> <li>Audience: Ruby developers new to rule-based systems</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#quality-standards","title":"\u2728 Quality Standards","text":"<ul> <li>\u2705 Every code example must be syntactically correct</li> <li>\u2705 Every link must point to existing files</li> <li>\u2705 Every SVG must have alt text/caption</li> <li>\u2705 Every technical term explained on first use</li> <li>\u2705 Implementation file references with line numbers</li> <li>\u2705 No orphan pages (all linked from somewhere)</li> </ul> <p>Last Updated: {{ date }} Documentation Lead: Claude Code Status: In Progress (26% complete)</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Ruby: 2.7 or higher</li> <li>SQLite3: For persistent blackboard memory (optional)</li> <li>Redis: For high-performance persistence (optional)</li> </ul>"},{"location":"installation/#installing-the-gem","title":"Installing the Gem","text":""},{"location":"installation/#from-rubygems","title":"From RubyGems","text":"<pre><code>gem install kbs\n</code></pre>"},{"location":"installation/#using-bundler","title":"Using Bundler","text":"<p>Add to your <code>Gemfile</code>:</p> <pre><code>gem 'kbs'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/madbomber/kbs.git\ncd kbs\nbundle install\nrake install\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"installation/#sqlite3-default-blackboard-backend","title":"SQLite3 (Default Blackboard Backend)","text":"<pre><code>gem install sqlite3\n</code></pre> <p>Or in your <code>Gemfile</code>:</p> <pre><code>gem 'sqlite3'\n</code></pre>"},{"location":"installation/#redis-high-performance-backend","title":"Redis (High-Performance Backend)","text":"<p>Install Redis server:</p> <pre><code># macOS\nbrew install redis\nbrew services start redis\n\n# Ubuntu/Debian\nsudo apt-get install redis-server\nsudo systemctl start redis\n\n# Docker\ndocker run -d -p 6379:6379 redis:latest\n</code></pre> <p>Install Ruby Redis gem:</p> <pre><code>gem install redis\n</code></pre> <p>Or in your <code>Gemfile</code>:</p> <pre><code>gem 'redis'\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify the installation:</p> <pre><code>require 'kbs'\n\nputs \"KBS version: #{KBS::VERSION}\"\n# =&gt; KBS version: 0.1.0\n\n# Test basic functionality\nengine = KBS::Engine.new\nengine.add_fact(:test, value: 42)\nputs \"\u2713 KBS is working!\"\n</code></pre>"},{"location":"installation/#development-setup","title":"Development Setup","text":"<p>For contributing or running tests:</p> <pre><code>git clone https://github.com/madbomber/kbs.git\ncd kbs\nbundle install\n\n# Run tests\nbundle exec rake test\n\n# Run examples\nbundle exec ruby examples/working_demo.rb\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#sqlite3-installation-issues","title":"SQLite3 Installation Issues","text":"<p>On macOS with M1/M2:</p> <pre><code>gem install sqlite3 -- --with-sqlite3-include=/opt/homebrew/opt/sqlite/include \\\n  --with-sqlite3-lib=/opt/homebrew/opt/sqlite/lib\n</code></pre> <p>On Ubuntu/Debian:</p> <pre><code>sudo apt-get install libsqlite3-dev\ngem install sqlite3\n</code></pre>"},{"location":"installation/#redis-connection-issues","title":"Redis Connection Issues","text":"<p>Check Redis is running:</p> <pre><code>redis-cli ping\n# =&gt; PONG\n</code></pre> <p>Test connection from Ruby:</p> <pre><code>require 'redis'\nredis = Redis.new(url: 'redis://localhost:6379/0')\nredis.ping\n# =&gt; \"PONG\"\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first rule-based system</li> <li>RETE Algorithm - Understand the engine</li> <li>Writing Rules - Master the DSL</li> <li>Examples - See real-world applications</li> </ul>"},{"location":"quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with KBS in 5 minutes.</p>"},{"location":"quick-start/#your-first-rule-based-system","title":"Your First Rule-Based System","text":"<p>Let's build a simple temperature monitoring system that alerts when readings are abnormal.</p>"},{"location":"quick-start/#step-1-create-the-engine","title":"Step 1: Create the Engine","text":"<pre><code>require 'kbs'\n\n# Create a RETE engine\nengine = KBS::Engine.new\n</code></pre>"},{"location":"quick-start/#step-2-define-rules","title":"Step 2: Define Rules","text":"<pre><code># Rule 1: Alert on high temperature\nhigh_temp_rule = KBS::Rule.new(\"high_temperature_alert\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { id: :id?, temp: :temp? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:temp?] &gt; 75\n      puts \"\u26a0\ufe0f  HIGH TEMP Alert: Sensor #{bindings[:id?]} at #{bindings[:temp?]}\u00b0F\"\n    end\n  end\nend\n\nengine.add_rule(high_temp_rule)\n\n# Rule 2: Alert when cooling system is offline AND temp is high\ncritical_rule = KBS::Rule.new(\"critical_condition\", priority: 10) do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n    KBS::Condition.new(:cooling, { id: :id?, status: \"offline\" })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:temp?] &gt; 75\n      puts \"\ud83d\udea8 CRITICAL: Sensor #{bindings[:id?]} at #{bindings[:temp?]}\u00b0F with cooling OFFLINE!\"\n    end\n  end\nend\n\nengine.add_rule(critical_rule)\n</code></pre>"},{"location":"quick-start/#step-3-add-facts","title":"Step 3: Add Facts","text":"<pre><code># Add sensor readings\nengine.add_fact(:sensor, id: \"room_101\", temp: 72)\nengine.add_fact(:sensor, id: \"server_rack\", temp: 82)\nengine.add_fact(:sensor, id: \"storage\", temp: 65)\n\n# Add cooling system status\nengine.add_fact(:cooling, id: \"server_rack\", status: \"offline\")\n</code></pre>"},{"location":"quick-start/#step-4-run-rules","title":"Step 4: Run Rules","text":"<pre><code>engine.run\n# Output:\n# =&gt; \u26a0\ufe0f  HIGH TEMP Alert: Sensor server_rack at 82\u00b0F\n# =&gt; \ud83d\udea8 CRITICAL: Sensor server_rack at 82\u00b0F with cooling OFFLINE!\n</code></pre>"},{"location":"quick-start/#understanding-what-happened","title":"Understanding What Happened","text":"<ol> <li>Engine Creation: <code>Engine.new</code> builds an empty RETE network</li> <li>Rule Addition: Rules are compiled into the discrimination network</li> <li>Fact Assertion: Facts propagate through the network, creating partial matches</li> <li>Rule Firing: <code>engine.run()</code> executes actions for all complete matches</li> </ol> <p>The critical rule fires because: - Sensor \"server_rack\" temp (82\u00b0F) &gt; 75 - Cooling system for \"server_rack\" is offline - Both conditions are joined on the same <code>:id?</code> variable</p>"},{"location":"quick-start/#using-negation","title":"Using Negation","text":"<p>Rules can match on the absence of facts:</p> <pre><code># Alert when sensor has NO recent reading\nstale_sensor_rule = KBS::Rule.new(\"stale_sensor\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor_registered, { id: :id? }),\n    # No recent reading exists (negation!)\n    KBS::Condition.new(:sensor, { id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    puts \"\u26a0\ufe0f  No reading from sensor #{bindings[:id?]}\"\n  end\nend\n\nengine.add_rule(stale_sensor_rule)\n\n# Register sensors\nengine.add_fact(:sensor_registered, id: \"room_101\")\nengine.add_fact(:sensor_registered, id: \"room_102\")\n\n# Only add reading for room_101\nengine.add_fact(:sensor, id: \"room_101\", temp: 70)\n\nengine.run\n# =&gt; \u26a0\ufe0f  No reading from sensor room_102\n</code></pre>"},{"location":"quick-start/#persistent-blackboard-memory","title":"Persistent Blackboard Memory","text":"<p>For production systems, use persistent storage:</p> <pre><code>require 'kbs/blackboard'\n\n# SQLite backend (default)\nengine = KBS::Blackboard::Engine.new(db_path: 'monitoring.db')\n\n# Facts survive restarts\nengine.add_fact(:sensor, id: \"room_101\", temp: 72)\n\n# Query historical data\nmemory = engine.working_memory\naudit = memory.audit_log.recent_changes(limit: 10)\n</code></pre>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":""},{"location":"quick-start/#learn-the-fundamentals","title":"Learn the Fundamentals","text":"<ul> <li>Writing Rules - Master rule syntax and patterns</li> <li>Pattern Matching - Understand how facts match conditions</li> <li>Variable Binding - Use variables to join conditions</li> <li>Negation - Express \"absence\" conditions</li> </ul>"},{"location":"quick-start/#explore-examples","title":"Explore Examples","text":"<ul> <li>Stock Trading - Build a trading signal system</li> <li>Expert Systems - Diagnostic and decision support</li> <li>Multi-Agent Systems - Collaborative problem-solving</li> </ul>"},{"location":"quick-start/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Blackboard Memory - Persistent storage and audit trails</li> <li>Performance Tuning - Optimize for production workloads</li> <li>Debugging - Trace rule execution and network state</li> </ul>"},{"location":"quick-start/#understand-the-engine","title":"Understand the Engine","text":"<ul> <li>RETE Algorithm - Deep dive into pattern matching</li> <li>Network Structure - How rules are compiled</li> <li>API Reference - Complete class documentation</li> </ul>"},{"location":"quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"quick-start/#time-based-rules","title":"Time-Based Rules","text":"<pre><code>rule = KBS::Rule.new(\"recent_spike\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:reading, {\n      sensor: :id?,\n      temp: :temp?,\n      timestamp: -&gt;(ts) { Time.now - ts &lt; 300 }  # Within 5 minutes\n    })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    puts \"Recent spike: #{bindings[:temp?]}\u00b0F\"\n  end\nend\n</code></pre>"},{"location":"quick-start/#threshold-comparison","title":"Threshold Comparison","text":"<pre><code>rule = KBS::Rule.new(\"above_threshold\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:reading, { sensor: :id?, value: :val? }),\n    KBS::Condition.new(:threshold, { sensor: :id?, max: :max? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:val?] &gt; bindings[:max?]\n      puts \"Threshold exceeded!\"\n    end\n  end\nend\n</code></pre>"},{"location":"quick-start/#state-machine","title":"State Machine","text":"<pre><code># Transition from \"init\" to \"ready\"\ntransition_rule = KBS::Rule.new(\"init_to_ready\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:state, { current: \"init\" }),\n    KBS::Condition.new(:sensor, { initialized: true }),\n    # No \"ready\" state exists yet\n    KBS::Condition.new(:state, { current: \"ready\" }, negated: true)\n  ]\n\n  r.action = lambda do |facts|\n    # Remove old state\n    engine.remove_fact(facts[0])\n    # Add new state\n    engine.add_fact(:state, current: \"ready\")\n  end\nend\n</code></pre>"},{"location":"quick-start/#tips","title":"Tips","text":"<ol> <li>Use descriptive rule names: Makes debugging easier</li> <li>Set priorities: Higher priority rules fire first</li> <li>Call <code>run()</code> explicitly: Rules don't fire automatically</li> <li>Leverage negation: Express \"when X is absent\" naturally</li> <li>Profile performance: Use <code>advanced/debugging.md</code> techniques</li> </ol> <p>Ready to dive deeper? Check out the Writing Rules Guide!</p>"},{"location":"advanced/","title":"Advanced Topics","text":"<p>techniques and optimizations.</p> <ul> <li>Performance Tuning - Optimize for production</li> <li>Custom Persistence - Build your own backend</li> <li>Debugging - Network inspection and tracing</li> <li>Testing Rules - Test strategies for rule-based systems</li> </ul>"},{"location":"advanced/custom-persistence/","title":"Custom Persistence","text":"<p>Implement custom storage backends for KBS by extending the <code>Store</code> interface. This guide covers implementing, testing, and optimizing custom persistence layers for PostgreSQL, MongoDB, or other databases.</p>"},{"location":"advanced/custom-persistence/#store-interface","title":"Store Interface","text":"<p>Custom stores must implement the <code>KBS::Blackboard::Persistence::Store</code> interface:</p> <pre><code>module KBS\n  module Blackboard\n    module Persistence\n      class Store\n        # Fact Operations\n        def save_fact(fact)\n          raise NotImplementedError\n        end\n\n        def load_facts(type = nil)\n          raise NotImplementedError\n        end\n\n        def update_fact(fact_id, attributes)\n          raise NotImplementedError\n        end\n\n        def delete_fact(fact_id)\n          raise NotImplementedError\n        end\n\n        # Message Queue Operations\n        def send_message(topic, content, priority:)\n          raise NotImplementedError\n        end\n\n        def pop_message(topic)\n          raise NotImplementedError\n        end\n\n        # Audit Operations\n        def log_fact_change(operation, fact, attributes = {})\n          raise NotImplementedError\n        end\n\n        def fact_history(fact_id)\n          raise NotImplementedError\n        end\n\n        def log_rule_firing(rule_name, fact_ids, bindings)\n          raise NotImplementedError\n        end\n\n        def rule_firings(rule_name: nil, limit: 100)\n          raise NotImplementedError\n        end\n\n        # Transaction Operations (optional)\n        def transaction\n          yield\n        end\n\n        def close\n          # Cleanup resources\n        end\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#postgresql-store","title":"PostgreSQL Store","text":""},{"location":"advanced/custom-persistence/#implementation","title":"Implementation","text":"<pre><code>require 'pg'\nrequire 'json'\n\nclass PostgresStore &lt; KBS::Blackboard::Persistence::Store\n  def initialize(connection_string:)\n    @conn = PG.connect(connection_string)\n    setup_tables\n  end\n\n  def setup_tables\n    @conn.exec &lt;&lt;~SQL\n      CREATE TABLE IF NOT EXISTS facts (\n        id UUID PRIMARY KEY,\n        fact_type VARCHAR(255) NOT NULL,\n        attributes JSONB NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW(),\n        updated_at TIMESTAMP DEFAULT NOW()\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_facts_type ON facts(fact_type);\n      CREATE INDEX IF NOT EXISTS idx_facts_attributes ON facts USING gin(attributes);\n\n      CREATE TABLE IF NOT EXISTS messages (\n        id SERIAL PRIMARY KEY,\n        topic VARCHAR(255) NOT NULL,\n        content JSONB NOT NULL,\n        priority INTEGER NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW()\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_messages_topic_priority\n        ON messages(topic, priority DESC);\n\n      CREATE TABLE IF NOT EXISTS audit_log (\n        id SERIAL PRIMARY KEY,\n        fact_id UUID NOT NULL,\n        operation VARCHAR(50) NOT NULL,\n        attributes JSONB,\n        timestamp TIMESTAMP DEFAULT NOW()\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_audit_fact_id ON audit_log(fact_id);\n\n      CREATE TABLE IF NOT EXISTS rule_firings (\n        id SERIAL PRIMARY KEY,\n        rule_name VARCHAR(255) NOT NULL,\n        fact_ids UUID[] NOT NULL,\n        bindings JSONB NOT NULL,\n        timestamp TIMESTAMP DEFAULT NOW()\n      );\n\n      CREATE INDEX IF NOT EXISTS idx_rule_firings_name ON rule_firings(rule_name);\n    SQL\n  end\n\n  # Fact Operations\n\n  def save_fact(fact)\n    @conn.exec_params(\n      \"INSERT INTO facts (id, fact_type, attributes) VALUES ($1, $2, $3)\",\n      [fact.id, fact.type.to_s, fact.attributes.to_json]\n    )\n\n    log_fact_change('add', fact, fact.attributes)\n    fact\n  end\n\n  def load_facts(type = nil)\n    query = if type\n      @conn.exec_params(\n        \"SELECT id, fact_type, attributes, created_at FROM facts WHERE fact_type = $1\",\n        [type.to_s]\n      )\n    else\n      @conn.exec(\"SELECT id, fact_type, attributes, created_at FROM facts\")\n    end\n\n    query.map do |row|\n      KBS::Blackboard::Fact.new(\n        row['fact_type'].to_sym,\n        JSON.parse(row['attributes'], symbolize_names: true),\n        id: row['id'],\n        created_at: Time.parse(row['created_at'])\n      )\n    end\n  end\n\n  def update_fact(fact_id, attributes)\n    @conn.exec_params(\n      \"UPDATE facts SET attributes = $1, updated_at = NOW() WHERE id = $2\",\n      [attributes.to_json, fact_id]\n    )\n\n    log_fact_change('update', fact_id, attributes)\n  end\n\n  def delete_fact(fact_id)\n    result = @conn.exec_params(\n      \"DELETE FROM facts WHERE id = $1 RETURNING attributes\",\n      [fact_id]\n    )\n\n    if result.ntuples &gt; 0\n      attrs = JSON.parse(result[0]['attributes'], symbolize_names: true)\n      log_fact_change('delete', fact_id, attrs)\n    end\n  end\n\n  # Message Queue Operations\n\n  def send_message(topic, content, priority:)\n    @conn.exec_params(\n      \"INSERT INTO messages (topic, content, priority) VALUES ($1, $2, $3)\",\n      [topic.to_s, content.to_json, priority]\n    )\n  end\n\n  def pop_message(topic)\n    # Atomic pop using DELETE RETURNING\n    result = @conn.exec_params(&lt;&lt;~SQL, [topic.to_s])\n      DELETE FROM messages\n      WHERE id = (\n        SELECT id FROM messages\n        WHERE topic = $1\n        ORDER BY priority DESC, created_at ASC\n        LIMIT 1\n        FOR UPDATE SKIP LOCKED\n      )\n      RETURNING content, priority\n    SQL\n\n    return nil if result.ntuples == 0\n\n    {\n      content: JSON.parse(result[0]['content'], symbolize_names: true),\n      priority: result[0]['priority'].to_i\n    }\n  end\n\n  # Audit Operations\n\n  def log_fact_change(operation, fact_or_id, attributes)\n    fact_id = fact_or_id.is_a?(String) ? fact_or_id : fact_or_id.id\n\n    @conn.exec_params(\n      \"INSERT INTO audit_log (fact_id, operation, attributes) VALUES ($1, $2, $3)\",\n      [fact_id, operation, attributes.to_json]\n    )\n  end\n\n  def fact_history(fact_id)\n    result = @conn.exec_params(\n      \"SELECT operation, attributes, timestamp FROM audit_log WHERE fact_id = $1 ORDER BY timestamp\",\n      [fact_id]\n    )\n\n    result.map do |row|\n      {\n        operation: row['operation'],\n        attributes: JSON.parse(row['attributes'], symbolize_names: true),\n        timestamp: Time.parse(row['timestamp'])\n      }\n    end\n  end\n\n  def log_rule_firing(rule_name, fact_ids, bindings)\n    @conn.exec_params(\n      \"INSERT INTO rule_firings (rule_name, fact_ids, bindings) VALUES ($1, $2, $3)\",\n      [rule_name, \"{#{fact_ids.join(',')}}\", bindings.to_json]\n    )\n  end\n\n  def rule_firings(rule_name: nil, limit: 100)\n    query = if rule_name\n      @conn.exec_params(\n        \"SELECT rule_name, fact_ids, bindings, timestamp FROM rule_firings WHERE rule_name = $1 ORDER BY timestamp DESC LIMIT $2\",\n        [rule_name, limit]\n      )\n    else\n      @conn.exec_params(\n        \"SELECT rule_name, fact_ids, bindings, timestamp FROM rule_firings ORDER BY timestamp DESC LIMIT $1\",\n        [limit]\n      )\n    end\n\n    query.map do |row|\n      {\n        rule_name: row['rule_name'],\n        fact_ids: row['fact_ids'].gsub(/[{}]/, '').split(','),\n        bindings: JSON.parse(row['bindings'], symbolize_names: true),\n        timestamp: Time.parse(row['timestamp'])\n      }\n    end\n  end\n\n  # Transaction Support\n\n  def transaction\n    @conn.exec(\"BEGIN\")\n    yield\n    @conn.exec(\"COMMIT\")\n  rescue =&gt; e\n    @conn.exec(\"ROLLBACK\")\n    raise e\n  end\n\n  def close\n    @conn.close if @conn\n  end\nend\n\n# Usage\nstore = PostgresStore.new(\n  connection_string: \"postgresql://localhost/kbs_production\"\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre>"},{"location":"advanced/custom-persistence/#mongodb-store","title":"MongoDB Store","text":""},{"location":"advanced/custom-persistence/#implementation_1","title":"Implementation","text":"<pre><code>require 'mongo'\nrequire 'securerandom'\n\nclass MongoStore &lt; KBS::Blackboard::Persistence::Store\n  def initialize(url:, database: 'kbs')\n    @client = Mongo::Client.new(url)\n    @db = @client.use(database)\n    setup_collections\n  end\n\n  def setup_collections\n    # Facts collection\n    @facts = @db[:facts]\n    @facts.indexes.create_one({ fact_type: 1 })\n    @facts.indexes.create_one({ created_at: 1 })\n\n    # Messages collection\n    @messages = @db[:messages]\n    @messages.indexes.create_one({ topic: 1, priority: -1, created_at: 1 })\n\n    # Audit log\n    @audit = @db[:audit_log]\n    @audit.indexes.create_one({ fact_id: 1, timestamp: 1 })\n\n    # Rule firings\n    @rule_firings = @db[:rule_firings]\n    @rule_firings.indexes.create_one({ rule_name: 1, timestamp: -1 })\n  end\n\n  # Fact Operations\n\n  def save_fact(fact)\n    doc = {\n      _id: fact.id,\n      fact_type: fact.type.to_s,\n      attributes: fact.attributes,\n      created_at: Time.now,\n      updated_at: Time.now\n    }\n\n    @facts.insert_one(doc)\n\n    log_fact_change('add', fact, fact.attributes)\n    fact\n  end\n\n  def load_facts(type = nil)\n    query = type ? { fact_type: type.to_s } : {}\n\n    @facts.find(query).map do |doc|\n      KBS::Blackboard::Fact.new(\n        doc['fact_type'].to_sym,\n        doc['attributes'].transform_keys(&amp;:to_sym),\n        id: doc['_id'],\n        created_at: doc['created_at']\n      )\n    end\n  end\n\n  def update_fact(fact_id, attributes)\n    @facts.update_one(\n      { _id: fact_id },\n      { '$set' =&gt; { attributes: attributes, updated_at: Time.now } }\n    )\n\n    log_fact_change('update', fact_id, attributes)\n  end\n\n  def delete_fact(fact_id)\n    doc = @facts.find_one_and_delete({ _id: fact_id })\n\n    if doc\n      log_fact_change('delete', fact_id, doc['attributes'])\n    end\n  end\n\n  # Message Queue Operations\n\n  def send_message(topic, content, priority:)\n    @messages.insert_one({\n      topic: topic.to_s,\n      content: content,\n      priority: priority,\n      created_at: Time.now\n    })\n  end\n\n  def pop_message(topic)\n    # Find highest priority message\n    doc = @messages.find_one_and_delete(\n      { topic: topic.to_s },\n      sort: { priority: -1, created_at: 1 }\n    )\n\n    return nil unless doc\n\n    {\n      content: doc['content'].transform_keys(&amp;:to_sym),\n      priority: doc['priority']\n    }\n  end\n\n  # Audit Operations\n\n  def log_fact_change(operation, fact_or_id, attributes)\n    fact_id = fact_or_id.is_a?(String) ? fact_or_id : fact_or_id.id\n\n    @audit.insert_one({\n      fact_id: fact_id,\n      operation: operation,\n      attributes: attributes,\n      timestamp: Time.now\n    })\n  end\n\n  def fact_history(fact_id)\n    @audit.find({ fact_id: fact_id })\n          .sort(timestamp: 1)\n          .map do |doc|\n      {\n        operation: doc['operation'],\n        attributes: doc['attributes'].transform_keys(&amp;:to_sym),\n        timestamp: doc['timestamp']\n      }\n    end\n  end\n\n  def log_rule_firing(rule_name, fact_ids, bindings)\n    @rule_firings.insert_one({\n      rule_name: rule_name,\n      fact_ids: fact_ids,\n      bindings: bindings,\n      timestamp: Time.now\n    })\n  end\n\n  def rule_firings(rule_name: nil, limit: 100)\n    query = rule_name ? { rule_name: rule_name } : {}\n\n    @rule_firings.find(query)\n                 .sort(timestamp: -1)\n                 .limit(limit)\n                 .map do |doc|\n      {\n        rule_name: doc['rule_name'],\n        fact_ids: doc['fact_ids'],\n        bindings: doc['bindings'].transform_keys(&amp;:to_sym),\n        timestamp: doc['timestamp']\n      }\n    end\n  end\n\n  # Transaction Support (MongoDB 4.0+)\n\n  def transaction\n    session = @client.start_session\n\n    session.with_transaction do\n      yield\n    end\n  ensure\n    session.end_session if session\n  end\n\n  def close\n    @client.close if @client\n  end\nend\n\n# Usage\nstore = MongoStore.new(\n  url: 'mongodb://localhost:27017',\n  database: 'kbs_production'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre>"},{"location":"advanced/custom-persistence/#testing-custom-stores","title":"Testing Custom Stores","text":""},{"location":"advanced/custom-persistence/#test-suite","title":"Test Suite","text":"<pre><code>require 'minitest/autorun'\n\nclass TestCustomStore &lt; Minitest::Test\n  def setup\n    @store = MyCustomStore.new\n  end\n\n  def teardown\n    @store.close\n  end\n\n  def test_save_and_load_facts\n    fact = KBS::Blackboard::Fact.new(:test, { value: 42 })\n\n    @store.save_fact(fact)\n    loaded = @store.load_facts(:test)\n\n    assert_equal 1, loaded.size\n    assert_equal 42, loaded.first[:value]\n  end\n\n  def test_load_facts_by_type\n    @store.save_fact(KBS::Blackboard::Fact.new(:type_a, { value: 1 }))\n    @store.save_fact(KBS::Blackboard::Fact.new(:type_b, { value: 2 }))\n\n    type_a_facts = @store.load_facts(:type_a)\n\n    assert_equal 1, type_a_facts.size\n    assert_equal :type_a, type_a_facts.first.type\n  end\n\n  def test_update_fact\n    fact = KBS::Blackboard::Fact.new(:test, { value: 1 })\n    @store.save_fact(fact)\n\n    @store.update_fact(fact.id, { value: 2 })\n\n    loaded = @store.load_facts(:test)\n    assert_equal 2, loaded.first[:value]\n  end\n\n  def test_delete_fact\n    fact = KBS::Blackboard::Fact.new(:test, { value: 1 })\n    @store.save_fact(fact)\n\n    @store.delete_fact(fact.id)\n\n    loaded = @store.load_facts(:test)\n    assert_empty loaded\n  end\n\n  def test_message_queue\n    @store.send_message(:alerts, { text: \"High priority\" }, priority: 100)\n    @store.send_message(:alerts, { text: \"Low priority\" }, priority: 10)\n\n    # Pop should return highest priority\n    msg = @store.pop_message(:alerts)\n\n    assert_equal \"High priority\", msg[:content][:text]\n    assert_equal 100, msg[:priority]\n\n    # Next pop gets lower priority\n    msg = @store.pop_message(:alerts)\n    assert_equal \"Low priority\", msg[:content][:text]\n  end\n\n  def test_message_queue_empty\n    msg = @store.pop_message(:nonexistent)\n    assert_nil msg\n  end\n\n  def test_fact_audit_trail\n    fact = KBS::Blackboard::Fact.new(:test, { value: 1 })\n\n    @store.save_fact(fact)\n    @store.update_fact(fact.id, { value: 2 })\n    @store.delete_fact(fact.id)\n\n    history = @store.fact_history(fact.id)\n\n    assert_equal 3, history.size\n    assert_equal \"add\", history[0][:operation]\n    assert_equal \"update\", history[1][:operation]\n    assert_equal \"delete\", history[2][:operation]\n  end\n\n  def test_rule_firing_log\n    @store.log_rule_firing(\"test_rule\", [\"fact1\", \"fact2\"], { var: :value })\n\n    firings = @store.rule_firings(rule_name: \"test_rule\")\n\n    assert_equal 1, firings.size\n    assert_equal \"test_rule\", firings.first[:rule_name]\n    assert_equal [\"fact1\", \"fact2\"], firings.first[:fact_ids]\n  end\n\n  def test_transactions\n    fact1 = KBS::Blackboard::Fact.new(:test, { value: 1 })\n    fact2 = KBS::Blackboard::Fact.new(:test, { value: 2 })\n\n    # Successful transaction\n    @store.transaction do\n      @store.save_fact(fact1)\n      @store.save_fact(fact2)\n    end\n\n    assert_equal 2, @store.load_facts(:test).size\n\n    # Failed transaction\n    begin\n      @store.transaction do\n        @store.save_fact(KBS::Blackboard::Fact.new(:test, { value: 3 }))\n        raise \"Rollback!\"\n      end\n    rescue\n      # Expected\n    end\n\n    # Should still be 2 facts (transaction rolled back)\n    assert_equal 2, @store.load_facts(:test).size\n  end\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/custom-persistence/#1-connection-pooling","title":"1. Connection Pooling","text":"<pre><code>class PooledPostgresStore &lt; PostgresStore\n  def initialize(connection_string:, pool_size: 10)\n    @pool = ConnectionPool.new(size: pool_size) do\n      PG.connect(connection_string)\n    end\n\n    # Setup using one connection\n    @pool.with { |conn| setup_tables_with_conn(conn) }\n  end\n\n  def save_fact(fact)\n    @pool.with do |conn|\n      conn.exec_params(\n        \"INSERT INTO facts (id, fact_type, attributes) VALUES ($1, $2, $3)\",\n        [fact.id, fact.type.to_s, fact.attributes.to_json]\n      )\n    end\n\n    fact\n  end\n\n  # ... other methods using @pool.with { |conn| ... }\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>def save_facts(facts)\n  @conn.exec(\"BEGIN\")\n\n  facts.each do |fact|\n    save_fact(fact)\n  end\n\n  @conn.exec(\"COMMIT\")\nrescue =&gt; e\n  @conn.exec(\"ROLLBACK\")\n  raise e\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#3-indexing","title":"3. Indexing","text":"<pre><code>def optimize_indexes\n  # Add indexes for common queries\n  @conn.exec(&lt;&lt;~SQL)\n    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_facts_created\n      ON facts(created_at DESC);\n\n    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_messages_topic_priority\n      ON messages(topic, priority DESC)\n      WHERE topic IN ('alerts', 'critical');\n\n    -- JSONB indexes for attribute queries\n    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_facts_value\n      ON facts((attributes-&gt;&gt;'value'));\n  SQL\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#4-caching","title":"4. Caching","text":"<pre><code>class CachedStore &lt; KBS::Blackboard::Persistence::Store\n  def initialize(underlying_store, cache_ttl: 300)\n    @store = underlying_store\n    @cache = {}\n    @cache_ttl = cache_ttl\n  end\n\n  def load_facts(type = nil)\n    cache_key = \"facts:#{type}\"\n\n    if cached = @cache[cache_key]\n      return cached[:data] if Time.now - cached[:timestamp] &lt; @cache_ttl\n    end\n\n    facts = @store.load_facts(type)\n\n    @cache[cache_key] = {\n      data: facts,\n      timestamp: Time.now\n    }\n\n    facts\n  end\n\n  def save_fact(fact)\n    result = @store.save_fact(fact)\n\n    # Invalidate cache\n    @cache.delete(\"facts:#{fact.type}\")\n    @cache.delete(\"facts:\")\n\n    result\n  end\n\n  # Delegate other methods\n  def method_missing(method, *args, &amp;block)\n    @store.send(method, *args, &amp;block)\n  end\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-persistence/#1-handle-errors-gracefully","title":"1. Handle Errors Gracefully","text":"<pre><code>def save_fact(fact)\n  retries = 0\n\n  begin\n    @conn.exec_params(...)\n  rescue PG::ConnectionBad =&gt; e\n    retries += 1\n\n    if retries &lt; 3\n      reconnect\n      retry\n    else\n      raise e\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#2-use-prepared-statements","title":"2. Use Prepared Statements","text":"<pre><code>def initialize(connection_string:)\n  super\n  @conn.prepare('save_fact',\n    \"INSERT INTO facts (id, fact_type, attributes) VALUES ($1, $2, $3)\")\nend\n\ndef save_fact(fact)\n  @conn.exec_prepared('save_fact', [fact.id, fact.type.to_s, fact.attributes.to_json])\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#3-implement-health-checks","title":"3. Implement Health Checks","text":"<pre><code>def healthy?\n  @conn.exec(\"SELECT 1\")\n  true\nrescue =&gt; e\n  false\nend\n</code></pre>"},{"location":"advanced/custom-persistence/#next-steps","title":"Next Steps","text":"<ul> <li>Persistence Guide - Choosing backends</li> <li>Testing Guide - Testing custom stores</li> <li>Performance Guide - Optimizing queries</li> <li>API Reference - Complete API documentation</li> </ul> <p>Custom stores enable KBS to work with any database. Implement the Store interface and test thoroughly.</p>"},{"location":"advanced/debugging/","title":"Debugging","text":"<p>Debug KBS applications using network visualization, token tracing, fact inspection, and rule execution logging. This guide provides tools and techniques to understand rule behavior and diagnose issues.</p>"},{"location":"advanced/debugging/#debugging-overview","title":"Debugging Overview","text":"<p>Common debugging scenarios:</p> <ol> <li>Rules not firing - Conditions don't match expected facts</li> <li>Unexpected rule firing - Rules fire when they shouldn't</li> <li>Performance issues - Slow rule execution</li> <li>Incorrect bindings - Variables bound to wrong values</li> <li>Network structure - Understanding compilation</li> </ol>"},{"location":"advanced/debugging/#enable-debug-output","title":"Enable Debug Output","text":""},{"location":"advanced/debugging/#basic-logging","title":"Basic Logging","text":"<pre><code>require 'kbs'\n\nengine = KBS::Engine.new\n\n# Enable debug output\nengine.instance_variable_set(:@debug, true)\n\n# Or create debug wrapper\nclass DebugEngine &lt; KBS::Engine\n  def add_fact(type, attributes = {})\n    fact = super\n    puts \"[FACT ADDED] #{fact.type}: #{fact.attributes.inspect}\"\n    fact\n  end\n\n  def remove_fact(fact)\n    puts \"[FACT REMOVED] #{fact.type}: #{fact.attributes.inspect}\"\n    super\n  end\nend\n</code></pre>"},{"location":"advanced/debugging/#rule-execution-logging","title":"Rule Execution Logging","text":"<pre><code>class LoggingEngine &lt; KBS::Engine\n  def initialize\n    super\n    @rule_log = []\n  end\n\n  def run\n    puts \"\\n=== Engine Run Started ===\"\n    puts \"Facts: #{facts.size}\"\n    puts \"Rules: #{@rules.size}\"\n\n    result = super\n\n    puts \"\\n=== Engine Run Completed ===\"\n    puts \"Rules fired: #{@rule_log.size}\"\n    @rule_log.each_with_index do |entry, i|\n      puts \"  #{i + 1}. #{entry[:rule]} (#{entry[:timestamp]})\"\n    end\n\n    result\n  end\n\n  attr_reader :rule_log\nend\n</code></pre>"},{"location":"advanced/debugging/#fact-inspection","title":"Fact Inspection","text":""},{"location":"advanced/debugging/#inspect-current-facts","title":"Inspect Current Facts","text":"<pre><code>def inspect_facts(engine)\n  puts \"\\n=== Current Facts ===\"\n\n  # Group by type\n  facts_by_type = engine.facts.group_by(&amp;:type)\n\n  facts_by_type.each do |type, facts|\n    puts \"\\n#{type} (#{facts.size}):\"\n    facts.each_with_index do |fact, i|\n      puts \"  #{i + 1}. #{fact.attributes.inspect}\"\n      if fact.is_a?(KBS::Blackboard::Fact)\n        puts \"     ID: #{fact.id}\"\n        puts \"     Created: #{fact.created_at}\"\n      end\n    end\n  end\n\n  puts \"\\nTotal facts: #{engine.facts.size}\"\nend\n\n# Usage\ninspect_facts(engine)\n</code></pre>"},{"location":"advanced/debugging/#query-fact-history-blackboard","title":"Query Fact History (Blackboard)","text":"<pre><code>def inspect_fact_history(engine, fact_id)\n  return unless engine.is_a?(KBS::Blackboard::Engine)\n\n  puts \"\\n=== Fact History: #{fact_id} ===\"\n\n  history = engine.fact_history(fact_id)\n\n  history.each do |entry|\n    puts \"\\n#{entry[:timestamp]}\"\n    puts \"  Operation: #{entry[:operation]}\"\n    puts \"  Attributes: #{entry[:attributes].inspect}\"\n  end\nend\n</code></pre>"},{"location":"advanced/debugging/#find-facts-by-criteria","title":"Find Facts by Criteria","text":"<pre><code>def find_facts(engine, **criteria)\n  results = engine.facts.select do |fact|\n    criteria.all? do |key, value|\n      case key\n      when :type\n        fact.type == value\n      else\n        fact[key] == value\n      end\n    end\n  end\n\n  puts \"\\n=== Found #{results.size} facts ===\"\n  results.each do |fact|\n    puts \"#{fact.type}: #{fact.attributes.inspect}\"\n  end\n\n  results\nend\n\n# Usage\nfind_facts(engine, type: :sensor, location: \"bedroom\")\nfind_facts(engine, type: :alert, severity: \"critical\")\n</code></pre>"},{"location":"advanced/debugging/#rule-debugging","title":"Rule Debugging","text":""},{"location":"advanced/debugging/#trace-rule-execution","title":"Trace Rule Execution","text":"<pre><code>class RuleTracer\n  def initialize(engine)\n    @engine = engine\n    @traces = []\n  end\n\n  def wrap_rules\n    @engine.instance_variable_get(:@rules).each do |rule|\n      wrap_rule(rule)\n    end\n  end\n\n  def wrap_rule(rule)\n    original_action = rule.action\n\n    rule.action = lambda do |facts, bindings|\n      trace = {\n        rule: rule.name,\n        timestamp: Time.now,\n        facts: facts.map { |f| { type: f.type, attrs: f.attributes } },\n        bindings: bindings.dup\n      }\n\n      puts \"\\n[RULE FIRING] #{rule.name}\"\n      puts \"  Facts: #{facts.map(&amp;:type).join(', ')}\"\n      puts \"  Bindings: #{bindings.inspect}\"\n\n      result = original_action.call(facts, bindings)\n\n      trace[:duration] = (Time.now - trace[:timestamp])\n      @traces &lt;&lt; trace\n\n      puts \"  Duration: #{trace[:duration]}s\"\n\n      result\n    end\n  end\n\n  attr_reader :traces\nend\n\n# Usage\ntracer = RuleTracer.new(engine)\ntracer.wrap_rules\nengine.run\nputs \"\\nTotal rule firings: #{tracer.traces.size}\"\n</code></pre>"},{"location":"advanced/debugging/#test-individual-conditions","title":"Test Individual Conditions","text":"<pre><code>def test_condition(engine, condition)\n  puts \"\\n=== Testing Condition ===\"\n  puts \"Type: #{condition.pattern[:type]}\"\n  puts \"Pattern: #{condition.pattern.inspect}\"\n\n  # Find matching facts\n  matches = engine.facts.select do |fact|\n    fact.matches?(condition.pattern)\n  end\n\n  puts \"\\nMatching facts: #{matches.size}\"\n  matches.each do |fact|\n    puts \"  #{fact.attributes.inspect}\"\n\n    # Test predicate if present\n    if condition.predicate\n      predicate_result = condition.predicate.call(fact)\n      puts \"  Predicate: #{predicate_result}\"\n    end\n  end\n\n  matches\nend\n\n# Usage\ncondition = KBS::Condition.new(:sensor, {\n  type: \"temperature\",\n  value: :v?\n}, predicate: lambda { |f| f[:value] &gt; 25 })\n\ntest_condition(engine, condition)\n</code></pre>"},{"location":"advanced/debugging/#why-did-rule-fire","title":"Why Did Rule Fire?","text":"<pre><code>def why_rule_fired(engine, rule_name)\n  rule = engine.instance_variable_get(:@rules).find { |r| r.name == rule_name }\n\n  return unless rule\n\n  puts \"\\n=== Why '#{rule_name}' Fired ===\"\n\n  # Check each condition\n  rule.conditions.each_with_index do |condition, i|\n    puts \"\\nCondition #{i + 1}: #{condition.pattern[:type]}\"\n    puts \"  Pattern: #{condition.pattern.inspect}\"\n    puts \"  Negated: #{condition.negated?}\"\n\n    matches = engine.facts.select { |f| f.matches?(condition.pattern) }\n\n    if condition.predicate\n      matches = matches.select { |f| condition.predicate.call(f) }\n    end\n\n    puts \"  Matches: #{matches.size} facts\"\n    matches.each do |fact|\n      puts \"    - #{fact.attributes.inspect}\"\n    end\n  end\nend\n</code></pre>"},{"location":"advanced/debugging/#why-didnt-rule-fire","title":"Why Didn't Rule Fire?","text":"<pre><code>def why_rule_didnt_fire(engine, rule_name)\n  rule = engine.instance_variable_get(:@rules).find { |r| r.name == rule_name }\n\n  return unless rule\n\n  puts \"\\n=== Why '#{rule_name}' Didn't Fire ===\"\n\n  # Check each condition\n  failing_condition = nil\n\n  rule.conditions.each_with_index do |condition, i|\n    puts \"\\nCondition #{i + 1}: #{condition.pattern[:type]}\"\n\n    matches = engine.facts.select { |f| f.matches?(condition.pattern) }\n\n    if condition.negated?\n      puts \"  Negated condition\"\n      if matches.empty?\n        puts \"  \u2713 PASSED (no matching facts)\"\n      else\n        puts \"  \u2717 FAILED (#{matches.size} matching facts found, but should be absent)\"\n        failing_condition = i\n        matches.each do |fact|\n          puts \"    Blocking fact: #{fact.attributes.inspect}\"\n        end\n      end\n    else\n      if matches.empty?\n        puts \"  \u2717 FAILED (no matching facts)\"\n        failing_condition = i\n\n        # Suggest similar facts\n        similar = engine.facts.select { |f| f.type == condition.pattern[:type] }\n        if similar.any?\n          puts \"  Similar facts (#{similar.size}):\"\n          similar.first(3).each do |fact|\n            puts \"    - #{fact.attributes.inspect}\"\n          end\n        end\n      else\n        # Check predicate\n        if condition.predicate\n          pred_matches = matches.select { |f| condition.predicate.call(f) }\n          if pred_matches.empty?\n            puts \"  \u2717 FAILED (#{matches.size} facts match pattern, but predicate failed)\"\n            failing_condition = i\n            matches.first(3).each do |fact|\n              puts \"    - #{fact.attributes.inspect} (predicate: false)\"\n            end\n          else\n            puts \"  \u2713 PASSED (#{pred_matches.size} facts)\"\n          end\n        else\n          puts \"  \u2713 PASSED (#{matches.size} facts)\"\n        end\n      end\n    end\n\n    break if failing_condition\n  end\n\n  if failing_condition\n    puts \"\\n\u26a0\ufe0f  Rule failed at condition #{failing_condition + 1}\"\n  else\n    puts \"\\n\u2713 All conditions passed (rule should fire on next run)\"\n  end\nend\n\n# Usage\nwhy_rule_didnt_fire(engine, \"detect_high_temperature\")\n</code></pre>"},{"location":"advanced/debugging/#network-visualization","title":"Network Visualization","text":""},{"location":"advanced/debugging/#print-network-structure","title":"Print Network Structure","text":"<pre><code>def visualize_network(engine)\n  puts \"\\n=== RETE Network Structure ===\"\n\n  # Alpha network\n  puts \"\\nALPHA NETWORK:\"\n  alpha_memories = []\n\n  engine.instance_eval do\n    @alpha_network.each do |pattern, memory|\n      puts \"  #{pattern.inspect}\"\n      puts \"    Items: #{memory.items.size}\"\n      alpha_memories &lt;&lt; memory\n    end\n  end\n\n  # Beta network\n  puts \"\\nBETA NETWORK:\"\n  # Simplified - actual inspection depends on implementation\n\n  puts \"\\nSTATISTICS:\"\n  puts \"  Alpha memories: #{alpha_memories.size}\"\n  puts \"  Total facts: #{engine.facts.size}\"\n  puts \"  Rules: #{engine.instance_variable_get(:@rules).size}\"\nend\n</code></pre>"},{"location":"advanced/debugging/#graphviz-export","title":"Graphviz Export","text":"<pre><code>def export_to_graphviz(engine, filename = \"network.dot\")\n  File.open(filename, 'w') do |f|\n    f.puts \"digraph RETE {\"\n    f.puts \"  rankdir=TB;\"\n    f.puts \"  node [shape=box];\"\n\n    # Alpha nodes\n    f.puts \"\\n  // Alpha Network\"\n    engine.instance_eval do\n      @alpha_network.each_with_index do |(pattern, memory), i|\n        node_id = \"alpha_#{i}\"\n        label = \"#{pattern[:type]}\\\\n#{memory.items.size} facts\"\n        f.puts \"  #{node_id} [label=\\\"#{label}\\\", style=filled, fillcolor=lightblue];\"\n      end\n    end\n\n    # Production nodes\n    f.puts \"\\n  // Production Nodes\"\n    engine.instance_variable_get(:@rules).each_with_index do |rule, i|\n      node_id = \"rule_#{i}\"\n      label = \"#{rule.name}\\\\n#{rule.priority}\"\n      f.puts \"  #{node_id} [label=\\\"#{label}\\\", style=filled, fillcolor=lightgreen];\"\n    end\n\n    # Edges (simplified)\n    # ...\n\n    f.puts \"}\"\n  end\n\n  puts \"Network exported to #{filename}\"\n  puts \"Render with: dot -Tpng #{filename} -o network.png\"\nend\n\n# Usage\nexport_to_graphviz(engine)\n</code></pre>"},{"location":"advanced/debugging/#token-tracing","title":"Token Tracing","text":""},{"location":"advanced/debugging/#trace-token-propagation","title":"Trace Token Propagation","text":"<pre><code>class TokenTracer\n  def initialize\n    @trace = []\n  end\n\n  def log_activation(node_type, node_id, token)\n    @trace &lt;&lt; {\n      timestamp: Time.now,\n      node_type: node_type,\n      node_id: node_id,\n      token: token.inspect\n    }\n\n    puts \"[#{node_type}] #{node_id}: #{token.inspect}\"\n  end\n\n  def print_trace\n    puts \"\\n=== Token Trace ===\"\n    @trace.each_with_index do |entry, i|\n      puts \"\\n#{i + 1}. [#{entry[:node_type]}] #{entry[:node_id]}\"\n      puts \"   Time: #{entry[:timestamp]}\"\n      puts \"   Token: #{entry[:token]}\"\n    end\n  end\n\n  attr_reader :trace\nend\n\n# Usage: Instrument nodes\ntracer = TokenTracer.new\n\n# Wrap alpha activation\nalpha_memory.define_singleton_method(:right_activate) do |fact|\n  tracer.log_activation(\"AlphaMemory\", object_id, fact)\n  super(fact)\nend\n</code></pre>"},{"location":"advanced/debugging/#interactive-debugging","title":"Interactive Debugging","text":""},{"location":"advanced/debugging/#debug-console","title":"Debug Console","text":"<pre><code>class DebugConsole\n  def initialize(engine)\n    @engine = engine\n  end\n\n  def start\n    loop do\n      print \"\\nkbs&gt; \"\n      input = gets.chomp\n\n      break if input == \"exit\"\n\n      case input\n      when \"facts\"\n        inspect_facts(@engine)\n      when \"rules\"\n        list_rules\n      when \"run\"\n        @engine.run\n        puts \"Engine ran successfully\"\n      when /^add (\\w+) (.+)$/\n        type = $1.to_sym\n        attrs = eval($2)  # UNSAFE: eval user input (for demo only)\n        @engine.add_fact(type, attrs)\n        puts \"Fact added\"\n      when /^remove (\\d+)$/\n        fact = @engine.facts[$1.to_i]\n        @engine.remove_fact(fact) if fact\n        puts \"Fact removed\"\n      when /^why (.+)$/\n        why_rule_didnt_fire(@engine, $1)\n      when \"help\"\n        print_help\n      else\n        puts \"Unknown command: #{input}\"\n        print_help\n      end\n    end\n  end\n\n  def list_rules\n    puts \"\\n=== Rules ===\"\n    @engine.instance_variable_get(:@rules).each_with_index do |rule, i|\n      puts \"#{i}. #{rule.name} (priority: #{rule.priority}, conditions: #{rule.conditions.size})\"\n    end\n  end\n\n  def print_help\n    puts &lt;&lt;~HELP\n\n      Commands:\n        facts              - List all facts\n        rules              - List all rules\n        run                - Run engine\n        add TYPE {ATTRS}   - Add fact\n        remove INDEX       - Remove fact\n        why RULE_NAME      - Explain why rule didn't fire\n        exit               - Exit console\n        help               - Show this help\n\n    HELP\n  end\nend\n\n# Usage\nconsole = DebugConsole.new(engine)\nconsole.start\n</code></pre>"},{"location":"advanced/debugging/#step-through-debugger","title":"Step-Through Debugger","text":"<pre><code>class StepDebugger\n  def initialize(engine)\n    @engine = engine\n    @breakpoints = []\n    @step_mode = false\n  end\n\n  def add_breakpoint(rule_name)\n    @breakpoints &lt;&lt; rule_name\n    puts \"Breakpoint added: #{rule_name}\"\n  end\n\n  def enable_step_mode\n    @step_mode = true\n\n    @engine.instance_variable_get(:@rules).each do |rule|\n      wrap_rule_with_breakpoint(rule)\n    end\n  end\n\n  def wrap_rule_with_breakpoint(rule)\n    original_action = rule.action\n\n    rule.action = lambda do |facts, bindings|\n      if @breakpoints.include?(rule.name) || @step_mode\n        puts \"\\n\ud83d\udd34 BREAKPOINT: #{rule.name}\"\n        puts \"Facts: #{facts.map { |f| { type: f.type, attrs: f.attributes } }}\"\n        puts \"Bindings: #{bindings.inspect}\"\n\n        print \"Continue? [y/n/i(nspect)] \"\n        response = gets.chomp\n\n        case response\n        when 'n'\n          puts \"Skipping rule\"\n          return\n        when 'i'\n          inspect_rule_context(facts, bindings)\n        end\n      end\n\n      original_action.call(facts, bindings)\n    end\n  end\n\n  def inspect_rule_context(facts, bindings)\n    puts \"\\n=== Rule Context ===\"\n    puts \"Facts (#{facts.size}):\"\n    facts.each_with_index do |fact, i|\n      puts \"  #{i}. #{fact.type}: #{fact.attributes.inspect}\"\n    end\n\n    puts \"\\nBindings:\"\n    bindings.each do |var, value|\n      puts \"  #{var} =&gt; #{value.inspect}\"\n    end\n\n    print \"\\nPress Enter to continue...\"\n    gets\n  end\nend\n\n# Usage\ndebugger = StepDebugger.new(engine)\ndebugger.add_breakpoint(\"high_temperature_alert\")\ndebugger.enable_step_mode\nengine.run\n</code></pre>"},{"location":"advanced/debugging/#common-debugging-patterns","title":"Common Debugging Patterns","text":""},{"location":"advanced/debugging/#verify-pattern-matching","title":"Verify Pattern Matching","text":"<pre><code>def verify_pattern_match(fact, pattern)\n  puts \"\\n=== Pattern Match Verification ===\"\n  puts \"Fact: #{fact.attributes.inspect}\"\n  puts \"Pattern: #{pattern.inspect}\"\n\n  result = fact.matches?(pattern)\n  puts \"Result: #{result}\"\n\n  # Detail each attribute\n  pattern.each do |key, expected|\n    next if key == :type\n\n    actual = fact[key]\n    match = (expected == actual || expected.is_a?(Symbol))\n\n    puts \"\\n  #{key}:\"\n    puts \"    Expected: #{expected.inspect}\"\n    puts \"    Actual: #{actual.inspect}\"\n    puts \"    Match: #{match ? '\u2713' : '\u2717'}\"\n  end\n\n  result\nend\n</code></pre>"},{"location":"advanced/debugging/#diagnose-join-issues","title":"Diagnose Join Issues","text":"<pre><code>def diagnose_join(engine, condition1, condition2)\n  puts \"\\n=== Join Diagnosis ===\"\n\n  # Find matches for each condition\n  matches1 = engine.facts.select { |f| f.matches?(condition1.pattern) }\n  matches2 = engine.facts.select { |f| f.matches?(condition2.pattern) }\n\n  puts \"\\nCondition 1 matches: #{matches1.size}\"\n  matches1.first(3).each { |f| puts \"  - #{f.attributes.inspect}\" }\n\n  puts \"\\nCondition 2 matches: #{matches2.size}\"\n  matches2.first(3).each { |f| puts \"  - #{f.attributes.inspect}\" }\n\n  # Find join variables\n  vars1 = condition1.pattern.values.select { |v| v.is_a?(Symbol) &amp;&amp; v.to_s.start_with?('?') }\n  vars2 = condition2.pattern.values.select { |v| v.is_a?(Symbol) &amp;&amp; v.to_s.start_with?('?') }\n  join_vars = vars1 &amp; vars2\n\n  puts \"\\nJoin variables: #{join_vars.inspect}\"\n\n  if join_vars.empty?\n    puts \"\u26a0\ufe0f  No shared variables - conditions are independent\"\n  else\n    # Check if any combinations match\n    combinations = 0\n    matches1.each do |f1|\n      matches2.each do |f2|\n        # Extract bindings\n        bindings1 = extract_bindings(f1, condition1.pattern)\n        bindings2 = extract_bindings(f2, condition2.pattern)\n\n        # Check join\n        if join_vars.all? { |v| bindings1[v] == bindings2[v] }\n          combinations += 1\n        end\n      end\n    end\n\n    puts \"Valid combinations: #{combinations}\"\n  end\nend\n</code></pre>"},{"location":"advanced/debugging/#track-memory-usage","title":"Track Memory Usage","text":"<pre><code>require 'objspace'\n\ndef track_memory_usage(engine)\n  puts \"\\n=== Memory Usage ===\"\n\n  # Facts\n  fact_size = engine.facts.sum { |f| ObjectSpace.memsize_of(f) }\n  puts \"Facts: #{(fact_size / 1024.0).round(2)} KB (#{engine.facts.size} facts)\"\n\n  # Alpha memories\n  alpha_size = 0\n  engine.instance_eval do\n    @alpha_network.each do |_, memory|\n      alpha_size += ObjectSpace.memsize_of(memory)\n      alpha_size += memory.items.sum { |f| ObjectSpace.memsize_of(f) }\n    end\n  end\n  puts \"Alpha network: #{(alpha_size / 1024.0).round(2)} KB\"\n\n  total = fact_size + alpha_size\n  puts \"\\nTotal: #{(total / 1024.0).round(2)} KB\"\nend\n</code></pre>"},{"location":"advanced/debugging/#debugging-checklist","title":"Debugging Checklist","text":"<ul> <li> Verify facts are added with correct types and attributes</li> <li> Check condition patterns match fact structure</li> <li> Test predicates independently</li> <li> Ensure variables are bound correctly across conditions</li> <li> Check negated conditions for blocking facts</li> <li> Verify rule priorities</li> <li> Inspect network structure</li> <li> Trace rule execution</li> <li> Monitor memory usage</li> <li> Check for infinite loops</li> </ul>"},{"location":"advanced/debugging/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Guide - Write tests to prevent bugs</li> <li>Performance Guide - Debug performance issues</li> <li>Architecture - Understand network internals</li> <li>API Reference - Engine API documentation</li> </ul> <p>Good debugging is about asking the right questions. Use these tools to understand what your rules are doing.</p>"},{"location":"advanced/performance/","title":"Performance Tuning","text":"<p>Optimize KBS applications for speed, scalability, and efficiency. This guide covers profiling, benchmarking, rule optimization, and storage backend selection.</p>"},{"location":"advanced/performance/#performance-overview","title":"Performance Overview","text":"<p>KBS performance depends on:</p> <ol> <li>Rule Complexity - Number of conditions, predicates, and joins</li> <li>Fact Volume - Size of working memory</li> <li>Network Structure - Shared nodes and network branching</li> <li>Storage Backend - SQLite, Redis, or in-memory</li> <li>Action Efficiency - Time spent in rule actions</li> </ol>"},{"location":"advanced/performance/#benchmarking","title":"Benchmarking","text":""},{"location":"advanced/performance/#basic-benchmark","title":"Basic Benchmark","text":"<pre><code>require 'benchmark'\nrequire 'kbs'\n\nengine = KBS::Engine.new\n\n# Add rules\nrule = KBS::Rule.new(\"simple_rule\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:fact, { value: :v? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Simple action\n  end\nend\n\nengine.add_rule(rule)\n\n# Benchmark fact addition\ntime = Benchmark.measure do\n  10_000.times do |i|\n    engine.add_fact(:fact, { value: i })\n  end\nend\n\nputs \"Added 10,000 facts in #{time.real} seconds\"\nputs \"#{(10_000 / time.real).round(2)} facts/second\"\n\n# Benchmark engine run\ntime = Benchmark.measure do\n  engine.run\nend\n\nputs \"Ran engine in #{time.real} seconds\"\n</code></pre>"},{"location":"advanced/performance/#comprehensive-benchmark","title":"Comprehensive Benchmark","text":"<pre><code>require 'benchmark'\n\nclass KBSBenchmark\n  def initialize(engine_type: :memory)\n    @engine_type = engine_type\n    @results = {}\n  end\n\n  def setup_engine\n    case @engine_type\n    when :memory\n      KBS::Engine.new\n    when :blackboard_sqlite\n      KBS::Blackboard::Engine.new(db_path: ':memory:')\n    when :blackboard_redis\n      require 'kbs/blackboard/persistence/redis_store'\n      store = KBS::Blackboard::Persistence::RedisStore.new(\n        url: 'redis://localhost:6379/15'  # Test database\n      )\n      KBS::Blackboard::Engine.new(store: store)\n    end\n  end\n\n  def benchmark_fact_addition(count: 10_000)\n    engine = setup_engine\n\n    time = Benchmark.measure do\n      count.times do |i|\n        engine.add_fact(:fact, { id: i, value: rand(1000) })\n      end\n    end\n\n    @results[:fact_addition] = {\n      count: count,\n      time: time.real,\n      rate: (count / time.real).round(2)\n    }\n  end\n\n  def benchmark_simple_rules(fact_count: 1000, rule_count: 10)\n    engine = setup_engine\n\n    # Add rules\n    rule_count.times do |i|\n      rule = KBS::Rule.new(\"rule_#{i}\") do |r|\n        r.conditions = [\n          KBS::Condition.new(:fact, { value: :v? })\n        ]\n\n        r.action = lambda do |facts, bindings|\n          # Minimal action\n        end\n      end\n      engine.add_rule(rule)\n    end\n\n    # Add facts\n    fact_count.times do |i|\n      engine.add_fact(:fact, { value: i })\n    end\n\n    # Benchmark engine run\n    time = Benchmark.measure do\n      engine.run\n    end\n\n    @results[:simple_rules] = {\n      fact_count: fact_count,\n      rule_count: rule_count,\n      time: time.real\n    }\n  end\n\n  def benchmark_complex_joins(fact_count: 500)\n    engine = setup_engine\n\n    # Rule with 3-way join\n    rule = KBS::Rule.new(\"complex_join\") do |r|\n      r.conditions = [\n        KBS::Condition.new(:a, { id: :id?, value: :v? }),\n        KBS::Condition.new(:b, { a_id: :id?, score: :s? }),\n        KBS::Condition.new(:c, { b_score: :s? })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        # Action\n      end\n    end\n\n    engine.add_rule(rule)\n\n    # Add facts\n    fact_count.times do |i|\n      engine.add_fact(:a, { id: i, value: rand(100) })\n      engine.add_fact(:b, { a_id: i, score: rand(100) })\n      engine.add_fact(:c, { b_score: i })\n    end\n\n    # Benchmark\n    time = Benchmark.measure do\n      engine.run\n    end\n\n    @results[:complex_joins] = {\n      fact_count: fact_count * 3,\n      time: time.real\n    }\n  end\n\n  def benchmark_negation(fact_count: 1000)\n    engine = setup_engine\n\n    # Rule with negation\n    rule = KBS::Rule.new(\"negation_rule\") do |r|\n      r.conditions = [\n        KBS::Condition.new(:positive, { id: :id? }),\n        KBS::Condition.new(:negative, { id: :id? }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        # Action\n      end\n    end\n\n    engine.add_rule(rule)\n\n    # Add facts (50% will match)\n    fact_count.times do |i|\n      engine.add_fact(:positive, { id: i })\n      engine.add_fact(:negative, { id: i }) if i.even?\n    end\n\n    # Benchmark\n    time = Benchmark.measure do\n      engine.run\n    end\n\n    @results[:negation] = {\n      fact_count: fact_count + (fact_count / 2),\n      time: time.real\n    }\n  end\n\n  def run_all\n    puts \"=== KBS Performance Benchmark (#{@engine_type}) ===\"\n\n    benchmark_fact_addition\n    puts \"\\nFact Addition:\"\n    puts \"  #{@results[:fact_addition][:count]} facts in #{@results[:fact_addition][:time].round(4)}s\"\n    puts \"  Rate: #{@results[:fact_addition][:rate]} facts/sec\"\n\n    benchmark_simple_rules\n    puts \"\\nSimple Rules:\"\n    puts \"  #{@results[:simple_rules][:rule_count]} rules, #{@results[:simple_rules][:fact_count]} facts\"\n    puts \"  Time: #{@results[:simple_rules][:time].round(4)}s\"\n\n    benchmark_complex_joins\n    puts \"\\nComplex Joins (3-way):\"\n    puts \"  #{@results[:complex_joins][:fact_count]} facts\"\n    puts \"  Time: #{@results[:complex_joins][:time].round(4)}s\"\n\n    benchmark_negation\n    puts \"\\nNegation:\"\n    puts \"  #{@results[:negation][:fact_count]} facts\"\n    puts \"  Time: #{@results[:negation][:time].round(4)}s\"\n\n    @results\n  end\nend\n\n# Run benchmarks\nmemory_bench = KBSBenchmark.new(engine_type: :memory)\nmemory_results = memory_bench.run_all\n\n# Compare with blackboard\nblackboard_bench = KBSBenchmark.new(engine_type: :blackboard_sqlite)\nblackboard_results = blackboard_bench.run_all\n\n# Compare\nputs \"\\n=== Performance Comparison ===\"\nputs \"Fact addition: Memory is #{(blackboard_results[:fact_addition][:time] / memory_results[:fact_addition][:time]).round(2)}x faster\"\n</code></pre>"},{"location":"advanced/performance/#rule-optimization","title":"Rule Optimization","text":""},{"location":"advanced/performance/#condition-ordering","title":"Condition Ordering","text":"<p>Order conditions from most to least selective:</p> <pre><code># Bad: Generic condition first\nKBS::Rule.new(\"inefficient\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:any_event, {}),  # Matches ALL events (large alpha memory)\n    KBS::Condition.new(:critical_error, { severity: \"critical\" })  # Selective\n  ]\nend\n\n# Good: Selective condition first\nKBS::Rule.new(\"efficient\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:critical_error, { severity: \"critical\" }),  # Selective\n    KBS::Condition.new(:any_event, { error_id: :id? })  # Filtered by join\n  ]\nend\n</code></pre> <p>Why it matters:</p> <pre><code>Bad ordering:\n  any_event alpha: 10,000 facts\n  Join produces 10,000 tokens\n  critical_error alpha: 5 facts\n  Join filters down to 5 final matches\n  \u2192 10,000 token propagations\n\nGood ordering:\n  critical_error alpha: 5 facts\n  Join produces 5 tokens\n  any_event alpha: 10,000 facts\n  Join filters to 5 final matches\n  \u2192 5 token propagations (2000x fewer!)\n</code></pre>"},{"location":"advanced/performance/#predicate-efficiency","title":"Predicate Efficiency","text":"<p>Use simple predicates:</p> <pre><code># Bad: Complex predicate\nKBS::Condition.new(:data, { value: :v? }, predicate: lambda { |f|\n  # Expensive operations\n  json = JSON.parse(f[:raw_data])\n  result = ComplexCalculation.new(json).process\n  result &gt; threshold\n})\n\n# Good: Pre-process data\nengine.add_fact(:data, {\n  value: calculate_value(raw_data),  # Pre-calculated\n  processed: true\n})\n\nKBS::Condition.new(:data, { value: :v? }, predicate: lambda { |f|\n  f[:value] &gt; threshold  # Simple comparison\n})\n</code></pre>"},{"location":"advanced/performance/#network-sharing","title":"Network Sharing","text":"<p>Leverage shared alpha and beta memories:</p> <pre><code># Inefficient: Duplicate alpha nodes\nrule1 = KBS::Rule.new(\"rule1\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { type: \"temperature\", value: :v1? })\n  ]\nend\n\nrule2 = KBS::Rule.new(\"rule2\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { type: \"temperature\", value: :v2? })  # SAME pattern\n  ]\nend\n\n# Engine automatically shares alpha memory for :sensor + type=\"temperature\"\n# Adding 1 temperature sensor fact activates BOTH rules efficiently\n</code></pre> <p>Sharing visualization:</p> <pre><code>Facts \u2192 AlphaMemory(:sensor, type=temperature) \u2500\u2500\u252c\u2500\u2192 Rule1\n                                                  \u2514\u2500\u2192 Rule2\n\nInstead of:\nFacts \u2192 AlphaMemory1(:sensor) \u2192 Rule1\n     \u2514\u2192 AlphaMemory2(:sensor) \u2192 Rule2  (duplicate work)\n</code></pre>"},{"location":"advanced/performance/#minimize-negations","title":"Minimize Negations","text":"<p>Negations are expensive:</p> <pre><code># Expensive: Multiple negations\nKBS::Rule.new(\"many_negations\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:a, {}),\n    KBS::Condition.new(:b, {}, negated: true),\n    KBS::Condition.new(:c, {}, negated: true),\n    KBS::Condition.new(:d, {}, negated: true)\n  ]\nend\n# Each negation checks alpha memory on every token\n\n# Better: Use positive logic\nengine.add_fact(:conditions_clear, {}) unless b_exists? || c_exists? || d_exists?\n\nKBS::Rule.new(\"positive_logic\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:a, {}),\n    KBS::Condition.new(:conditions_clear, {})\n  ]\nend\n</code></pre>"},{"location":"advanced/performance/#batch-operations","title":"Batch Operations","text":"<p>Group related operations:</p> <pre><code># Inefficient: Add facts one by one with run after each\n1000.times do |i|\n  engine.add_fact(:item, { id: i })\n  engine.run  # Run engine 1000 times!\nend\n\n# Efficient: Batch add, then run once\n1000.times do |i|\n  engine.add_fact(:item, { id: i })\nend\nengine.run  # Run engine once\n</code></pre>"},{"location":"advanced/performance/#storage-backend-selection","title":"Storage Backend Selection","text":""},{"location":"advanced/performance/#performance-characteristics","title":"Performance Characteristics","text":"<pre><code>require 'benchmark'\n\n# In-memory (fastest)\nmemory_engine = KBS::Engine.new\n\n# SQLite (persistent, slower)\nsqlite_engine = KBS::Blackboard::Engine.new(db_path: 'test.db')\n\n# Redis (persistent, fast)\nrequire 'kbs/blackboard/persistence/redis_store'\nredis_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nredis_engine = KBS::Blackboard::Engine.new(store: redis_store)\n\n# Benchmark\nengines = {\n  memory: memory_engine,\n  sqlite: sqlite_engine,\n  redis: redis_engine\n}\n\nengines.each do |name, engine|\n  time = Benchmark.measure do\n    10_000.times { |i| engine.add_fact(:test, { value: i }) }\n  end\n\n  puts \"#{name}: #{(10_000 / time.real).round(2)} facts/sec\"\nend\n\n# Typical results:\n# memory: 50,000 facts/sec\n# sqlite: 5,000 facts/sec\n# redis: 25,000 facts/sec\n</code></pre>"},{"location":"advanced/performance/#backend-decision-matrix","title":"Backend Decision Matrix","text":"<p>In-Memory (<code>KBS::Engine</code>): - \u2705 Fastest (no I/O) - \u2705 Simple (no setup) - \u274c No persistence - Use when: Prototyping, short-lived processes, pure computation</p> <p>SQLite (<code>KBS::Blackboard::Engine</code>): - \u2705 Persistent - \u2705 ACID transactions - \u2705 No dependencies - \u274c Slower writes (~5,000/sec) - Use when: Single process, moderate load, need durability</p> <p>Redis (<code>RedisStore</code>): - \u2705 Fast (~25,000/sec) - \u2705 Distributed - \u2705 Scalable - \u274c Requires Redis server - Use when: High throughput, multiple processes, real-time systems</p> <p>Hybrid (<code>HybridStore</code>): - \u2705 Fast (Redis) + durable (SQLite) - \u274c Most complex - Use when: Production, need both speed and audit trail</p>"},{"location":"advanced/performance/#sqlite-optimization","title":"SQLite Optimization","text":"<pre><code>engine = KBS::Blackboard::Engine.new(\n  db_path: 'optimized.db',\n  journal_mode: 'WAL',         # Write-Ahead Logging (better concurrency)\n  synchronous: 'NORMAL',       # Balance safety/speed\n  cache_size: -64000,          # 64MB cache\n  busy_timeout: 5000           # Wait 5s for locks\n)\n\n# Results: 2-3x faster than default settings\n</code></pre>"},{"location":"advanced/performance/#redis-optimization","title":"Redis Optimization","text":"<pre><code>store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  pool_size: 10,          # Connection pooling\n  pool_timeout: 5,        # Pool timeout\n  reconnect_attempts: 3   # Retry on failure\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n\n# Enable Redis persistence (optional)\n# In redis.conf:\n#   save 900 1\n#   appendonly yes\n</code></pre>"},{"location":"advanced/performance/#profiling","title":"Profiling","text":""},{"location":"advanced/performance/#ruby-profiler","title":"Ruby Profiler","text":"<pre><code>require 'ruby-prof'\n\nengine = KBS::Engine.new\n\n# Add rules and facts\n# ...\n\n# Profile engine run\nresult = RubyProf.profile do\n  engine.run\nend\n\n# Print results\nprinter = RubyProf::FlatPrinter.new(result)\nprinter.print(STDOUT, min_percent: 2)\n\n# Or use call graph\nprinter = RubyProf::CallTreePrinter.new(result)\nFile.open('profile.out', 'w') { |f| printer.print(f) }\n# View with kcachegrind or qcachegrind\n</code></pre>"},{"location":"advanced/performance/#stackprof-sampling-profiler","title":"Stackprof (Sampling Profiler)","text":"<pre><code>require 'stackprof'\n\nengine = KBS::Engine.new\n\n# Add rules and facts\n# ...\n\n# Profile\nStackProf.run(mode: :cpu, out: 'stackprof.dump') do\n  1000.times { engine.run }\nend\n\n# Analyze\n# $ stackprof stackprof.dump --text\n# $ stackprof stackprof.dump --method 'KBS::JoinNode#left_activate'\n</code></pre>"},{"location":"advanced/performance/#custom-instrumentation","title":"Custom Instrumentation","text":"<pre><code>class InstrumentedEngine &lt; KBS::Engine\n  def initialize\n    super\n    @metrics = {\n      fact_additions: 0,\n      rule_firings: 0,\n      alpha_activations: 0,\n      beta_activations: 0\n    }\n  end\n\n  def add_fact(type, attributes = {})\n    @metrics[:fact_additions] += 1\n    super\n  end\n\n  def run\n    start = Time.now\n    result = super\n    elapsed = Time.now - start\n\n    puts \"Engine run: #{elapsed}s\"\n    puts \"  Facts: #{facts.size}\"\n    puts \"  Rules fired: #{@metrics[:rule_firings]}\"\n\n    result\n  end\n\n  def report_metrics\n    @metrics\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#common-bottlenecks","title":"Common Bottlenecks","text":""},{"location":"advanced/performance/#1-large-alpha-memories","title":"1. Large Alpha Memories","text":"<p>Problem: Conditions matching many facts slow down joins</p> <pre><code># Slow: Matches ALL events\nKBS::Condition.new(:event, {})  # Alpha memory: 100,000 facts\n</code></pre> <p>Solution: Add constraints</p> <pre><code># Fast: Matches specific events\nKBS::Condition.new(:event, { type: \"error\", severity: \"critical\" })\n# Alpha memory: 50 facts\n</code></pre>"},{"location":"advanced/performance/#2-expensive-predicates","title":"2. Expensive Predicates","text":"<p>Problem: Complex predicates evaluated repeatedly</p> <pre><code># Slow: Expensive predicate called for every fact\nKBS::Condition.new(:data, {}, predicate: lambda { |f|\n  expensive_calculation(f[:raw_data])\n})\n</code></pre> <p>Solution: Pre-calculate</p> <pre><code># Fast: Calculate once when adding fact\nprocessed_value = expensive_calculation(raw_data)\nengine.add_fact(:data, { processed: processed_value })\n\nKBS::Condition.new(:data, { processed: :v? })\n</code></pre>"},{"location":"advanced/performance/#3-action-overhead","title":"3. Action Overhead","text":"<p>Problem: Slow actions block engine</p> <pre><code># Slow: Action makes API call\nr.action = lambda do |facts, bindings|\n  result = HTTParty.get(\"https://api.example.com/process\")  # Blocks!\n  engine.add_fact(:result, result)\nend\n</code></pre> <p>Solution: Async processing</p> <pre><code># Fast: Queue action, process asynchronously\nr.action = lambda do |facts, bindings|\n  engine.send_message(:api_queue, {\n    url: \"https://api.example.com/process\",\n    fact_id: facts[0].id\n  }, priority: 50)\nend\n\n# Separate worker processes messages\nworker = Thread.new do\n  loop do\n    msg = engine.pop_message(:api_queue)\n    break unless msg\n\n    result = HTTParty.get(msg[:content][:url])\n    engine.add_fact(:result, result)\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#4-memory-leaks","title":"4. Memory Leaks","text":"<p>Problem: Facts accumulate indefinitely</p> <pre><code># Memory grows unbounded\nloop do\n  engine.add_fact(:sensor_reading, {\n    value: read_sensor(),\n    timestamp: Time.now\n  })\n  engine.run\nend\n# After 1 hour: 360,000 facts in memory!\n</code></pre> <p>Solution: Clean up old facts</p> <pre><code># Cleanup rule\ncleanup_rule = KBS::Rule.new(\"cleanup_old_readings\", priority: 1) do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor_reading, {\n      timestamp: :time?\n    }, predicate: lambda { |f|\n      (Time.now - f[:timestamp]) &gt; 300  # 5 minutes old\n    })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.remove_fact(facts[0])\n  end\nend\n</code></pre>"},{"location":"advanced/performance/#optimization-checklist","title":"Optimization Checklist","text":""},{"location":"advanced/performance/#rule-design","title":"Rule Design","text":"<ul> <li> Order conditions from most to least selective</li> <li> Minimize negations (use positive logic where possible)</li> <li> Keep predicates simple</li> <li> Pre-calculate expensive values</li> <li> Share patterns across rules</li> </ul>"},{"location":"advanced/performance/#fact-management","title":"Fact Management","text":"<ul> <li> Remove facts when no longer needed</li> <li> Batch fact additions</li> <li> Use specific fact types (not generic <code>:data</code>)</li> <li> Avoid duplicate facts</li> </ul>"},{"location":"advanced/performance/#actions","title":"Actions","text":"<ul> <li> Keep actions fast</li> <li> Avoid blocking I/O in actions</li> <li> Use message passing for async work</li> <li> Don't add/remove many facts in single action</li> </ul>"},{"location":"advanced/performance/#storage","title":"Storage","text":"<ul> <li> Choose backend based on requirements:</li> <li>In-memory for speed</li> <li>SQLite for persistence + moderate load</li> <li>Redis for persistence + high load</li> <li>Hybrid for production</li> <li> Optimize SQLite with WAL mode</li> <li> Use connection pooling for Redis</li> <li> Monitor database size</li> </ul>"},{"location":"advanced/performance/#monitoring","title":"Monitoring","text":"<ul> <li> Profile before optimizing</li> <li> Measure fact addition rate</li> <li> Track engine run time</li> <li> Monitor memory usage</li> <li> Log rule firing frequency</li> </ul>"},{"location":"advanced/performance/#performance-targets","title":"Performance Targets","text":""},{"location":"advanced/performance/#expected-performance-in-memory","title":"Expected Performance (In-Memory)","text":"Operation Target Notes Add fact 50,000/sec Simple facts, no rules Simple rule (1 condition) 10,000/sec Per fact Complex rule (3+ conditions) 1,000/sec Per fact Engine run (1000 facts, 10 rules) &lt; 100ms Total time Negation check 10,000/sec Per token"},{"location":"advanced/performance/#expected-performance-sqlite","title":"Expected Performance (SQLite)","text":"Operation Target Notes Add fact 5,000/sec With WAL mode Query facts 100,000/sec Indexed queries Transaction 1,000/sec Commit rate"},{"location":"advanced/performance/#expected-performance-redis","title":"Expected Performance (Redis)","text":"Operation Target Notes Add fact 25,000/sec Network overhead Query facts 50,000/sec Hash operations Message queue 50,000/sec Sorted set operations"},{"location":"advanced/performance/#scaling-strategies","title":"Scaling Strategies","text":""},{"location":"advanced/performance/#vertical-scaling","title":"Vertical Scaling","text":"<p>Increase single-process performance:</p> <pre><code># 1. Use faster backend\nstore = KBS::Blackboard::Persistence::RedisStore.new(...)\nengine = KBS::Blackboard::Engine.new(store: store)\n\n# 2. Optimize rules\n# - Order conditions\n# - Minimize negations\n# - Batch operations\n\n# 3. Pre-process data\n# - Calculate values before adding facts\n# - Index frequently queried attributes\n</code></pre>"},{"location":"advanced/performance/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>Multiple processes sharing Redis:</p> <pre><code># Process 1: Data collector\ncollector_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\ncollector = KBS::Blackboard::Engine.new(store: collector_store)\n\n# Collect data\nloop do\n  data = fetch_data()\n  collector.add_fact(:raw_data, data)\nend\n\n# Process 2: Rule processor\nprocessor_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'  # Same Redis!\n)\nprocessor = KBS::Blackboard::Engine.new(store: processor_store)\n\n# Add rules\nprocessor.add_rule(...)\n\n# Process data\nloop do\n  processor.run\n  sleep 1\nend\n</code></pre>"},{"location":"advanced/performance/#partitioning","title":"Partitioning","text":"<p>Split facts by domain:</p> <pre><code># Engine 1: Temperature monitoring\ntemp_engine = KBS::Blackboard::Engine.new(db_path: 'temp.db')\n# Handles :temperature_reading, :hvac_control\n\n# Engine 2: Security monitoring\nsecurity_engine = KBS::Blackboard::Engine.new(db_path: 'security.db')\n# Handles :motion_sensor, :door_sensor, :alarm\n\n# Coordinator: Coordinates between engines\ncoordinator_engine = KBS::Blackboard::Engine.new(db_path: 'coordinator.db')\n# Handles cross-domain rules\n</code></pre>"},{"location":"advanced/performance/#next-steps","title":"Next Steps","text":"<ul> <li>Debugging Guide - Debug performance issues</li> <li>Testing Guide - Performance testing strategies</li> <li>Custom Persistence - Optimize custom backends</li> <li>Architecture - Understand network structure</li> </ul> <p>Premature optimization is the root of all evil. Profile first, then optimize the bottlenecks.</p>"},{"location":"advanced/testing/","title":"Testing Rules","text":"<p>Comprehensive testing strategies for rule-based systems. This guide covers unit testing, integration testing, test fixtures, and coverage analysis for KBS applications.</p>"},{"location":"advanced/testing/#testing-overview","title":"Testing Overview","text":"<p>Rule-based systems require testing at multiple levels:</p> <ol> <li>Unit Tests - Test individual rules in isolation</li> <li>Integration Tests - Test rule interactions</li> <li>Fact Fixtures - Reusable test data</li> <li>Coverage - Ensure all rules and conditions are tested</li> <li>Performance Tests - Verify rule execution speed</li> </ol>"},{"location":"advanced/testing/#setup","title":"Setup","text":""},{"location":"advanced/testing/#test-framework","title":"Test Framework","text":"<pre><code># Gemfile\ngroup :test do\n  gem 'minitest', '~&gt; 5.0'\n  gem 'simplecov', require: false  # Coverage\nend\n</code></pre>"},{"location":"advanced/testing/#test-helper","title":"Test Helper","text":"<pre><code># test/test_helper.rb\nrequire 'simplecov'\nSimpleCov.start\n\nrequire 'minitest/autorun'\nrequire 'kbs'\n\nclass Minitest::Test\n  def setup_engine\n    KBS::Engine.new\n  end\n\n  def assert_rule_fired(engine, rule_name)\n    # Check if rule action was executed\n    # Implementation depends on tracking mechanism\n  end\n\n  def refute_rule_fired(engine, rule_name)\n    # Check that rule did not fire\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#unit-testing-rules","title":"Unit Testing Rules","text":""},{"location":"advanced/testing/#test-single-rule","title":"Test Single Rule","text":"<pre><code>require 'test_helper'\n\nclass TestTemperatureRule &lt; Minitest::Test\n  def setup\n    @engine = setup_engine\n    @fired = false\n\n    # Create test rule\n    @rule = KBS::Rule.new(\"high_temp_alert\", priority: 100) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor, {\n          type: \"temperature\",\n          value: :temp?\n        }, predicate: lambda { |f| f[:value] &gt; 30 })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @fired = true\n        @engine.add_fact(:alert, {\n          type: \"high_temperature\",\n          temperature: bindings[:temp?]\n        })\n      end\n    end\n\n    @engine.add_rule(@rule)\n  end\n\n  def test_fires_when_temperature_high\n    @engine.add_fact(:sensor, { type: \"temperature\", value: 35 })\n    @engine.run\n\n    assert @fired, \"Rule should fire for high temperature\"\n\n    alerts = @engine.facts.select { |f| f.type == :alert }\n    assert_equal 1, alerts.size\n    assert_equal 35, alerts.first[:temperature]\n  end\n\n  def test_does_not_fire_when_temperature_normal\n    @engine.add_fact(:sensor, { type: \"temperature\", value: 25 })\n    @engine.run\n\n    refute @fired, \"Rule should not fire for normal temperature\"\n\n    alerts = @engine.facts.select { |f| f.type == :alert }\n    assert_empty alerts\n  end\n\n  def test_threshold_boundary\n    # Test at exact threshold\n    @engine.add_fact(:sensor, { type: \"temperature\", value: 30 })\n    @engine.run\n\n    refute @fired, \"Rule should not fire at exact threshold (&gt;= not &gt;)\"\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#test-rule-with-multiple-conditions","title":"Test Rule with Multiple Conditions","text":"<pre><code>class TestMultiConditionRule &lt; Minitest::Test\n  def setup\n    @engine = setup_engine\n    @fired = false\n\n    @rule = KBS::Rule.new(\"high_temp_and_low_humidity\") do |r|\n      r.conditions = [\n        KBS::Condition.new(:temperature, {\n          location: :loc?,\n          value: :temp?\n        }, predicate: lambda { |f| f[:value] &gt; 30 }),\n\n        KBS::Condition.new(:humidity, {\n          location: :loc?,\n          value: :hum?\n        }, predicate: lambda { |f| f[:value] &lt; 40 })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @fired = true\n      end\n    end\n\n    @engine.add_rule(@rule)\n  end\n\n  def test_fires_when_both_conditions_met\n    @engine.add_fact(:temperature, { location: \"room1\", value: 35 })\n    @engine.add_fact(:humidity, { location: \"room1\", value: 30 })\n    @engine.run\n\n    assert @fired, \"Rule should fire when both conditions met\"\n  end\n\n  def test_does_not_fire_with_mismatched_locations\n    @engine.add_fact(:temperature, { location: \"room1\", value: 35 })\n    @engine.add_fact(:humidity, { location: \"room2\", value: 30 })\n    @engine.run\n\n    refute @fired, \"Rule should not fire with different locations\"\n  end\n\n  def test_does_not_fire_when_only_temperature_high\n    @engine.add_fact(:temperature, { location: \"room1\", value: 35 })\n    # No humidity fact\n    @engine.run\n\n    refute @fired, \"Rule should not fire without humidity fact\"\n  end\n\n  def test_does_not_fire_when_temperature_normal\n    @engine.add_fact(:temperature, { location: \"room1\", value: 25 })\n    @engine.add_fact(:humidity, { location: \"room1\", value: 30 })\n    @engine.run\n\n    refute @fired, \"Rule should not fire with normal temperature\"\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#test-negated-conditions","title":"Test Negated Conditions","text":"<pre><code>class TestNegationRule &lt; Minitest::Test\n  def setup\n    @engine = setup_engine\n    @fired = false\n\n    @rule = KBS::Rule.new(\"alert_if_no_acknowledgment\") do |r|\n      r.conditions = [\n        KBS::Condition.new(:error, { id: :id? }),\n        KBS::Condition.new(:acknowledged, { error_id: :id? }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @fired = true\n      end\n    end\n\n    @engine.add_rule(@rule)\n  end\n\n  def test_fires_when_error_not_acknowledged\n    @engine.add_fact(:error, { id: 1 })\n    @engine.run\n\n    assert @fired, \"Rule should fire when error not acknowledged\"\n  end\n\n  def test_does_not_fire_when_error_acknowledged\n    @engine.add_fact(:error, { id: 1 })\n    @engine.add_fact(:acknowledged, { error_id: 1 })\n    @engine.run\n\n    refute @fired, \"Rule should not fire when error acknowledged\"\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"advanced/testing/#test-rule-interactions","title":"Test Rule Interactions","text":"<pre><code>class TestRuleInteractions &lt; Minitest::Test\n  def setup\n    @engine = setup_engine\n    @alerts = []\n\n    # Rule 1: Detect high temperature\n    @engine.add_rule(KBS::Rule.new(\"detect_high_temp\") do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor, { value: :temp? }, predicate: lambda { |f| f[:value] &gt; 30 })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:temp_alert, { severity: \"high\" })\n      end\n    end)\n\n    # Rule 2: Escalate to critical\n    @engine.add_rule(KBS::Rule.new(\"escalate_critical\") do |r|\n      r.conditions = [\n        KBS::Condition.new(:temp_alert, { severity: \"high\" }),\n        KBS::Condition.new(:sensor, { value: :temp? }, predicate: lambda { |f| f[:value] &gt; 40 })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:critical_alert, { type: \"temperature\" })\n        @alerts &lt;&lt; :critical\n      end\n    end)\n  end\n\n  def test_cascading_rules\n    # Add high temperature\n    @engine.add_fact(:sensor, { value: 45 })\n    @engine.run\n\n    # Both rules should fire\n    assert @engine.facts.any? { |f| f.type == :temp_alert }\n    assert @engine.facts.any? { |f| f.type == :critical_alert }\n    assert_includes @alerts, :critical\n  end\n\n  def test_partial_cascade\n    # Add moderately high temperature\n    @engine.add_fact(:sensor, { value: 35 })\n    @engine.run\n\n    # Only first rule fires\n    assert @engine.facts.any? { |f| f.type == :temp_alert }\n    refute @engine.facts.any? { |f| f.type == :critical_alert }\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#test-rule-priority","title":"Test Rule Priority","text":"<pre><code>class TestRulePriority &lt; Minitest::Test\n  def setup\n    @engine = setup_engine\n    @execution_order = []\n\n    # High priority rule\n    @engine.add_rule(KBS::Rule.new(\"high_priority\", priority: 100) do |r|\n      r.conditions = [KBS::Condition.new(:trigger, {})]\n      r.action = lambda do |facts, bindings|\n        @execution_order &lt;&lt; :high\n      end\n    end)\n\n    # Low priority rule\n    @engine.add_rule(KBS::Rule.new(\"low_priority\", priority: 10) do |r|\n      r.conditions = [KBS::Condition.new(:trigger, {})]\n      r.action = lambda do |facts, bindings|\n        @execution_order &lt;&lt; :low\n      end\n    end)\n  end\n\n  def test_executes_in_priority_order\n    @engine.add_fact(:trigger, {})\n    @engine.run\n\n    assert_equal [:high, :low], @execution_order\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#test-fixtures","title":"Test Fixtures","text":""},{"location":"advanced/testing/#fact-fixtures","title":"Fact Fixtures","text":"<pre><code>module FactFixtures\n  def sensor_facts(count: 10)\n    count.times.map do |i|\n      { type: :sensor, attributes: { id: i, value: rand(20..40) } }\n    end\n  end\n\n  def high_temp_scenario\n    [\n      { type: :sensor, attributes: { location: \"room1\", value: 35 } },\n      { type: :sensor, attributes: { location: \"room2\", value: 38 } },\n      { type: :threshold, attributes: { value: 30 } }\n    ]\n  end\n\n  def normal_scenario\n    [\n      { type: :sensor, attributes: { location: \"room1\", value: 22 } },\n      { type: :sensor, attributes: { location: \"room2\", value: 24 } },\n      { type: :threshold, attributes: { value: 30 } }\n    ]\n  end\n\n  def load_facts(engine, facts)\n    facts.each do |fact_data|\n      engine.add_fact(fact_data[:type], fact_data[:attributes])\n    end\n  end\nend\n\nclass TestWithFixtures &lt; Minitest::Test\n  include FactFixtures\n\n  def test_with_high_temp_scenario\n    engine = setup_engine\n    # Add rules...\n\n    load_facts(engine, high_temp_scenario)\n    engine.run\n\n    # Assertions...\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#rule-fixtures","title":"Rule Fixtures","text":"<pre><code>module RuleFixtures\n  def temperature_monitoring_rules\n    [\n      KBS::Rule.new(\"detect_high\") do |r|\n        r.conditions = [\n          KBS::Condition.new(:sensor, { value: :v? }, predicate: lambda { |f| f[:value] &gt; 30 })\n        ]\n        r.action = lambda { |facts, bindings| facts[0][:alerted] = true }\n      end,\n\n      KBS::Rule.new(\"detect_low\") do |r|\n        r.conditions = [\n          KBS::Condition.new(:sensor, { value: :v? }, predicate: lambda { |f| f[:value] &lt; 15 })\n        ]\n        r.action = lambda { |facts, bindings| facts[0][:alerted] = true }\n      end\n    ]\n  end\n\n  def load_rules(engine, rules)\n    rules.each { |rule| engine.add_rule(rule) }\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#coverage-strategies","title":"Coverage Strategies","text":""},{"location":"advanced/testing/#track-rule-firings","title":"Track Rule Firings","text":"<pre><code>class CoverageTracker\n  def initialize(engine)\n    @engine = engine\n    @rule_firings = Hash.new(0)\n    @condition_matches = Hash.new(0)\n  end\n\n  def wrap_rules\n    @engine.instance_variable_get(:@rules).each do |rule|\n      original_action = rule.action\n\n      rule.action = lambda do |facts, bindings|\n        @rule_firings[rule.name] += 1\n        original_action.call(facts, bindings)\n      end\n    end\n  end\n\n  def report\n    puts \"\\n=== Coverage Report ===\"\n\n    total_rules = @engine.instance_variable_get(:@rules).size\n    fired_rules = @rule_firings.keys.size\n    coverage = (fired_rules.to_f / total_rules * 100).round(2)\n\n    puts \"Rules: #{fired_rules}/#{total_rules} (#{coverage}%)\"\n\n    puts \"\\nRule Firings:\"\n    @rule_firings.each do |name, count|\n      puts \"  #{name}: #{count}\"\n    end\n\n    untested = @engine.instance_variable_get(:@rules).map(&amp;:name) - @rule_firings.keys\n    if untested.any?\n      puts \"\\nUntested Rules:\"\n      untested.each { |name| puts \"  - #{name}\" }\n    end\n  end\n\n  attr_reader :rule_firings, :condition_matches\nend\n\n# Usage\nclass TestWithCoverage &lt; Minitest::Test\n  def test_coverage\n    engine = setup_engine\n    # Add rules...\n\n    tracker = CoverageTracker.new(engine)\n    tracker.wrap_rules\n\n    # Add facts and run\n    engine.run\n\n    tracker.report\n\n    # Assert all rules fired\n    assert_equal @engine.instance_variable_get(:@rules).size, tracker.rule_firings.size\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#condition-coverage","title":"Condition Coverage","text":"<pre><code>def test_all_condition_paths\n  engine = setup_engine\n\n  rule = KBS::Rule.new(\"multi_path\") do |r|\n    r.conditions = [\n      KBS::Condition.new(:a, {}),\n      KBS::Condition.new(:b, {}),\n      KBS::Condition.new(:c, {}, negated: true)\n    ]\n    r.action = lambda { |facts, bindings| }\n  end\n\n  engine.add_rule(rule)\n\n  # Test path 1: All conditions pass\n  engine.add_fact(:a, {})\n  engine.add_fact(:b, {})\n  # c absent\n  engine.run\n  # Assert...\n\n  # Test path 2: Negation fails\n  engine = setup_engine\n  engine.add_rule(rule)\n  engine.add_fact(:a, {})\n  engine.add_fact(:b, {})\n  engine.add_fact(:c, {})  # Blocks negation\n  engine.run\n  # Assert...\n\n  # Test path 3: Positive condition missing\n  engine = setup_engine\n  engine.add_rule(rule)\n  engine.add_fact(:a, {})\n  # b missing\n  engine.run\n  # Assert...\nend\n</code></pre>"},{"location":"advanced/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"advanced/testing/#benchmark-rule-execution","title":"Benchmark Rule Execution","text":"<pre><code>require 'benchmark'\n\nclass PerformanceTest &lt; Minitest::Test\n  def test_rule_performance\n    engine = setup_engine\n\n    # Add rule\n    engine.add_rule(KBS::Rule.new(\"perf_test\") do |r|\n      r.conditions = [\n        KBS::Condition.new(:data, { value: :v? })\n      ]\n      r.action = lambda { |facts, bindings| }\n    end)\n\n    # Add many facts\n    1000.times { |i| engine.add_fact(:data, { value: i }) }\n\n    # Benchmark\n    time = Benchmark.measure { engine.run }\n\n    assert time.real &lt; 1.0, \"Engine should complete in under 1 second\"\n  end\n\n  def test_fact_addition_performance\n    engine = setup_engine\n\n    time = Benchmark.measure do\n      10_000.times { |i| engine.add_fact(:data, { value: i }) }\n    end\n\n    rate = 10_000 / time.real\n    assert rate &gt; 10_000, \"Should add &gt;10k facts/sec, got #{rate.round(2)}\"\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#testing-blackboard-persistence","title":"Testing Blackboard Persistence","text":""},{"location":"advanced/testing/#test-with-sqlite","title":"Test with SQLite","text":"<pre><code>class TestBlackboardPersistence &lt; Minitest::Test\n  def test_facts_persist_across_sessions\n    # Session 1: Add facts\n    engine1 = KBS::Blackboard::Engine.new(db_path: 'test.db')\n    engine1.add_fact(:sensor, { id: 1, value: 25 })\n    engine1.close\n\n    # Session 2: Load facts\n    engine2 = KBS::Blackboard::Engine.new(db_path: 'test.db')\n    assert_equal 1, engine2.facts.size\n    assert_equal 25, engine2.facts.first[:value]\n\n    engine2.close\n    File.delete('test.db') if File.exist?('test.db')\n  end\n\n  def test_audit_trail\n    engine = KBS::Blackboard::Engine.new(db_path: ':memory:')\n\n    fact = engine.add_fact(:data, { value: 1 })\n    engine.update_fact(fact.id, { value: 2 })\n    engine.delete_fact(fact.id)\n\n    history = engine.fact_history(fact.id)\n\n    assert_equal 3, history.size\n    assert_equal \"add\", history[0][:operation]\n    assert_equal \"update\", history[1][:operation]\n    assert_equal \"delete\", history[2][:operation]\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"advanced/testing/#1-isolate-rules","title":"1. Isolate Rules","text":"<pre><code>def test_single_rule_only\n  engine = setup_engine\n\n  # Add ONLY the rule being tested\n  engine.add_rule(my_test_rule)\n\n  # No other rules to interfere\n  engine.run\nend\n</code></pre>"},{"location":"advanced/testing/#2-test-edge-cases","title":"2. Test Edge Cases","text":"<pre><code>def test_edge_cases\n  # Empty facts\n  engine.run\n  assert_empty engine.facts.select { |f| f.type == :alert }\n\n  # Exact threshold\n  engine.add_fact(:sensor, { value: 30 })\n  engine.run\n\n  # Just below threshold\n  engine.add_fact(:sensor, { value: 29.99 })\n  engine.run\n\n  # Just above threshold\n  engine.add_fact(:sensor, { value: 30.01 })\n  engine.run\nend\n</code></pre>"},{"location":"advanced/testing/#3-test-side-effects","title":"3. Test Side Effects","text":"<pre><code>def test_action_side_effects\n  engine = setup_engine\n  added_facts = []\n\n  rule = KBS::Rule.new(\"test\") do |r|\n    r.conditions = [KBS::Condition.new(:trigger, {})]\n    r.action = lambda do |facts, bindings|\n      new_fact = engine.add_fact(:result, { value: 42 })\n      added_facts &lt;&lt; new_fact\n    end\n  end\n\n  engine.add_rule(rule)\n  engine.add_fact(:trigger, {})\n  engine.run\n\n  assert_equal 1, added_facts.size\n  assert_equal 42, added_facts.first[:value]\nend\n</code></pre>"},{"location":"advanced/testing/#4-use-descriptive-test-names","title":"4. Use Descriptive Test Names","text":"<pre><code>def test_high_temperature_alert_fires_when_sensor_exceeds_threshold\n  # Clear what this tests\nend\n\ndef test_alert_not_sent_twice_for_same_sensor\n  # Explains the scenario\nend\n</code></pre>"},{"location":"advanced/testing/#5-setup-and-teardown","title":"5. Setup and Teardown","text":"<pre><code>class TestWithSetup &lt; Minitest::Test\n  def setup\n    @engine = setup_engine\n    @test_db = \"test_#{SecureRandom.hex(8)}.db\"\n  end\n\n  def teardown\n    @engine.close if @engine.respond_to?(:close)\n    File.delete(@test_db) if File.exist?(@test_db)\n  end\nend\n</code></pre>"},{"location":"advanced/testing/#testing-checklist","title":"Testing Checklist","text":"<ul> <li> Test each rule fires with correct facts</li> <li> Test each rule doesn't fire without required facts</li> <li> Test boundary conditions</li> <li> Test negated conditions</li> <li> Test variable bindings</li> <li> Test rule priorities</li> <li> Test rule interactions</li> <li> Test action side effects</li> <li> Test persistence (if using blackboard)</li> <li> Measure performance</li> <li> Achieve high rule coverage</li> </ul>"},{"location":"advanced/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Debugging Guide - Debug failing tests</li> <li>Performance Guide - Optimize slow tests</li> <li>Architecture - Understand rule execution</li> <li>Examples - See tested examples</li> </ul> <p>Good tests make rule changes safe. Test each rule thoroughly.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete class documentation for KBS.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":"<ul> <li>Engine - Main RETE engine</li> <li>Facts &amp; Conditions - Pattern matching</li> <li>Rules - Production rules</li> <li>Blackboard - Persistent memory</li> </ul>"},{"location":"api/#architecture","title":"Architecture","text":"<p>See Architecture Overview for system design.</p>"},{"location":"api/blackboard/","title":"Blackboard API Reference","text":"<p>Complete API reference for blackboard memory classes.</p>"},{"location":"api/blackboard/#table-of-contents","title":"Table of Contents","text":"<ul> <li>KBS::Blackboard::Memory - Central blackboard workspace</li> <li>KBS::Blackboard::MessageQueue - Inter-agent communication</li> <li>KBS::Blackboard::AuditLog - Historical tracking</li> <li>Usage Patterns</li> </ul>"},{"location":"api/blackboard/#kbsblackboardmemory","title":"KBS::Blackboard::Memory","text":"<p>The central blackboard workspace that coordinates facts, messages, and audit logging.</p> <p>Architecture: Composes three components: 1. Store - Persistence layer (SQLite, Redis, or Hybrid) 2. MessageQueue - Priority-based inter-agent messaging 3. AuditLog - Complete history of fact changes and rule firings</p>"},{"location":"api/blackboard/#constructor","title":"Constructor","text":""},{"location":"api/blackboard/#initializedb_path-memory-store-nil","title":"<code>initialize(db_path: ':memory:', store: nil)</code>","text":"<p>Creates a new blackboard memory.</p> <p>Parameters: - <code>db_path</code> (String, optional) - Path to SQLite database (default: <code>:memory:</code>) - <code>store</code> (KBS::Blackboard::Persistence::Store, optional) - Custom store (default: <code>nil</code>, creates SQLiteStore)</p> <p>Returns: <code>KBS::Blackboard::Memory</code> instance</p> <p>Side Effects: - Generates session UUID - Creates or connects to persistence store - Initializes message queue and audit log - Sets up database tables/indexes</p> <p>Example - In-Memory: <pre><code>memory = KBS::Blackboard::Memory.new\n# Blackboard stored in RAM (lost on exit)\n</code></pre></p> <p>Example - SQLite Persistence: <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'knowledge_base.db')\n# Facts persisted to knowledge_base.db\n</code></pre></p> <p>Example - Redis Store: <pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(url: 'redis://localhost:6379/0')\nmemory = KBS::Blackboard::Memory.new(store: store)\n# Fast, distributed persistence\n</code></pre></p> <p>Example - Hybrid Store: <pre><code>require 'kbs/blackboard/persistence/hybrid_store'\n\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\nmemory = KBS::Blackboard::Memory.new(store: store)\n# Facts in Redis, audit trail in SQLite\n</code></pre></p>"},{"location":"api/blackboard/#public-attributes","title":"Public Attributes","text":""},{"location":"api/blackboard/#session_id","title":"<code>session_id</code>","text":"<p>Type: <code>String</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Unique session identifier (UUID)</p> <p>Example: <pre><code>memory = KBS::Blackboard::Memory.new\nputs memory.session_id  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre></p> <p>Use Cases: - Filter audit log by session - Separate facts from different runs - Debugging multi-session scenarios</p>"},{"location":"api/blackboard/#store","title":"<code>store</code>","text":"<p>Type: <code>KBS::Blackboard::Persistence::Store</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The underlying persistence store</p> <p>Example: <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'kb.db')\nputs memory.store.class  # =&gt; KBS::Blackboard::Persistence::SqliteStore\n</code></pre></p>"},{"location":"api/blackboard/#message_queue","title":"<code>message_queue</code>","text":"<p>Type: <code>KBS::Blackboard::MessageQueue</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The message queue for inter-agent communication</p> <p>Example: <pre><code>memory.message_queue.post(\"agent1\", \"alerts\", { level: \"critical\" })\n</code></pre></p>"},{"location":"api/blackboard/#audit_log","title":"<code>audit_log</code>","text":"<p>Type: <code>KBS::Blackboard::AuditLog</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The audit log for tracking all changes</p> <p>Example: <pre><code>history = memory.audit_log.fact_history(fact.uuid)\n</code></pre></p>"},{"location":"api/blackboard/#fact-management-methods","title":"Fact Management Methods","text":""},{"location":"api/blackboard/#add_facttype-attributes","title":"<code>add_fact(type, attributes = {})</code>","text":"<p>Adds a persistent fact to the blackboard.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type - <code>attributes</code> (Hash, optional) - Fact attributes (default: <code>{}</code>)</p> <p>Returns: <code>KBS::Blackboard::Fact</code> - Persistent fact with UUID</p> <p>Side Effects: - Generates UUID for fact - Saves fact to store (within transaction) - Logs addition to audit log - Notifies observers</p> <p>Example: <pre><code>fact = memory.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact.uuid  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\nputs fact.type  # =&gt; :temperature\nputs fact[:value]  # =&gt; 85\n</code></pre></p> <p>Transaction Handling: <pre><code>memory.transaction do\n  fact1 = memory.add_fact(:order, id: 1, status: \"pending\")\n  fact2 = memory.add_fact(:inventory, item: \"ABC\", quantity: 100)\n  # Both facts committed together\nend\n</code></pre></p>"},{"location":"api/blackboard/#remove_factfact","title":"<code>remove_fact(fact)</code>","text":"<p>Removes a fact from the blackboard.</p> <p>Parameters: - <code>fact</code> (KBS::Blackboard::Fact or String) - Fact object or UUID</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Marks fact as inactive in store - Logs removal to audit log - Notifies observers</p> <p>Example: <pre><code>fact = memory.add_fact(:temperature, value: 85)\nmemory.remove_fact(fact)\n\n# Or by UUID\nmemory.remove_fact(\"550e8400-e29b-41d4-a716-446655440000\")\n\n# Fact remains in audit log\nhistory = memory.get_history(fact.uuid)\nputs history.last[:action]  # =&gt; \"REMOVE\"\n</code></pre></p>"},{"location":"api/blackboard/#update_factfact-new_attributes","title":"<code>update_fact(fact, new_attributes)</code>","text":"<p>Updates a fact's attributes.</p> <p>Parameters: - <code>fact</code> (KBS::Blackboard::Fact or String) - Fact object or UUID - <code>new_attributes</code> (Hash) - New attributes to merge</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Updates fact in store - Logs update to audit log</p> <p>Example: <pre><code>fact = memory.add_fact(:temperature, location: \"server_room\", value: 85)\nmemory.update_fact(fact, value: 90, timestamp: Time.now)\n\n# Or by UUID\nmemory.update_fact(fact.uuid, value: 95)\n</code></pre></p> <p>Note: Updates do NOT notify observers or trigger rule re-evaluation. For that, retract and re-add the fact.</p>"},{"location":"api/blackboard/#get_factstype-nil-pattern","title":"<code>get_facts(type = nil, pattern = {})</code>","text":"<p>Retrieves facts from the blackboard.</p> <p>Parameters: - <code>type</code> (Symbol, optional) - Filter by fact type (default: <code>nil</code>, all types) - <code>pattern</code> (Hash, optional) - Additional attribute filters (default: <code>{}</code>)</p> <p>Returns: <code>Array&lt;KBS::Blackboard::Fact&gt;</code></p> <p>Example: <pre><code># Get all facts\nall_facts = memory.get_facts\n\n# Get all temperature facts\ntemps = memory.get_facts(:temperature)\n\n# Get temperature facts from specific location\nserver_temps = memory.get_facts(:temperature, location: \"server_room\")\n</code></pre></p> <p>Performance: O(N) where N = total facts (uses linear scan). For large datasets, consider <code>query_facts</code>.</p>"},{"location":"api/blackboard/#facts","title":"<code>facts</code>","text":"<p>Alias for <code>get_facts()</code>. Returns all facts.</p> <p>Returns: <code>Array&lt;KBS::Blackboard::Fact&gt;</code></p> <p>Example: <pre><code>puts \"Total facts: #{memory.facts.size}\"\n</code></pre></p>"},{"location":"api/blackboard/#query_factssql_conditions-nil-params","title":"<code>query_facts(sql_conditions = nil, params = [])</code>","text":"<p>Advanced SQL query for facts (SQLite store only).</p> <p>Parameters: - <code>sql_conditions</code> (String, optional) - SQL WHERE clause (default: <code>nil</code>) - <code>params</code> (Array, optional) - Parameters for SQL query (default: <code>[]</code>)</p> <p>Returns: <code>Array&lt;KBS::Blackboard::Fact&gt;</code></p> <p>Example: <pre><code># Query with SQL condition\nhigh_temps = memory.query_facts(\n  \"fact_type = ? AND json_extract(attributes, '$.value') &gt; ?\",\n  [:temperature, 80]\n)\n\n# Complex query\nrecent_errors = memory.query_facts(\n  \"fact_type = ? AND datetime(json_extract(attributes, '$.timestamp')) &gt; datetime(?)\",\n  [:error, (Time.now - 3600).iso8601]\n)\n</code></pre></p> <p>Important: Only works with SQLite stores. Redis stores will raise NotImplementedError.</p>"},{"location":"api/blackboard/#message-queue-methods","title":"Message Queue Methods","text":""},{"location":"api/blackboard/#post_messagesender-topic-content-priority-0","title":"<code>post_message(sender, topic, content, priority: 0)</code>","text":"<p>Posts a message to the blackboard message queue.</p> <p>Parameters: - <code>sender</code> (String) - Sender identifier (e.g., agent name) - <code>topic</code> (String) - Message topic (channel/category) - <code>content</code> (Hash) - Message payload - <code>priority</code> (Integer, optional) - Message priority (default: 0, higher = more urgent)</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Adds message to queue - Persists to store</p> <p>Example: <pre><code># Post high-priority alert\nmemory.post_message(\n  \"temperature_agent\",\n  \"alerts\",\n  { level: \"critical\", value: 110, location: \"server_room\" },\n  priority: 100\n)\n\n# Post normal-priority task\nmemory.post_message(\n  \"scheduler\",\n  \"tasks\",\n  { task_name: \"cleanup\", params: {} },\n  priority: 10\n)\n</code></pre></p> <p>Message Ordering: Messages consumed in priority order (highest first), then FIFO within same priority.</p>"},{"location":"api/blackboard/#consume_messagetopic-consumer","title":"<code>consume_message(topic, consumer)</code>","text":"<p>Retrieves and removes the highest priority message from a topic.</p> <p>Parameters: - <code>topic</code> (String) - Topic to consume from - <code>consumer</code> (String) - Consumer identifier (for audit trail)</p> <p>Returns: <code>Hash</code> or <code>nil</code> - Message hash with <code>:id</code>, <code>:sender</code>, <code>:topic</code>, <code>:content</code>, <code>:priority</code>, <code>:posted_at</code>, or <code>nil</code> if queue empty</p> <p>Side Effects: - Removes message from queue (atomic operation) - Marks message as consumed - Records consumer and consumption timestamp</p> <p>Example: <pre><code># Consumer loop\nloop do\n  msg = memory.consume_message(\"tasks\", \"worker_1\")\n  break unless msg\n\n  puts \"Processing: #{msg[:content][:task_name]} (priority #{msg[:priority]})\"\n  puts \"Sent by: #{msg[:sender]} at #{msg[:posted_at]}\"\n\n  # Process message...\n  process_task(msg[:content])\nend\n</code></pre></p> <p>Thread Safety: Atomic pop (safe for concurrent consumers with PostgreSQL/Redis).</p>"},{"location":"api/blackboard/#peek_messagestopic-limit-10","title":"<code>peek_messages(topic, limit: 10)</code>","text":"<p>Views messages in queue without consuming them.</p> <p>Parameters: - <code>topic</code> (String) - Topic to peek - <code>limit</code> (Integer, optional) - Max messages to return (default: 10)</p> <p>Returns: <code>Array&lt;Hash&gt;</code> - Array of message hashes (same format as <code>consume_message</code>)</p> <p>Example: <pre><code># Check queue depth\npending = memory.peek_messages(\"tasks\", limit: 100)\nputs \"Pending tasks: #{pending.size}\"\n\n# Inspect high-priority messages\npending.each do |msg|\n  if msg[:priority] &gt; 50\n    puts \"High priority: #{msg[:content][:task_name]}\"\n  end\nend\n</code></pre></p> <p>Use Cases: - Monitor queue depth - Inspect waiting messages - Debugging message flow</p>"},{"location":"api/blackboard/#audit-log-methods","title":"Audit Log Methods","text":""},{"location":"api/blackboard/#log_rule_firingrule_name-fact_uuids-bindings","title":"<code>log_rule_firing(rule_name, fact_uuids, bindings = {})</code>","text":"<p>Logs a rule firing event.</p> <p>Parameters: - <code>rule_name</code> (String) - Name of fired rule - <code>fact_uuids</code> (Array) - UUIDs of facts that matched - <code>bindings</code> (Hash, optional) - Variable bindings (default: <code>{}</code>) <p>Returns: <code>nil</code></p> <p>Side Effects: - Adds entry to audit log - Records timestamp and session ID</p> <p>Example: <pre><code># Typically called by engine, but can be called manually\nmemory.log_rule_firing(\n  \"high_temperature_alert\",\n  [fact1.uuid, fact2.uuid],\n  { :temp? =&gt; 85, :location? =&gt; \"server_room\" }\n)\n</code></pre></p> <p>Note: <code>KBS::Blackboard::Engine</code> calls this automatically. Manual calls useful for custom logging.</p>"},{"location":"api/blackboard/#get_historyfact_uuid-nil-limit-100","title":"<code>get_history(fact_uuid = nil, limit: 100)</code>","text":"<p>Retrieves fact change history.</p> <p>Parameters: - <code>fact_uuid</code> (String, optional) - Filter by fact UUID (default: <code>nil</code>, all facts) - <code>limit</code> (Integer, optional) - Max entries to return (default: 100)</p> <p>Returns: <code>Array&lt;Hash&gt;</code> - Array of history entries with <code>:fact_uuid</code>, <code>:fact_type</code>, <code>:attributes</code>, <code>:action</code>, <code>:timestamp</code>, <code>:session_id</code></p> <p>Example: <pre><code># Get history for specific fact\nfact = memory.add_fact(:temperature, value: 85)\nmemory.update_fact(fact, value: 90)\nmemory.update_fact(fact, value: 95)\n\nhistory = memory.get_history(fact.uuid)\nhistory.each do |entry|\n  puts \"#{entry[:timestamp]}: #{entry[:action]} - #{entry[:attributes][:value]}\"\nend\n\n# Output:\n# 2025-01-15 10:30:03: UPDATE - 95\n# 2025-01-15 10:30:02: UPDATE - 90\n# 2025-01-15 10:30:00: ADD - 85\n</code></pre></p> <p>All Facts History: <pre><code># Get recent changes across all facts\nrecent_changes = memory.get_history(limit: 50)\n</code></pre></p>"},{"location":"api/blackboard/#get_rule_firingsrule_name-nil-limit-100","title":"<code>get_rule_firings(rule_name = nil, limit: 100)</code>","text":"<p>Retrieves rule firing history.</p> <p>Parameters: - <code>rule_name</code> (String, optional) - Filter by rule name (default: <code>nil</code>, all rules) - <code>limit</code> (Integer, optional) - Max entries to return (default: 100)</p> <p>Returns: <code>Array&lt;Hash&gt;</code> - Array of firing entries with <code>:rule_name</code>, <code>:fact_uuids</code>, <code>:bindings</code>, <code>:fired_at</code>, <code>:session_id</code></p> <p>Example: <pre><code># Get firings for specific rule\nfirings = memory.get_rule_firings(\"high_temperature_alert\", limit: 10)\nfirings.each do |firing|\n  puts \"#{firing[:fired_at]}: #{firing[:rule_name]}\"\n  puts \"  Bindings: #{firing[:bindings]}\"\n  puts \"  Facts: #{firing[:fact_uuids]}\"\nend\n\n# All rule firings\nall_firings = memory.get_rule_firings(limit: 100)\n</code></pre></p> <p>Use Cases: - Debugging rule behavior - Performance analysis - Compliance auditing</p>"},{"location":"api/blackboard/#knowledge-source-methods","title":"Knowledge Source Methods","text":""},{"location":"api/blackboard/#register_knowledge_sourcename-description-nil-topics","title":"<code>register_knowledge_source(name, description: nil, topics: [])</code>","text":"<p>Registers an agent/knowledge source.</p> <p>Parameters: - <code>name</code> (String) - Knowledge source name - <code>description</code> (String, optional) - Description (default: <code>nil</code>) - <code>topics</code> (Array, optional) - Topics this source produces/consumes (default: <code>[]</code>) <p>Returns: <code>nil</code></p> <p>Side Effects: - Stores knowledge source metadata in database</p> <p>Example: <pre><code>memory.register_knowledge_source(\n  \"TemperatureMonitor\",\n  description: \"Monitors temperature sensors and generates alerts\",\n  topics: [\"temperature_readings\", \"alerts\"]\n)\n\nmemory.register_knowledge_source(\n  \"AlertDispatcher\",\n  description: \"Dispatches alerts to external systems\",\n  topics: [\"alerts\"]\n)\n</code></pre></p> <p>Use Cases: - Document multi-agent systems - Visualize agent architecture - Track message flow</p>"},{"location":"api/blackboard/#observer-pattern-methods","title":"Observer Pattern Methods","text":""},{"location":"api/blackboard/#add_observerobserver","title":"<code>add_observer(observer)</code>","text":"<p>Registers an observer to receive fact change notifications.</p> <p>Parameters: - <code>observer</code> - Object responding to <code>update(action, fact)</code> method</p> <p>Returns: <code>nil</code></p> <p>Side Effects: Adds observer to internal observers list</p> <p>Example: <pre><code>class FactLogger\n  def update(action, fact)\n    case action\n    when :add\n      puts \"Added: #{fact.type} #{fact.attributes}\"\n    when :remove\n      puts \"Removed: #{fact.uuid}\"\n    end\n  end\nend\n\nlogger = FactLogger.new\nmemory.add_observer(logger)\n\nmemory.add_fact(:temperature, value: 85)\n# Output: Added: temperature {:value=&gt;85}\n</code></pre></p> <p>Important: Observers are NOT persisted. Re-register after restart.</p>"},{"location":"api/blackboard/#session-management-methods","title":"Session Management Methods","text":""},{"location":"api/blackboard/#clear_session","title":"<code>clear_session</code>","text":"<p>Removes all facts from current session.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Removes facts with matching session_id - Preserves audit log</p> <p>Example: <pre><code># Add facts\nmemory.add_fact(:temperature, value: 85)\nmemory.add_fact(:humidity, value: 60)\n\n# Clear session facts\nmemory.clear_session\n\n# Facts removed, but audit log intact\nputs memory.facts.size  # =&gt; 0\nputs memory.get_history.size  # =&gt; 2 (ADD entries still present)\n</code></pre></p>"},{"location":"api/blackboard/#transactionblock","title":"<code>transaction(&amp;block)</code>","text":"<p>Executes block within database transaction.</p> <p>Parameters: - <code>&amp;block</code> - Block to execute</p> <p>Returns: Result of block</p> <p>Side Effects: - Begins transaction - Executes block - Commits on success - Rolls back on exception</p> <p>Example: <pre><code>memory.transaction do\n  fact1 = memory.add_fact(:order, id: 1, total: 100)\n  fact2 = memory.add_fact(:inventory, item: \"ABC\", quantity: 10)\n\n  # If this raises, both facts are rolled back\n  raise \"Validation failed\" if fact1[:total] &gt; 1000\nend\n</code></pre></p> <p>Nested Transactions: Supported (SQLite uses savepoints).</p>"},{"location":"api/blackboard/#statistics-methods","title":"Statistics Methods","text":""},{"location":"api/blackboard/#stats","title":"<code>stats</code>","text":"<p>Returns blackboard statistics.</p> <p>Parameters: None</p> <p>Returns: <code>Hash</code> with keys: - <code>:facts_count</code> (Integer) - Active facts - <code>:total_messages</code> (Integer) - Total messages (consumed + unconsumed) - <code>:unconsumed_messages</code> (Integer) - Unconsumed messages - <code>:rules_fired</code> (Integer) - Total rule firings</p> <p>Example: <pre><code>stats = memory.stats\nputs \"Facts: #{stats[:facts_count]}\"\nputs \"Messages (unconsumed): #{stats[:unconsumed_messages]}\"\nputs \"Messages (total): #{stats[:total_messages]}\"\nputs \"Rules fired: #{stats[:rules_fired]}\"\n</code></pre></p>"},{"location":"api/blackboard/#maintenance-methods","title":"Maintenance Methods","text":""},{"location":"api/blackboard/#vacuum","title":"<code>vacuum</code>","text":"<p>Optimizes database storage (SQLite only).</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: Reclaims unused database space</p> <p>Example: <pre><code># After deleting many facts\nmemory.vacuum\n</code></pre></p> <p>When to Use: After bulk deletions or periodically for long-running systems.</p>"},{"location":"api/blackboard/#close","title":"<code>close</code>","text":"<p>Closes database connection.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: Closes connection to store</p> <p>Example: <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'kb.db')\n# ... use memory ...\nmemory.close\n</code></pre></p> <p>Important: Required for proper cleanup. Use <code>ensure</code> block: <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'kb.db')\nbegin\n  # ... use memory ...\nensure\n  memory.close\nend\n</code></pre></p>"},{"location":"api/blackboard/#kbsblackboardmessagequeue","title":"KBS::Blackboard::MessageQueue","text":"<p>Priority-based message queue for inter-agent communication.</p> <p>Typically accessed via: <code>memory.message_queue</code> or <code>memory.post_message()</code> / <code>memory.consume_message()</code></p>"},{"location":"api/blackboard/#methods","title":"Methods","text":""},{"location":"api/blackboard/#postsender-topic-content-priority-0","title":"<code>post(sender, topic, content, priority: 0)</code>","text":"<p>Posts a message to the queue.</p> <p>Parameters: - <code>sender</code> (String) - Sender identifier - <code>topic</code> (String) - Message topic - <code>content</code> (Hash or String) - Message payload (auto-converts to JSON) - <code>priority</code> (Integer, optional) - Priority (default: 0)</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>memory.message_queue.post(\"agent1\", \"alerts\", { alert: \"critical\" }, priority: 100)\n</code></pre></p>"},{"location":"api/blackboard/#consumetopic-consumer","title":"<code>consume(topic, consumer)</code>","text":"<p>Consumes highest priority message from topic.</p> <p>Parameters: - <code>topic</code> (String) - Topic to consume from - <code>consumer</code> (String) - Consumer identifier</p> <p>Returns: <code>Hash</code> or <code>nil</code></p> <p>Example: <pre><code>msg = memory.message_queue.consume(\"tasks\", \"worker_1\")\nputs msg[:content] if msg\n</code></pre></p>"},{"location":"api/blackboard/#peektopic-limit-10","title":"<code>peek(topic, limit: 10)</code>","text":"<p>Views messages without consuming.</p> <p>Parameters: - <code>topic</code> (String) - Topic to peek - <code>limit</code> (Integer, optional) - Max messages (default: 10)</p> <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example: <pre><code>pending = memory.message_queue.peek(\"tasks\", limit: 5)\nputs \"Next #{pending.size} tasks:\"\npending.each { |m| puts \"  - #{m[:content]}\" }\n</code></pre></p>"},{"location":"api/blackboard/#stats_1","title":"<code>stats</code>","text":"<p>Returns queue statistics.</p> <p>Returns: <code>Hash</code> with <code>:total_messages</code>, <code>:unconsumed_messages</code></p> <p>Example: <pre><code>stats = memory.message_queue.stats\nputs \"Queue depth: #{stats[:unconsumed_messages]}\"\n</code></pre></p>"},{"location":"api/blackboard/#kbsblackboardauditlog","title":"KBS::Blackboard::AuditLog","text":"<p>Complete audit trail of all fact changes and rule firings.</p> <p>Typically accessed via: <code>memory.audit_log</code> or <code>memory.get_history()</code> / <code>memory.get_rule_firings()</code></p>"},{"location":"api/blackboard/#methods_1","title":"Methods","text":""},{"location":"api/blackboard/#log_fact_changefact_uuid-fact_type-attributes-action","title":"<code>log_fact_change(fact_uuid, fact_type, attributes, action)</code>","text":"<p>Logs a fact change event.</p> <p>Parameters: - <code>fact_uuid</code> (String) - Fact UUID - <code>fact_type</code> (Symbol) - Fact type - <code>attributes</code> (Hash) - Fact attributes - <code>action</code> (String) - Action: \"ADD\", \"UPDATE\", \"REMOVE\"</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>memory.audit_log.log_fact_change(\n  fact.uuid,\n  :temperature,\n  { value: 85 },\n  'ADD'\n)\n</code></pre></p> <p>Note: Automatically called by Memory. Manual calls useful for custom tracking.</p>"},{"location":"api/blackboard/#log_rule_firingrule_name-fact_uuids-bindings_1","title":"<code>log_rule_firing(rule_name, fact_uuids, bindings = {})</code>","text":"<p>Logs a rule firing event.</p> <p>Parameters: - <code>rule_name</code> (String) - Rule name - <code>fact_uuids</code> (Array) - Matched fact UUIDs - <code>bindings</code> (Hash, optional) - Variable bindings (default: <code>{}</code>) <p>Returns: <code>nil</code></p> <p>Example: <pre><code>memory.audit_log.log_rule_firing(\n  \"high_temp_alert\",\n  [fact1.uuid, fact2.uuid],\n  { :temp? =&gt; 85 }\n)\n</code></pre></p>"},{"location":"api/blackboard/#fact_historyfact_uuid-nil-limit-100","title":"<code>fact_history(fact_uuid = nil, limit: 100)</code>","text":"<p>Retrieves fact change history.</p> <p>Parameters: - <code>fact_uuid</code> (String, optional) - Filter by UUID (default: <code>nil</code>) - <code>limit</code> (Integer, optional) - Max entries (default: 100)</p> <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example: <pre><code>history = memory.audit_log.fact_history(fact.uuid, limit: 10)\n</code></pre></p>"},{"location":"api/blackboard/#rule_firingsrule_name-nil-limit-100","title":"<code>rule_firings(rule_name = nil, limit: 100)</code>","text":"<p>Retrieves rule firing history.</p> <p>Parameters: - <code>rule_name</code> (String, optional) - Filter by rule name (default: <code>nil</code>) - <code>limit</code> (Integer, optional) - Max entries (default: 100)</p> <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example: <pre><code>firings = memory.audit_log.rule_firings(\"my_rule\", limit: 50)\n</code></pre></p>"},{"location":"api/blackboard/#stats_2","title":"<code>stats</code>","text":"<p>Returns audit log statistics.</p> <p>Returns: <code>Hash</code> with <code>:rules_fired</code></p> <p>Example: <pre><code>stats = memory.audit_log.stats\nputs \"Total rule firings: #{stats[:rules_fired]}\"\n</code></pre></p>"},{"location":"api/blackboard/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/blackboard/#1-multi-agent-coordination","title":"1. Multi-Agent Coordination","text":"<pre><code># Setup\nmemory = KBS::Blackboard::Memory.new(db_path: 'agents.db')\n\n# Agent 1 - Temperature Monitor\nmemory.register_knowledge_source(\n  \"TempMonitor\",\n  description: \"Monitors temperature sensors\",\n  topics: [\"sensors\", \"alerts\"]\n)\n\ndef monitor_loop(memory)\n  loop do\n    temp = read_sensor\n    fact = memory.add_fact(:temperature, value: temp, timestamp: Time.now)\n\n    if temp &gt; 80\n      memory.post_message(\n        \"TempMonitor\",\n        \"alerts\",\n        { type: \"high_temp\", value: temp },\n        priority: 50\n      )\n    end\n\n    sleep 5\n  end\nend\n\n# Agent 2 - Alert Dispatcher\nmemory.register_knowledge_source(\n  \"AlertDispatcher\",\n  description: \"Sends alerts to external systems\",\n  topics: [\"alerts\"]\n)\n\ndef dispatch_loop(memory)\n  loop do\n    msg = memory.consume_message(\"alerts\", \"AlertDispatcher\")\n    break unless msg\n\n    case msg[:content][:type]\n    when \"high_temp\"\n      send_email_alert(msg[:content][:value])\n    end\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#2-audit-trail-analysis","title":"2. Audit Trail Analysis","text":"<pre><code># Find facts that were updated multiple times\nmemory.get_history(limit: 1000).group_by { |e| e[:fact_uuid] }.each do |uuid, entries|\n  if entries.size &gt; 5\n    puts \"Fact #{uuid} changed #{entries.size} times\"\n    entries.each do |entry|\n      puts \"  #{entry[:timestamp]}: #{entry[:action]} - #{entry[:attributes]}\"\n    end\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#3-rule-performance-analysis","title":"3. Rule Performance Analysis","text":"<pre><code># Analyze rule firing frequency\nfirings = memory.get_rule_firings(limit: 10000)\nby_rule = firings.group_by { |f| f[:rule_name] }\n\nby_rule.each do |rule_name, firings_list|\n  puts \"#{rule_name}: #{firings_list.size} firings\"\n\n  # Calculate average time between firings\n  if firings_list.size &gt; 1\n    times = firings_list.map { |f| f[:fired_at] }.sort\n    intervals = times.each_cons(2).map { |t1, t2| (t2 - t1).to_f }\n    avg_interval = intervals.sum / intervals.size\n    puts \"  Avg interval: #{avg_interval.round(2)} seconds\"\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#4-transaction-based-workflows","title":"4. Transaction-Based Workflows","text":"<pre><code>def process_order(memory, order_data)\n  memory.transaction do\n    # Add order fact\n    order = memory.add_fact(:order, order_data)\n\n    # Check inventory\n    inventory = memory.get_facts(:inventory, product_id: order[:product_id]).first\n    raise \"Insufficient inventory\" if inventory[:quantity] &lt; order[:quantity]\n\n    # Deduct inventory\n    memory.update_fact(inventory, quantity: inventory[:quantity] - order[:quantity])\n\n    # Create shipment fact\n    shipment = memory.add_fact(:shipment, order_id: order.uuid, status: \"pending\")\n\n    # Post message for shipping agent\n    memory.post_message(\n      \"OrderProcessor\",\n      \"shipments\",\n      { shipment_id: shipment.uuid },\n      priority: 10\n    )\n\n    # If any step fails, entire transaction rolls back\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#5-debugging-message-flow","title":"5. Debugging Message Flow","text":"<pre><code># Monitor message queue\ndef monitor_queue(memory, topic)\n  loop do\n    pending = memory.peek_messages(topic, limit: 10)\n    puts \"#{Time.now}: #{pending.size} messages in #{topic} queue\"\n\n    pending.each do |msg|\n      age = Time.now - msg[:posted_at]\n      puts \"  [#{msg[:priority]}] #{msg[:sender]}: #{msg[:content]} (#{age.round}s old)\"\n    end\n\n    sleep 5\n  end\nend\n</code></pre>"},{"location":"api/blackboard/#6-session-isolation","title":"6. Session Isolation","text":"<pre><code># Separate test runs\ntest_memory = KBS::Blackboard::Memory.new(db_path: 'test.db')\nputs \"Session: #{test_memory.session_id}\"\n\n# Run test\ntest_memory.add_fact(:test_marker, run_id: 1)\nrun_tests(test_memory)\n\n# Cleanup session (preserves audit log)\ntest_memory.clear_session\n\n# Analyze audit log across sessions\nall_history = test_memory.get_history(limit: 10000)\nby_session = all_history.group_by { |e| e[:session_id] }\nputs \"Total sessions: #{by_session.size}\"\n</code></pre>"},{"location":"api/blackboard/#7-custom-observer-for-metrics","title":"7. Custom Observer for Metrics","text":"<pre><code>class MetricsObserver\n  def initialize\n    @fact_counts = Hash.new(0)\n    @add_count = 0\n    @remove_count = 0\n  end\n\n  def update(action, fact)\n    case action\n    when :add\n      @add_count += 1\n      @fact_counts[fact.type] += 1\n    when :remove\n      @remove_count += 1\n      @fact_counts[fact.type] -= 1\n    end\n  end\n\n  def report\n    puts \"Facts added: #{@add_count}\"\n    puts \"Facts removed: #{@remove_count}\"\n    puts \"Active facts by type:\"\n    @fact_counts.each do |type, count|\n      puts \"  #{type}: #{count}\"\n    end\n  end\nend\n\nmetrics = MetricsObserver.new\nmemory.add_observer(metrics)\n\n# ... run system ...\n\nmetrics.report\n</code></pre>"},{"location":"api/blackboard/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/blackboard/#message-queue","title":"Message Queue","text":"<ul> <li>Priority indexing: Messages sorted by priority + timestamp</li> <li>Atomic pop: <code>consume</code> uses SELECT + UPDATE in transaction (safe for concurrent consumers)</li> <li>Scaling: For &gt;10,000 messages/sec, use Redis store</li> </ul>"},{"location":"api/blackboard/#audit-log","title":"Audit Log","text":"<ul> <li>Write performance: Each fact change = 1 audit log insert (can be disabled for high-throughput)</li> <li>Query performance: Indexed by <code>fact_uuid</code> and <code>session_id</code></li> <li>Growth: Audit log grows unbounded. Implement periodic archival for production:</li> </ul> <pre><code># Archive old audit entries\ndef archive_old_audit(memory, cutoff_date)\n  memory.store.db.execute(\n    \"DELETE FROM fact_history WHERE timestamp &lt; ?\",\n    [cutoff_date.iso8601]\n  )\n\n  memory.store.db.execute(\n    \"DELETE FROM rules_fired WHERE fired_at &lt; ?\",\n    [cutoff_date.iso8601]\n  )\n\n  memory.vacuum\nend\n\n# Archive entries older than 30 days\narchive_old_audit(memory, Date.today - 30)\n</code></pre>"},{"location":"api/blackboard/#see-also","title":"See Also","text":"<ul> <li>Engine API - Blackboard::Engine integration</li> <li>Facts API - Persistent fact objects</li> <li>Custom Persistence - Implementing custom stores</li> <li>Blackboard Guide - Blackboard pattern overview</li> <li>Multi-Agent Example - Multi-agent coordination</li> </ul>"},{"location":"api/engine/","title":"Engine API Reference","text":"<p>Complete API reference for KBS engine classes.</p>"},{"location":"api/engine/#table-of-contents","title":"Table of Contents","text":"<ul> <li>KBS::Engine - Core RETE engine</li> <li>KBS::Blackboard::Engine - Persistent RETE engine with blackboard</li> <li>Engine Lifecycle</li> <li>Advanced Topics</li> </ul>"},{"location":"api/engine/#kbsengine","title":"KBS::Engine","text":"<p>The core RETE II algorithm engine for in-memory fact processing.</p>"},{"location":"api/engine/#constructor","title":"Constructor","text":""},{"location":"api/engine/#initialize","title":"<code>initialize()</code>","text":"<p>Creates a new in-memory RETE engine.</p> <p>Parameters: None</p> <p>Returns: <code>KBS::Engine</code> instance</p> <p>Example: <pre><code>require 'kbs'\n\nengine = KBS::Engine.new\n# Engine ready with empty working memory\n</code></pre></p> <p>Internal State Initialized: - <code>@working_memory</code> - WorkingMemory instance - <code>@rules</code> - Array of registered rules - <code>@alpha_memories</code> - Hash of pattern \u2192 AlphaMemory - <code>@production_nodes</code> - Hash of rule name \u2192 ProductionNode - <code>@root_beta_memory</code> - Root BetaMemory with dummy token</p>"},{"location":"api/engine/#public-methods","title":"Public Methods","text":""},{"location":"api/engine/#add_rulerule","title":"<code>add_rule(rule)</code>","text":"<p>Registers a rule and compiles it into the RETE network.</p> <p>Parameters: - <code>rule</code> (Rule) - Rule object with conditions and action</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Builds alpha memories for each condition pattern - Creates join nodes or negation nodes - Creates beta memories for partial matches - Creates production node for rule - Activates existing facts through new network paths</p> <p>Example: <pre><code>rule = KBS::Rule.new(\n  name: \"high_temperature\",\n  priority: 10,\n  conditions: [\n    KBS::Condition.new(:temperature, { location: \"server_room\" })\n  ],\n  action: -&gt;(bindings) { puts \"Alert: High temperature!\" }\n)\n\nengine.add_rule(rule)\n</code></pre></p> <p>Using DSL: <pre><code>kb = KBS.knowledge_base do\n  rule \"high_temperature\", priority: 10 do\n    on :temperature, location: \"server_room\", value: greater_than(80)\n    perform do |bindings|\n      puts \"Alert: #{bindings[:location?]} is #{bindings[:value?]}\u00b0F\"\n    end\n  end\nend\n\nkb.rules.each { |rule| engine.add_rule(rule) }\n</code></pre></p> <p>Performance Notes: - First rule with a pattern creates alpha memory - Subsequent rules sharing patterns reuse alpha memory (network sharing) - Cost is O(C) where C is number of conditions in rule</p>"},{"location":"api/engine/#add_facttype-attributes","title":"<code>add_fact(type, attributes = {})</code>","text":"<p>Adds a fact to working memory and activates matching alpha memories.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type (e.g., <code>:temperature</code>, <code>:order</code>) - <code>attributes</code> (Hash) - Fact attributes (default: <code>{}</code>)</p> <p>Returns: <code>KBS::Fact</code> - The created fact</p> <p>Side Effects: - Creates Fact object - Adds to working memory - Activates all matching alpha memories - Propagates through join nodes - May create new tokens in beta memories</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\n# =&gt; #&lt;KBS::Fact:0x00... @type=:temperature @attributes={...}&gt;\n\n# Facts without attributes\nmarker = engine.add_fact(:system_ready)\n# =&gt; #&lt;KBS::Fact:0x00... @type=:system_ready @attributes={}&gt;\n</code></pre></p> <p>Thread Safety: Not thread-safe. Wrap in mutex if adding facts from multiple threads.</p> <p>Performance: O(A \u00d7 P) where A is number of alpha memories, P is pattern matching cost</p>"},{"location":"api/engine/#remove_factfact","title":"<code>remove_fact(fact)</code>","text":"<p>Removes a fact from working memory and deactivates it in alpha memories.</p> <p>Parameters: - <code>fact</code> (KBS::Fact) - Fact object to remove (must be exact object reference)</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Removes from working memory - Deactivates fact in all alpha memories - Removes tokens containing this fact - May cause negation nodes to re-evaluate</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nengine.remove_fact(fact)\n\n# Common pattern: Store fact reference for later removal\n@current_alert = engine.add_fact(:alert, level: \"critical\")\n# Later...\nengine.remove_fact(@current_alert) if @current_alert\n</code></pre></p> <p>Important: You must keep a reference to the fact object to remove it. Finding facts requires inspecting <code>engine.working_memory.facts</code>.</p> <p>Example - Finding and Removing: <pre><code># Find all temperature facts\ntemp_facts = engine.working_memory.facts.select { |f| f.type == :temperature }\n\n# Remove specific fact\nold_fact = temp_facts.find { |f| f[:timestamp] &lt; Time.now - 3600 }\nengine.remove_fact(old_fact) if old_fact\n</code></pre></p>"},{"location":"api/engine/#run","title":"<code>run()</code>","text":"<p>Executes all activated rules by firing production nodes.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Fires actions for all tokens in production nodes - Rule actions may add/remove facts - Rule actions may modify external state</p> <p>Example: <pre><code>engine.add_fact(:temperature, value: 85)\nengine.add_fact(:sensor, status: \"active\")\n\n# Facts are in working memory but rules haven't fired\nengine.run  # Execute all matching rules\n\n# Rules fire based on priority (highest first within each production)\n</code></pre></p> <p>Execution Order: - Production nodes fire in arbitrary order (dictionary order by rule name) - Within a production node, tokens fire in insertion order - For priority-based execution, use <code>KBS::Blackboard::Engine</code></p> <p>Example - Multiple Rule Firings: <pre><code>fired_rules = []\n\nkb = KBS.knowledge_base do\n  rule \"rule_a\", priority: 10 do\n    on :temperature, value: greater_than(80)\n    perform { fired_rules &lt;&lt; \"rule_a\" }\n  end\n\n  rule \"rule_b\", priority: 20 do\n    on :temperature, value: greater_than(80)\n    perform { fired_rules &lt;&lt; \"rule_b\" }\n  end\nend\n\nkb.rules.each { |r| engine.add_rule(r) }\nengine.add_fact(:temperature, value: 85)\nengine.run\n\n# Both rules fire (priority doesn't affect KBS::Engine execution order)\nputs fired_rules  # =&gt; [\"rule_a\", \"rule_b\"] or [\"rule_b\", \"rule_a\"]\n</code></pre></p> <p>Best Practice: Call <code>run</code> after batch adding facts: <pre><code># Good - batch facts then run once\nengine.add_fact(:temperature, value: 85)\nengine.add_fact(:humidity, value: 60)\nengine.add_fact(:pressure, value: 1013)\nengine.run\n\n# Avoid - running after each fact (may fire rules prematurely)\nengine.add_fact(:temperature, value: 85)\nengine.run  # Rule may fire with incomplete data\nengine.add_fact(:humidity, value: 60)\nengine.run\n</code></pre></p>"},{"location":"api/engine/#public-attributes","title":"Public Attributes","text":""},{"location":"api/engine/#working_memory","title":"<code>working_memory</code>","text":"<p>Type: <code>KBS::WorkingMemory</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The working memory storing all facts.</p> <p>Example: <pre><code>engine.add_fact(:temperature, value: 85)\nengine.add_fact(:humidity, value: 60)\n\n# Inspect all facts\nputs engine.working_memory.facts.size  # =&gt; 2\n\n# Find specific facts\ntemps = engine.working_memory.facts.select { |f| f.type == :temperature }\ntemps.each do |fact|\n  puts \"Temperature: #{fact[:value]}\"\nend\n</code></pre></p>"},{"location":"api/engine/#rules","title":"<code>rules</code>","text":"<p>Type: <code>Array&lt;KBS::Rule&gt;</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: All registered rules.</p> <p>Example: <pre><code>puts \"Registered rules:\"\nengine.rules.each do |rule|\n  puts \"  - #{rule.name} (priority: #{rule.priority})\"\n  puts \"    Conditions: #{rule.conditions.size}\"\nend\n</code></pre></p>"},{"location":"api/engine/#alpha_memories","title":"<code>alpha_memories</code>","text":"<p>Type: <code>Hash&lt;Hash, KBS::AlphaMemory&gt;</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Pattern \u2192 AlphaMemory mapping.</p> <p>Example: <pre><code># Inspect alpha memories (useful for debugging)\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern: #{pattern}\"\n  puts \"  Facts: #{memory.facts.size}\"\n  puts \"  Successors: #{memory.successors.size}\"\nend\n</code></pre></p>"},{"location":"api/engine/#production_nodes","title":"<code>production_nodes</code>","text":"<p>Type: <code>Hash&lt;Symbol, KBS::ProductionNode&gt;</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Rule name \u2192 ProductionNode mapping.</p> <p>Example: <pre><code># Check if a rule is activated\nprod_node = engine.production_nodes[:high_temperature]\nif prod_node &amp;&amp; prod_node.tokens.any?\n  puts \"Rule 'high_temperature' has #{prod_node.tokens.size} activations\"\nend\n</code></pre></p>"},{"location":"api/engine/#observer-pattern","title":"Observer Pattern","text":"<p>The engine implements the observer pattern to watch fact changes.</p>"},{"location":"api/engine/#updateaction-fact-internal","title":"<code>update(action, fact)</code> (Internal)","text":"<p>Parameters: - <code>action</code> (Symbol) - <code>:add</code> or <code>:remove</code> - <code>fact</code> (KBS::Fact) - The fact that changed</p> <p>Description: Called automatically by WorkingMemory when facts change. Activates/deactivates alpha memories.</p> <p>Example - Custom Observer: <pre><code>class FactLogger\n  def update(action, fact)\n    puts \"[#{Time.now}] #{action.upcase}: #{fact.type} #{fact.attributes}\"\n  end\nend\n\nlogger = FactLogger.new\nengine.working_memory.add_observer(logger)\n\nengine.add_fact(:temperature, value: 85)\n# Output: [2025-01-15 10:30:00] ADD: temperature {:value=&gt;85}\n</code></pre></p>"},{"location":"api/engine/#kbsblackboardengine","title":"KBS::Blackboard::Engine","text":"<p>Persistent RETE engine with blackboard memory, audit logging, and message queue.</p> <p>Inherits: <code>KBS::Engine</code></p> <p>Key Differences from KBS::Engine: - Persistent facts (SQLite, Redis, or Hybrid) - Audit trail of all fact changes - Message queue for inter-agent communication - Transaction support - Observer notifications - Rule firing logged with bindings</p>"},{"location":"api/engine/#constructor_1","title":"Constructor","text":""},{"location":"api/engine/#initializedb_path-memory-store-nil","title":"<code>initialize(db_path: ':memory:', store: nil)</code>","text":"<p>Creates a persistent RETE engine with blackboard memory.</p> <p>Parameters: - <code>db_path</code> (String, optional) - Path to SQLite database (default: <code>:memory:</code>) - <code>store</code> (Store, optional) - Custom persistence store (default: <code>nil</code>, uses SQLiteStore)</p> <p>Returns: <code>KBS::Blackboard::Engine</code> instance</p> <p>Example - In-Memory: <pre><code>engine = KBS::Blackboard::Engine.new\n# Blackboard in RAM (lost on exit)\n</code></pre></p> <p>Example - SQLite Persistence: <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'knowledge_base.db')\n# Facts persisted to knowledge_base.db\n</code></pre></p> <p>Example - Redis Persistence: <pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(url: 'redis://localhost:6379/0')\nengine = KBS::Blackboard::Engine.new(store: store)\n# Fast, distributed persistence\n</code></pre></p> <p>Example - Hybrid Persistence: <pre><code>require 'kbs/blackboard/persistence/hybrid_store'\n\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\nengine = KBS::Blackboard::Engine.new(store: store)\n# Facts in Redis, audit trail in SQLite\n</code></pre></p>"},{"location":"api/engine/#public-methods_1","title":"Public Methods","text":""},{"location":"api/engine/#add_facttype-attributes_1","title":"<code>add_fact(type, attributes = {})</code>","text":"<p>Adds a persistent fact to the blackboard.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type - <code>attributes</code> (Hash) - Fact attributes</p> <p>Returns: <code>KBS::Blackboard::Fact</code> - Persistent fact with UUID</p> <p>Side Effects: - Creates fact with UUID - Saves to persistent store - Logs to audit trail - Activates alpha memories - Notifies observers</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact.uuid  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Fact persists across restarts\nengine2 = KBS::Blackboard::Engine.new(db_path: 'knowledge_base.db')\nreloaded_facts = engine2.blackboard.get_facts_by_type(:temperature)\nputs reloaded_facts.first[:value]  # =&gt; 85\n</code></pre></p> <p>Difference from KBS::Engine: Returns <code>KBS::Blackboard::Fact</code> (has <code>.uuid</code>) instead of <code>KBS::Fact</code>.</p>"},{"location":"api/engine/#remove_factfact_1","title":"<code>remove_fact(fact)</code>","text":"<p>Removes a persistent fact from the blackboard.</p> <p>Parameters: - <code>fact</code> (KBS::Blackboard::Fact) - Fact to remove</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Marks fact as inactive in store - Logs removal to audit trail - Deactivates in alpha memories - Notifies observers</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nengine.remove_fact(fact)\n\n# Fact marked inactive but remains in audit trail\naudit = engine.blackboard.audit_log.get_fact_history(fact.uuid)\nputs audit.last[:action]  # =&gt; \"retract\"\n</code></pre></p>"},{"location":"api/engine/#run_1","title":"<code>run()</code>","text":"<p>Executes activated rules with audit logging.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Fires rules in production nodes - Logs each rule firing to audit trail - Records fact UUIDs and variable bindings - Marks tokens as fired (prevents duplicate firing)</p> <p>Example: <pre><code>engine.add_rule(my_rule)\nengine.add_fact(:temperature, value: 85)\nengine.run\n\n# Check audit log\nengine.blackboard.audit_log.entries.each do |entry|\n  next unless entry[:event_type] == \"rule_fired\"\n  puts \"Rule #{entry[:rule_name]} fired with bindings: #{entry[:bindings]}\"\nend\n</code></pre></p> <p>Difference from KBS::Engine: - Logs every rule firing - Prevents duplicate firing of same token - Records variable bindings in audit</p>"},{"location":"api/engine/#post_messagesender-topic-content-priority-0","title":"<code>post_message(sender, topic, content, priority: 0)</code>","text":"<p>Posts a message to the blackboard message queue.</p> <p>Parameters: - <code>sender</code> (String) - Sender identifier (e.g., agent name) - <code>topic</code> (String) - Message topic (channel) - <code>content</code> (Hash) - Message payload - <code>priority</code> (Integer, optional) - Message priority (default: 0, higher = more urgent)</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Adds message to queue - Persists to store - Higher priority messages consumed first</p> <p>Example: <pre><code># Agent 1 posts message\nengine.post_message(\n  \"trading_agent\",\n  \"orders\",\n  { action: \"buy\", symbol: \"AAPL\", quantity: 100 },\n  priority: 10\n)\n\n# Agent 2 consumes message\nmsg = engine.consume_message(\"orders\", \"execution_agent\")\nputs msg[:content][:action]  # =&gt; \"buy\"\nputs msg[:sender]  # =&gt; \"trading_agent\"\n</code></pre></p> <p>Use Cases: - Inter-agent communication - Command/event bus - Task queues - Priority-based scheduling</p>"},{"location":"api/engine/#consume_messagetopic-consumer","title":"<code>consume_message(topic, consumer)</code>","text":"<p>Retrieves and removes the highest priority message from a topic.</p> <p>Parameters: - <code>topic</code> (String) - Topic to consume from - <code>consumer</code> (String) - Consumer identifier (for audit trail)</p> <p>Returns: <code>Hash</code> or <code>nil</code> - Message hash with <code>:id</code>, <code>:sender</code>, <code>:topic</code>, <code>:content</code>, <code>:priority</code>, <code>:timestamp</code>, or <code>nil</code> if queue empty</p> <p>Side Effects: - Removes message from queue - Logs consumption to audit trail (if store supports it)</p> <p>Example: <pre><code># Consumer loop\nloop do\n  msg = engine.consume_message(\"tasks\", \"worker_1\")\n  break unless msg\n\n  puts \"Processing: #{msg[:content][:task_name]} (priority #{msg[:priority]})\"\n  # Process message...\nend\n</code></pre></p> <p>Thread Safety: Atomic pop operation (PostgreSQL/Redis stores support concurrent consumers)</p>"},{"location":"api/engine/#stats","title":"<code>stats()</code>","text":"<p>Returns blackboard statistics.</p> <p>Parameters: None</p> <p>Returns: <code>Hash</code> with keys: - <code>:facts_count</code> (Integer) - Number of active facts - <code>:messages_count</code> (Integer) - Number of queued messages (all topics) - <code>:audit_entries_count</code> (Integer) - Total audit log entries</p> <p>Example: <pre><code>stats = engine.stats\nputs \"Facts: #{stats[:facts_count]}\"\nputs \"Messages: #{stats[:messages_count]}\"\nputs \"Audit entries: #{stats[:audit_entries_count]}\"\n</code></pre></p> <p>Performance: May be slow for large databases (counts all rows)</p>"},{"location":"api/engine/#public-attributes_1","title":"Public Attributes","text":""},{"location":"api/engine/#blackboard","title":"<code>blackboard</code>","text":"<p>Type: <code>KBS::Blackboard::Memory</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The blackboard memory (also accessible as <code>working_memory</code>).</p> <p>Example: <pre><code># Access blackboard components\nengine.blackboard.message_queue.post(\"agent1\", \"alerts\", { alert: \"critical\" })\nengine.blackboard.audit_log.entries.last\nengine.blackboard.transaction { engine.add_fact(:order, status: \"pending\") }\n\n# Get facts by type\ntemps = engine.blackboard.get_facts_by_type(:temperature)\n</code></pre></p>"},{"location":"api/engine/#engine-lifecycle","title":"Engine Lifecycle","text":""},{"location":"api/engine/#typical-flow","title":"Typical Flow","text":"<pre><code># 1. Create engine\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# 2. Define and register rules\nkb = KBS.knowledge_base do\n  rule \"high_temp_alert\", priority: 10 do\n    on :temperature, value: greater_than(80)\n    perform do |bindings|\n      puts \"Alert! Temperature: #{bindings[:value?]}\"\n    end\n  end\nend\nkb.rules.each { |r| engine.add_rule(r) }\n\n# 3. Add initial facts\nengine.add_fact(:sensor, id: 1, status: \"active\")\n\n# 4. Main loop\nloop do\n  # Collect new data\n  temp = read_temperature_sensor\n  engine.add_fact(:temperature, value: temp, timestamp: Time.now)\n\n  # Execute rules\n  engine.run\n\n  # Process messages\n  while msg = engine.consume_message(\"tasks\", \"main_loop\")\n    handle_task(msg[:content])\n  end\n\n  sleep 5\nend\n</code></pre>"},{"location":"api/engine/#restart-and-recovery","title":"Restart and Recovery","text":"<pre><code># Session 1 - Add facts\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nengine.add_fact(:account, id: 1, balance: 1000)\n# Exit\n\n# Session 2 - Facts still present\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\naccounts = engine.blackboard.get_facts_by_type(:account)\nputs accounts.first[:balance]  # =&gt; 1000\n\n# BUT: Rules must be re-registered (not persisted)\nkb = load_rules\nkb.rules.each { |r| engine.add_rule(r) }\n</code></pre> <p>Important: Only facts persist. Rules, alpha memories, and RETE network must be rebuilt on restart.</p>"},{"location":"api/engine/#transaction-example","title":"Transaction Example","text":"<pre><code>engine.blackboard.transaction do\n  fact1 = engine.add_fact(:order, id: 1, status: \"pending\")\n  fact2 = engine.add_fact(:inventory, item: \"ABC\", quantity: 100)\n\n  # If error occurs here, both facts are rolled back\n  raise \"Validation failed\" if invalid_order?(fact1)\nend\n</code></pre> <p>Database Support: SQLite and PostgreSQL support ACID transactions. Redis and MongoDB require custom transaction logic.</p>"},{"location":"api/engine/#advanced-topics","title":"Advanced Topics","text":""},{"location":"api/engine/#network-sharing","title":"Network Sharing","text":"<p>Multiple rules sharing condition patterns reuse alpha memories:</p> <pre><code># Both rules share the :temperature alpha memory\nrule \"high_temp_alert\" do\n  on :temperature, value: greater_than(80)\n  perform { puts \"High temperature!\" }\nend\n\nrule \"critical_temp_alert\" do\n  on :temperature, value: greater_than(100)\n  perform { puts \"CRITICAL temperature!\" }\nend\n\n# Only 1 alpha memory created for :temperature\n# Pattern matching happens once per fact\n</code></pre>"},{"location":"api/engine/#inspecting-the-rete-network","title":"Inspecting the RETE Network","text":"<pre><code># Dump alpha memories\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern: #{pattern.inspect}\"\n  puts \"  Facts in alpha memory: #{memory.facts.size}\"\n  puts \"  Successor nodes: #{memory.successors.size}\"\n  memory.successors.each do |succ|\n    puts \"    #{succ.class.name}\"\n  end\nend\n\n# Dump production nodes\nengine.production_nodes.each do |name, node|\n  puts \"Rule: #{name}\"\n  puts \"  Tokens (activations): #{node.tokens.size}\"\n  node.tokens.each do |token|\n    puts \"    Token with #{token.facts.size} facts\"\n  end\nend\n</code></pre> <p>Use Case: Debugging why a rule didn't fire</p>"},{"location":"api/engine/#custom-working-memory-observer","title":"Custom Working Memory Observer","text":"<pre><code>class MetricsCollector\n  def initialize\n    @fact_count = 0\n    @retract_count = 0\n  end\n\n  def update(action, fact)\n    case action\n    when :add\n      @fact_count += 1\n    when :remove\n      @retract_count += 1\n    end\n  end\n\n  def report\n    puts \"Facts added: #{@fact_count}\"\n    puts \"Facts retracted: #{@retract_count}\"\n  end\nend\n\nmetrics = MetricsCollector.new\nengine.working_memory.add_observer(metrics)\n\n# Run engine...\nengine.add_fact(:temperature, value: 85)\nengine.remove_fact(fact)\n\nmetrics.report\n# =&gt; Facts added: 1\n# =&gt; Facts retracted: 1\n</code></pre>"},{"location":"api/engine/#programmatic-rule-creation","title":"Programmatic Rule Creation","text":"<pre><code># Without DSL - manual Rule object\ncondition = KBS::Condition.new(:temperature, { value: -&gt; (v) { v &gt; 80 } })\naction = -&gt;(bindings) { puts \"High temperature detected\" }\nrule = KBS::Rule.new(name: \"high_temp\", priority: 10, conditions: [condition], action: action)\n\nengine.add_rule(rule)\n</code></pre> <p>When to Use: Dynamically generating rules at runtime based on configuration.</p>"},{"location":"api/engine/#engine-composition","title":"Engine Composition","text":"<pre><code># Multiple engines with different rule sets\nclass MonitoringSystem\n  def initialize\n    @temperature_engine = KBS::Blackboard::Engine.new(db_path: 'temp.db')\n    @security_engine = KBS::Blackboard::Engine.new(db_path: 'security.db')\n\n    setup_temperature_rules(@temperature_engine)\n    setup_security_rules(@security_engine)\n  end\n\n  def process_sensor_data(data)\n    if data[:type] == :temperature\n      @temperature_engine.add_fact(:temperature, data)\n      @temperature_engine.run\n    elsif data[:type] == :motion\n      @security_engine.add_fact(:motion, data)\n      @security_engine.run\n    end\n  end\nend\n</code></pre> <p>Use Case: Separating concerns across multiple knowledge bases</p>"},{"location":"api/engine/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/engine/#rule-ordering","title":"Rule Ordering","text":"<p>Rules are added to <code>@rules</code> array in registration order, but execution order depends on when tokens reach production nodes.</p> <pre><code># Both rules activated by same fact\nengine.add_rule(rule_a)  # Registered first\nengine.add_rule(rule_b)  # Registered second\n\nengine.add_fact(:temperature, value: 85)\nengine.run\n# Both fire, but order is unpredictable in KBS::Engine\n# Use KBS::Blackboard::Engine with priority for deterministic order\n</code></pre>"},{"location":"api/engine/#fact-batching","title":"Fact Batching","text":"<pre><code># Efficient - batch facts then run once\nfacts_to_add.each do |data|\n  engine.add_fact(:sensor_reading, data)\nend\nengine.run  # All rules see complete dataset\n\n# Inefficient - run after each fact\nfacts_to_add.each do |data|\n  engine.add_fact(:sensor_reading, data)\n  engine.run  # May fire rules prematurely\nend\n</code></pre>"},{"location":"api/engine/#memory-growth","title":"Memory Growth","text":"<pre><code># Clean up old facts to prevent memory growth\ncutoff_time = Time.now - 3600  # 1 hour ago\nold_facts = engine.working_memory.facts.select do |fact|\n  fact[:timestamp] &amp;&amp; fact[:timestamp] &lt; cutoff_time\nend\n\nold_facts.each { |f| engine.remove_fact(f) }\n</code></pre> <p>Production Pattern: Implement fact expiration in a cleanup rule:</p> <pre><code>rule \"expire_old_facts\", priority: 0 do\n  on :temperature, timestamp: -&gt;(ts) { Time.now - ts &gt; 3600 }\n  perform do |bindings|\n    fact = bindings[:matched_fact?]\n    engine.remove_fact(fact)\n  end\nend\n</code></pre>"},{"location":"api/engine/#error-handling","title":"Error Handling","text":""},{"location":"api/engine/#rule-action-errors","title":"Rule Action Errors","text":"<pre><code>rule \"risky_operation\" do\n  on :task, status: \"pending\"\n  perform do |bindings|\n    begin\n      perform_risky_operation(bindings[:task_id?])\n    rescue =&gt; e\n      # Log error\n      puts \"Error in rule: #{e.message}\"\n\n      # Add error fact for other rules to handle\n      engine.add_fact(:error, rule: \"risky_operation\", message: e.message)\n    end\n  end\nend\n</code></pre>"},{"location":"api/engine/#store-connection-errors","title":"Store Connection Errors","text":"<pre><code>begin\n  engine = KBS::Blackboard::Engine.new(db_path: '/invalid/path/kb.db')\nrescue Errno::EACCES =&gt; e\n  puts \"Cannot access database: #{e.message}\"\n  # Fallback to in-memory\n  engine = KBS::Blackboard::Engine.new\nend\n</code></pre>"},{"location":"api/engine/#thread-safety","title":"Thread Safety","text":"<p>KBS::Engine and KBS::Blackboard::Engine are NOT thread-safe.</p> <p>For multi-threaded access:</p> <pre><code>require 'thread'\n\nclass ThreadSafeEngine\n  def initialize(*args)\n    @engine = KBS::Blackboard::Engine.new(*args)\n    @mutex = Mutex.new\n  end\n\n  def add_fact(*args)\n    @mutex.synchronize { @engine.add_fact(*args) }\n  end\n\n  def run\n    @mutex.synchronize { @engine.run }\n  end\nend\n</code></pre> <p>Better Approach: Use one engine per thread or message passing between threads.</p>"},{"location":"api/engine/#see-also","title":"See Also","text":"<ul> <li>Facts API - Working with fact objects</li> <li>Rules API - Rule and Condition objects</li> <li>Blackboard API - Memory, MessageQueue, AuditLog</li> <li>DSL Guide - Rule definition syntax</li> <li>Performance Guide - Optimization strategies</li> </ul>"},{"location":"api/facts/","title":"Facts API Reference","text":"<p>Complete API reference for fact and condition classes in KBS.</p>"},{"location":"api/facts/#table-of-contents","title":"Table of Contents","text":"<ul> <li>KBS::Fact - Transient in-memory fact</li> <li>KBS::Blackboard::Fact - Persistent fact with UUID</li> <li>KBS::Condition - Pattern matching condition</li> <li>Fact Patterns</li> <li>Pattern Matching Semantics</li> </ul>"},{"location":"api/facts/#kbsfact","title":"KBS::Fact","text":"<p>Transient in-memory fact used by the core RETE engine.</p>"},{"location":"api/facts/#constructor","title":"Constructor","text":""},{"location":"api/facts/#initializetype-attributes","title":"<code>initialize(type, attributes = {})</code>","text":"<p>Creates a new transient fact.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type (e.g., <code>:temperature</code>, <code>:order</code>) - <code>attributes</code> (Hash, optional) - Fact attributes (default: <code>{}</code>)</p> <p>Returns: <code>KBS::Fact</code> instance</p> <p>Example: <pre><code># Fact with attributes\nfact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n# Fact without attributes (marker/flag)\nflag = KBS::Fact.new(:system_ready)\n</code></pre></p> <p>Internal Behavior: - <code>@id</code> is set to <code>object_id</code> (unique Ruby object identifier) - <code>@type</code> stores the fact type - <code>@attributes</code> stores the attribute hash</p>"},{"location":"api/facts/#public-attributes","title":"Public Attributes","text":""},{"location":"api/facts/#id","title":"<code>id</code>","text":"<p>Type: <code>Integer</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Unique identifier (Ruby object ID)</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\nputs fact.id  # =&gt; 70123456789012 (varies)\n</code></pre></p> <p>Note: Not stable across Ruby processes. For persistent IDs, use <code>KBS::Blackboard::Fact</code> with UUIDs.</p>"},{"location":"api/facts/#type","title":"<code>type</code>","text":"<p>Type: <code>Symbol</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact type</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\nputs fact.type  # =&gt; :temperature\n</code></pre></p>"},{"location":"api/facts/#attributes","title":"<code>attributes</code>","text":"<p>Type: <code>Hash</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact's attribute hash</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nputs fact.attributes  # =&gt; {:location=&gt;\"server_room\", :value=&gt;85}\n</code></pre></p> <p>Important: Direct modification bypasses change tracking: <pre><code># Don't do this (changes not tracked)\nfact.attributes[:value] = 90\n\n# Instead use []= accessor\nfact[:value] = 90\n</code></pre></p>"},{"location":"api/facts/#public-methods","title":"Public Methods","text":""},{"location":"api/facts/#key","title":"<code>[](key)</code>","text":"<p>Retrieves an attribute value.</p> <p>Parameters: - <code>key</code> (Symbol) - Attribute key</p> <p>Returns: Attribute value or <code>nil</code> if not present</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nputs fact[:location]  # =&gt; \"server_room\"\nputs fact[:value]     # =&gt; 85\nputs fact[:missing]   # =&gt; nil\n</code></pre></p>"},{"location":"api/facts/#key-value","title":"<code>[]=(key, value)</code>","text":"<p>Sets an attribute value.</p> <p>Parameters: - <code>key</code> (Symbol) - Attribute key - <code>value</code> - Attribute value</p> <p>Returns: The value</p> <p>Side Effects: Modifies the fact's attributes hash</p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\nfact[:value] = 90\nfact[:timestamp] = Time.now\n\nputs fact.attributes  # =&gt; {:value=&gt;90, :timestamp=&gt;2025-01-15 10:30:00}\n</code></pre></p> <p>Important for KBS::Fact: Changes are NOT persisted and do NOT trigger re-evaluation. For tracked updates, use <code>KBS::Blackboard::Fact</code>.</p>"},{"location":"api/facts/#matchespattern","title":"<code>matches?(pattern)</code>","text":"<p>Checks if this fact matches a pattern.</p> <p>Parameters: - <code>pattern</code> (Hash) - Pattern hash with <code>:type</code> and attribute constraints</p> <p>Returns: <code>true</code> if matches, <code>false</code> otherwise</p> <p>Pattern Types: 1. Type constraint: <code>pattern[:type]</code> must equal fact type 2. Literal values: Attribute must equal specified value 3. Predicate lambdas: <code>value.is_a?(Proc)</code> - attribute passed to lambda, must return truthy 4. Variable bindings: <code>value.is_a?(Symbol) &amp;&amp; value.to_s.start_with?('?')</code> - always matches (variable captures value)</p> <p>Example - Literal Matching: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n# Type only\nfact.matches?(type: :temperature)  # =&gt; true\nfact.matches?(type: :pressure)     # =&gt; false\n\n# Type + literal attribute\nfact.matches?(type: :temperature, location: \"server_room\")  # =&gt; true\nfact.matches?(type: :temperature, location: \"lobby\")        # =&gt; false\n\n# Multiple literals\nfact.matches?(type: :temperature, location: \"server_room\", value: 85)  # =&gt; true\nfact.matches?(type: :temperature, location: \"server_room\", value: 90)  # =&gt; false\n</code></pre></p> <p>Example - Predicate Matching: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)\n\n# Lambda predicate\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 80 })   # =&gt; true\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 100 })  # =&gt; false\n\n# Complex predicate\nfact.matches?(\n  type: :temperature,\n  value: -&gt;(v) { v &gt;= 70 &amp;&amp; v &lt;= 90 }\n)  # =&gt; true\n</code></pre></p> <p>Example - Variable Binding: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n# Variables always match (they capture the value)\nfact.matches?(type: :temperature, location: :loc?)  # =&gt; true\nfact.matches?(type: :temperature, value: :temp?)    # =&gt; true\n\n# Variables with other constraints\nfact.matches?(\n  type: :temperature,\n  location: \"server_room\",  # Literal constraint\n  value: :temp?             # Variable binding\n)  # =&gt; true\n</code></pre></p> <p>Example - Missing Attributes: <pre><code>fact = KBS::Fact.new(:temperature, value: 85)  # No :location attribute\n\n# Missing attributes fail predicate/literal checks\nfact.matches?(type: :temperature, location: \"server_room\")  # =&gt; false\nfact.matches?(type: :temperature, location: -&gt;(l) { l.length &gt; 5 })  # =&gt; false (no :location)\n\n# Missing attributes match variables\nfact.matches?(type: :temperature, location: :loc?)  # =&gt; true (variable matches nil)\n</code></pre></p> <p>Algorithm: 1. If <code>pattern[:type]</code> present and doesn't match fact type \u2192 return <code>false</code> 2. For each key in pattern (except <code>:type</code>):    - If value is Proc: call with fact attribute value, return <code>false</code> if falsy or attribute missing    - If value is variable (symbol starting with <code>?</code>): skip (always matches)    - Otherwise: return <code>false</code> if fact attribute \u2260 pattern value 3. Return <code>true</code> if all checks passed</p>"},{"location":"api/facts/#to_s","title":"<code>to_s</code>","text":"<p>Returns string representation of fact.</p> <p>Parameters: None</p> <p>Returns: <code>String</code> in format <code>\"type(attr1: val1, attr2: val2)\"</code></p> <p>Example: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nputs fact.to_s  # =&gt; \"temperature(location: server_room, value: 85)\"\n\nflag = KBS::Fact.new(:system_ready)\nputs flag.to_s  # =&gt; \"system_ready()\"\n</code></pre></p>"},{"location":"api/facts/#kbsblackboardfact","title":"KBS::Blackboard::Fact","text":"<p>Persistent fact with UUID, used by blackboard memory.</p> <p>Inherits: None (separate implementation from <code>KBS::Fact</code>)</p> <p>Key Differences from KBS::Fact: - Has UUID instead of object ID - <code>[]=</code> and <code>update()</code> trigger persistence and audit logging - <code>retract()</code> method to remove from blackboard - Reference to blackboard memory for update tracking</p>"},{"location":"api/facts/#constructor_1","title":"Constructor","text":""},{"location":"api/facts/#initializeuuid-type-attributes-blackboard-nil","title":"<code>initialize(uuid, type, attributes, blackboard = nil)</code>","text":"<p>Creates a persistent fact. Usually created via <code>engine.add_fact()</code>, not directly.</p> <p>Parameters: - <code>uuid</code> (String) - Unique identifier (UUID format) - <code>type</code> (Symbol) - Fact type - <code>attributes</code> (Hash) - Fact attributes - <code>blackboard</code> (KBS::Blackboard::Memory, optional) - Reference to blackboard (default: <code>nil</code>)</p> <p>Returns: <code>KBS::Blackboard::Fact</code> instance</p> <p>Example - Direct Construction (rare): <pre><code>require 'securerandom'\n\nfact = KBS::Blackboard::Fact.new(\n  SecureRandom.uuid,\n  :temperature,\n  { location: \"server_room\", value: 85 }\n)\nputs fact.uuid  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre></p> <p>Example - Typical Usage: <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nfact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\n# Returns KBS::Blackboard::Fact with UUID and blackboard reference\n</code></pre></p>"},{"location":"api/facts/#public-attributes_1","title":"Public Attributes","text":""},{"location":"api/facts/#uuid","title":"<code>uuid</code>","text":"<p>Type: <code>String</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Globally unique identifier (UUID format)</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nputs fact.uuid  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre></p> <p>Use Cases: - Stable ID across restarts - Foreign keys in external systems - Audit trail references</p>"},{"location":"api/facts/#type_1","title":"<code>type</code>","text":"<p>Type: <code>Symbol</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact type</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nputs fact.type  # =&gt; :temperature\n</code></pre></p>"},{"location":"api/facts/#attributes_1","title":"<code>attributes</code>","text":"<p>Type: <code>Hash</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact's attribute hash</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact.attributes  # =&gt; {:location=&gt;\"server_room\", :value=&gt;85}\n</code></pre></p> <p>Important: Direct modification bypasses persistence: <pre><code># Don't do this (not persisted)\nfact.attributes[:value] = 90\n\n# Instead use []= or update()\nfact[:value] = 90\n# or\nfact.update(value: 90)\n</code></pre></p>"},{"location":"api/facts/#public-methods_1","title":"Public Methods","text":""},{"location":"api/facts/#key_1","title":"<code>[](key)</code>","text":"<p>Retrieves an attribute value.</p> <p>Parameters: - <code>key</code> (Symbol) - Attribute key</p> <p>Returns: Attribute value or <code>nil</code> if not present</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact[:location]  # =&gt; \"server_room\"\nputs fact[:value]     # =&gt; 85\nputs fact[:missing]   # =&gt; nil\n</code></pre></p>"},{"location":"api/facts/#key-value_1","title":"<code>[]=(key, value)</code>","text":"<p>Sets an attribute value with persistence.</p> <p>Parameters: - <code>key</code> (Symbol) - Attribute key - <code>value</code> - Attribute value (must be JSON-serializable for most stores)</p> <p>Returns: The value</p> <p>Side Effects: - Updates fact's attributes hash - Calls <code>blackboard.update_fact(self, @attributes)</code> if blackboard present - Persists change to store - Logs to audit trail - Notifies observers</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nfact[:value] = 90  # Immediately persisted\n\n# After restart\nengine2 = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nreloaded = engine2.blackboard.get_facts_by_type(:temperature).first\nputs reloaded[:value]  # =&gt; 90\n</code></pre></p> <p>Important: Updates do NOT trigger rule re-evaluation. To trigger rules, retract and re-add: <pre><code>old_fact = fact\nfact.retract\nnew_fact = engine.add_fact(:temperature, value: 90)\nengine.run\n</code></pre></p>"},{"location":"api/facts/#updatenew_attributes","title":"<code>update(new_attributes)</code>","text":"<p>Bulk update multiple attributes with persistence.</p> <p>Parameters: - <code>new_attributes</code> (Hash) - Hash of attributes to merge</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Merges <code>new_attributes</code> into <code>@attributes</code> - Persists changes - Logs to audit trail - Notifies observers</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\n\nfact.update(value: 90, timestamp: Time.now)\n\nputs fact.attributes\n# =&gt; {:location=&gt;\"server_room\", :value=&gt;90, :timestamp=&gt;2025-01-15 10:30:00}\n</code></pre></p> <p>Difference from <code>[]=</code>: Updates multiple attributes in single persistence operation (more efficient).</p>"},{"location":"api/facts/#retract","title":"<code>retract()</code>","text":"<p>Removes this fact from the blackboard.</p> <p>Parameters: None</p> <p>Returns: <code>nil</code></p> <p>Side Effects: - Calls <code>blackboard.remove_fact(self)</code> if blackboard present - Marks fact as inactive in store - Logs retraction to audit trail - Deactivates in alpha memories - Notifies observers</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, value: 85)\nfact.retract  # Fact removed\n\n# Equivalent to:\nengine.remove_fact(fact)\n</code></pre></p> <p>Use Case: Fact self-destruction in rule actions: <pre><code>rule \"auto_expire_old_alerts\" do\n  on :alert, timestamp: -&gt;(ts) { Time.now - ts &gt; 3600 }\n  perform do |bindings|\n    # Fact can remove itself\n    alert_fact = bindings[:matched_fact?]\n    alert_fact.retract\n  end\nend\n</code></pre></p>"},{"location":"api/facts/#matchespattern_1","title":"<code>matches?(pattern)</code>","text":"<p>Checks if this fact matches a pattern. Same semantics as <code>KBS::Fact#matches?</code>.</p> <p>Parameters: - <code>pattern</code> (Hash) - Pattern hash with <code>:type</code> and attribute constraints</p> <p>Returns: <code>true</code> if matches, <code>false</code> otherwise</p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\n\nfact.matches?(type: :temperature)  # =&gt; true\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 80 })  # =&gt; true\nfact.matches?(type: :pressure)  # =&gt; false\n</code></pre></p> <p>See <code>KBS::Fact#matches?</code> for detailed semantics.</p>"},{"location":"api/facts/#to_s_1","title":"<code>to_s</code>","text":"<p>Returns string representation with UUID prefix.</p> <p>Parameters: None</p> <p>Returns: <code>String</code> in format <code>\"type(uuid_prefix...: attr1=val1, attr2=val2)\"</code></p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nputs fact.to_s\n# =&gt; \"temperature(550e8400...: location=server_room, value=85)\"\n</code></pre></p> <p>Note: Only first 8 characters of UUID shown for brevity.</p>"},{"location":"api/facts/#to_h","title":"<code>to_h</code>","text":"<p>Returns hash representation of fact.</p> <p>Parameters: None</p> <p>Returns: <code>Hash</code> with keys <code>:uuid</code>, <code>:type</code>, <code>:attributes</code></p> <p>Example: <pre><code>fact = engine.add_fact(:temperature, location: \"server_room\", value: 85)\nhash = fact.to_h\n\nputs hash\n# =&gt; {\n#   :uuid =&gt; \"550e8400-e29b-41d4-a716-446655440000\",\n#   :type =&gt; :temperature,\n#   :attributes =&gt; {:location=&gt;\"server_room\", :value=&gt;85}\n# }\n</code></pre></p> <p>Use Cases: - Serialization for APIs - Logging - Testing assertions</p>"},{"location":"api/facts/#kbscondition","title":"KBS::Condition","text":"<p>Pattern matching condition used in rule definitions.</p>"},{"location":"api/facts/#constructor_2","title":"Constructor","text":""},{"location":"api/facts/#initializetype-pattern-negated-false","title":"<code>initialize(type, pattern = {}, negated: false)</code>","text":"<p>Creates a condition that matches facts.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type to match - <code>pattern</code> (Hash, optional) - Attribute constraints (default: <code>{}</code>) - <code>negated</code> (Boolean, optional) - If <code>true</code>, condition matches when pattern is absent (default: <code>false</code>)</p> <p>Returns: <code>KBS::Condition</code> instance</p> <p>Example - Positive Condition: <pre><code># Match any temperature fact\ncondition = KBS::Condition.new(:temperature)\n\n# Match temperature facts with location=\"server_room\"\ncondition = KBS::Condition.new(:temperature, location: \"server_room\")\n\n# Match temperature facts with value &gt; 80\ncondition = KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n</code></pre></p> <p>Example - Negated Condition: <pre><code># Match when there is NO alert fact\ncondition = KBS::Condition.new(:alert, {}, negated: true)\n\n# Match when there is NO critical alert\ncondition = KBS::Condition.new(:alert, { level: \"critical\" }, negated: true)\n</code></pre></p> <p>Example - Variable Binding: <pre><code># Capture temperature value in :temp? variable\ncondition = KBS::Condition.new(:temperature, value: :temp?)\n\n# Capture location and value\ncondition = KBS::Condition.new(\n  :temperature,\n  location: :loc?,\n  value: :temp?\n)\n</code></pre></p>"},{"location":"api/facts/#public-attributes_2","title":"Public Attributes","text":""},{"location":"api/facts/#type_2","title":"<code>type</code>","text":"<p>Type: <code>Symbol</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The fact type this condition matches</p> <p>Example: <pre><code>condition = KBS::Condition.new(:temperature, value: :temp?)\nputs condition.type  # =&gt; :temperature\n</code></pre></p>"},{"location":"api/facts/#pattern","title":"<code>pattern</code>","text":"<p>Type: <code>Hash</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: The attribute pattern to match</p> <p>Example: <pre><code>condition = KBS::Condition.new(:temperature, location: \"server_room\", value: :temp?)\nputs condition.pattern  # =&gt; {:location=&gt;\"server_room\", :value=&gt;:temp?}\n</code></pre></p>"},{"location":"api/facts/#negated","title":"<code>negated</code>","text":"<p>Type: <code>Boolean</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Whether this is a negation condition</p> <p>Example: <pre><code>pos_condition = KBS::Condition.new(:temperature, value: :temp?)\nputs pos_condition.negated  # =&gt; false\n\nneg_condition = KBS::Condition.new(:alert, {}, negated: true)\nputs neg_condition.negated  # =&gt; true\n</code></pre></p>"},{"location":"api/facts/#variable_bindings","title":"<code>variable_bindings</code>","text":"<p>Type: <code>Hash&lt;Symbol, Symbol&gt;</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Map of variable names to attribute keys (e.g., <code>{:temp? =&gt; :value}</code>)</p> <p>Example: <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  location: :loc?,\n  value: :temp?\n)\n\nputs condition.variable_bindings\n# =&gt; {:loc?=&gt;:location, :temp?=&gt;:value}\n</code></pre></p> <p>Use Case: RETE engine uses this to extract bindings when condition matches: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nbindings = {}\n\ncondition.variable_bindings.each do |var, attr|\n  bindings[var] = fact[attr]\nend\n\nputs bindings  # =&gt; {:loc?=&gt;\"server_room\", :temp?=&gt;85}\n</code></pre></p>"},{"location":"api/facts/#fact-patterns","title":"Fact Patterns","text":"<p>Patterns are hashes used to match facts. They appear in: - <code>Condition.new(type, pattern)</code> - <code>Fact#matches?(pattern)</code> - Alpha memory keys</p>"},{"location":"api/facts/#pattern-structure","title":"Pattern Structure","text":"<pre><code>{\n  type: :fact_type,           # Optional: fact type constraint\n  attribute1: literal_value,   # Literal constraint\n  attribute2: :variable?,      # Variable binding\n  attribute3: -&gt;(v) { ... }    # Predicate lambda\n}\n</code></pre>"},{"location":"api/facts/#pattern-types","title":"Pattern Types","text":""},{"location":"api/facts/#1-empty-pattern","title":"1. Empty Pattern","text":"<p>Matches all facts of a type.</p> <pre><code>condition = KBS::Condition.new(:temperature)\n# Matches ANY temperature fact\n</code></pre>"},{"location":"api/facts/#2-literal-pattern","title":"2. Literal Pattern","text":"<p>Matches facts with exact attribute values.</p> <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  location: \"server_room\",\n  sensor_id: 42\n)\n\n# Matches:\nKBS::Fact.new(:temperature, location: \"server_room\", sensor_id: 42, value: 85)\n\n# Doesn't match:\nKBS::Fact.new(:temperature, location: \"lobby\", sensor_id: 42)\nKBS::Fact.new(:temperature, location: \"server_room\", sensor_id: 99)\n</code></pre>"},{"location":"api/facts/#3-predicate-pattern","title":"3. Predicate Pattern","text":"<p>Matches facts where attribute satisfies lambda.</p> <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &gt; 80 &amp;&amp; v &lt; 100 },\n  location: -&gt;(l) { l.start_with?(\"server\") }\n)\n\n# Matches:\nKBS::Fact.new(:temperature, location: \"server_room\", value: 85)\nKBS::Fact.new(:temperature, location: \"server_1\", value: 90)\n\n# Doesn't match:\nKBS::Fact.new(:temperature, location: \"server_room\", value: 110)  # value &gt; 100\nKBS::Fact.new(:temperature, location: \"lobby\", value: 85)  # location doesn't start with \"server\"\n</code></pre> <p>Important: Predicate fails if attribute is missing: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\")  # No :value\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 0 })  # =&gt; false (no :value attribute)\n</code></pre></p>"},{"location":"api/facts/#4-variable-binding-pattern","title":"4. Variable Binding Pattern","text":"<p>Variables (symbols starting with <code>?</code>) capture attribute values for use in join tests and action blocks.</p> <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  location: :loc?,\n  value: :temp?\n)\n\n# Matches ANY temperature fact, binding :loc? and :temp?\nfact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n# Bindings: {:loc? =&gt; \"server_room\", :temp? =&gt; 85}\n</code></pre>"},{"location":"api/facts/#5-mixed-pattern","title":"5. Mixed Pattern","text":"<p>Combine literals, predicates, and variables.</p> <pre><code>condition = KBS::Condition.new(\n  :temperature,\n  location: \"server_room\",      # Literal\n  value: :temp?,                # Variable\n  timestamp: -&gt;(ts) { ts &gt; cutoff_time }  # Predicate\n)\n\n# Only matches temperature facts from server_room with recent timestamp\n# Captures value in :temp? variable\n</code></pre>"},{"location":"api/facts/#pattern-matching-semantics","title":"Pattern Matching Semantics","text":""},{"location":"api/facts/#matching-algorithm","title":"Matching Algorithm","text":"<p>For <code>fact.matches?(pattern)</code>:</p> <ol> <li>Type Check: If <code>pattern[:type]</code> present, must equal <code>fact.type</code></li> <li>Attribute Checks: For each <code>key, value</code> in pattern (except <code>:type</code>):</li> <li>Variable (<code>value.is_a?(Symbol) &amp;&amp; value.to_s.start_with?('?')</code>): Always matches (captures <code>fact[key]</code>)</li> <li>Predicate (<code>value.is_a?(Proc)</code>): Must satisfy <code>value.call(fact[key])</code>. Fails if <code>fact[key]</code> is nil.</li> <li>Literal: Must equal <code>fact[key]</code></li> <li>Result: <code>true</code> if all checks pass, <code>false</code> otherwise</li> </ol>"},{"location":"api/facts/#open-world-assumption","title":"Open World Assumption","text":"<p>Facts are not required to have all attributes in the pattern. Patterns only constrain attributes they specify.</p> <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85, timestamp: Time.now)\n\n# Matches - pattern doesn't mention :timestamp\nfact.matches?(type: :temperature, location: \"server_room\")  # =&gt; true\n\n# Matches - pattern only constrains :value\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 80 })  # =&gt; true\n</code></pre> <p>But: If pattern specifies an attribute the fact lacks, match fails:</p> <pre><code>fact = KBS::Fact.new(:temperature, value: 85)  # No :location\n\n# Fails - fact missing :location attribute\nfact.matches?(type: :temperature, location: \"server_room\")  # =&gt; false\n\n# Fails - predicate can't evaluate nil\nfact.matches?(type: :temperature, location: -&gt;(l) { l.length &gt; 5 })  # =&gt; false\n\n# Succeeds - variable matches nil\nfact.matches?(type: :temperature, location: :loc?)  # =&gt; true (binds :loc? =&gt; nil)\n</code></pre>"},{"location":"api/facts/#variable-binding-extraction","title":"Variable Binding Extraction","text":"<p>Variables are extracted during condition construction:</p> <pre><code>condition = KBS::Condition.new(\n  :order,\n  symbol: :sym?,\n  quantity: :qty?,\n  price: :price?\n)\n\nputs condition.variable_bindings\n# =&gt; {:sym?=&gt;:symbol, :qty?=&gt;:quantity, :price?=&gt;:price}\n</code></pre> <p>When a fact matches, bindings are populated:</p> <pre><code>fact = KBS::Fact.new(:order, symbol: \"AAPL\", quantity: 100, price: 150.25)\n\nbindings = {}\ncondition.variable_bindings.each do |var, attr|\n  bindings[var] = fact[attr]\nend\n\nputs bindings\n# =&gt; {:sym?=&gt;\"AAPL\", :qty?=&gt;100, :price?=&gt;150.25}\n</code></pre>"},{"location":"api/facts/#predicate-constraints","title":"Predicate Constraints","text":"<p>Predicates are powerful but have caveats:</p> <p>1. Nil Attributes Fail: <pre><code>fact = KBS::Fact.new(:temperature, location: \"server_room\")  # No :value\n\n# Predicate fails - can't call lambda on nil\nfact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 0 })  # =&gt; false\n</code></pre></p> <p>2. Predicates Run on Every Match Attempt: <pre><code># This predicate runs every time a fact is checked\nexpensive_check = -&gt;(v) { complex_calculation(v) }\ncondition = KBS::Condition.new(:temperature, value: expensive_check)\n\n# For 1000 temperature facts, expensive_check runs 1000 times\n</code></pre></p> <p>3. Predicates Should Be Pure Functions: <pre><code># Bad - side effects\ncounter = 0\ncondition = KBS::Condition.new(:temperature, value: -&gt;(v) { counter += 1; v &gt; 80 })\n\n# Good - pure predicate\ncondition = KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n</code></pre></p> <p>4. Predicates Can't Access Other Attributes: <pre><code># This doesn't work - predicate only receives attribute value\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &gt; @threshold }  # @threshold from where?\n)\n\n# Use closures to capture context\nthreshold = 80\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &gt; threshold }  # Closure captures threshold\n)\n</code></pre></p>"},{"location":"api/facts/#negation-semantics","title":"Negation Semantics","text":"<p>Negated conditions match when NO fact satisfies the pattern:</p> <pre><code># Rule fires when there's NO critical alert\nrule \"all_clear\" do\n  negated :alert, level: \"critical\"  # negated: true\n  perform { puts \"All systems normal\" }\nend\n</code></pre> <p>Important: Negation matches absence, not presence of opposite:</p> <pre><code># Matches when NO alert with level=\"critical\" exists\nnegated :alert, level: \"critical\"\n\n# NOT equivalent to: Match when alert with level != \"critical\" exists\n# To match non-critical alerts, use predicate:\non :alert, level: -&gt;(l) { l != \"critical\" }\n</code></pre> <p>See Negation Guide for detailed semantics.</p>"},{"location":"api/facts/#common-patterns","title":"Common Patterns","text":""},{"location":"api/facts/#1-range-checks","title":"1. Range Checks","text":"<pre><code># Between 70 and 90\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &gt;= 70 &amp;&amp; v &lt;= 90 }\n)\n\n# Outside range\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { v &lt; 70 || v &gt; 90 }\n)\n</code></pre>"},{"location":"api/facts/#2-string-matching","title":"2. String Matching","text":"<pre><code># Starts with\ncondition = KBS::Condition.new(\n  :sensor,\n  name: -&gt;(n) { n.start_with?(\"temp_\") }\n)\n\n# Regex match\ncondition = KBS::Condition.new(\n  :sensor,\n  name: -&gt;(n) { n =~ /^sensor_\\d+$/ }\n)\n\n# Contains substring\ncondition = KBS::Condition.new(\n  :log_entry,\n  message: -&gt;(m) { m.include?(\"ERROR\") }\n)\n</code></pre>"},{"location":"api/facts/#3-collection-membership","title":"3. Collection Membership","text":"<pre><code># One of several values\nvalid_statuses = [\"pending\", \"processing\", \"completed\"]\ncondition = KBS::Condition.new(\n  :order,\n  status: -&gt;(s) { valid_statuses.include?(s) }\n)\n\n# Not in collection\ninvalid_statuses = [\"cancelled\", \"failed\"]\ncondition = KBS::Condition.new(\n  :order,\n  status: -&gt;(s) { !invalid_statuses.include?(s) }\n)\n</code></pre>"},{"location":"api/facts/#4-timestamp-checks","title":"4. Timestamp Checks","text":"<pre><code># Recent facts (last hour)\ncutoff = Time.now - 3600\ncondition = KBS::Condition.new(\n  :temperature,\n  timestamp: -&gt;(ts) { ts &gt; cutoff }\n)\n\n# Old facts (older than 1 day)\ncutoff = Time.now - 86400\ncondition = KBS::Condition.new(\n  :temperature,\n  timestamp: -&gt;(ts) { ts &lt; cutoff }\n)\n</code></pre>"},{"location":"api/facts/#5-cross-attribute-constraints-using-multiple-conditions","title":"5. Cross-Attribute Constraints (Using Multiple Conditions)","text":"<p>You can't directly compare two attributes of the same fact in one condition. Use multiple conditions:</p> <pre><code># Want: Match orders where quantity * price &gt; 10000\n# Can't do this in one condition:\n# condition = KBS::Condition.new(:order, ...)  # No way to access both :quantity and :price\n\n# Instead: Capture variables and check in action or use join test\nrule \"large_order\" do\n  on :order, quantity: :qty?, price: :price?\n  perform do |bindings|\n    total = bindings[:qty?] * bindings[:price?]\n    if total &gt; 10000\n      puts \"Large order: $#{total}\"\n    end\n  end\nend\n</code></pre>"},{"location":"api/facts/#6-nullnil-checks","title":"6. Null/Nil Checks","text":"<p>Variables capture <code>nil</code>, predicates fail on <code>nil</code>:</p> <pre><code># Match facts with ANY value for :location (including nil)\ncondition = KBS::Condition.new(:temperature, location: :loc?)\n# Matches fact.new(:temperature, location: nil)  \u2192 binds :loc? =&gt; nil\n# Matches fact.new(:temperature)  \u2192 binds :loc? =&gt; nil\n\n# Match facts with NON-NIL :location\ncondition = KBS::Condition.new(\n  :temperature,\n  location: -&gt;(l) { !l.nil? }\n)\n# Fails fact.new(:temperature, location: nil)\n# Fails fact.new(:temperature)  (no :location attribute)\n</code></pre>"},{"location":"api/facts/#performance-tips","title":"Performance Tips","text":""},{"location":"api/facts/#1-order-predicates-by-selectivity","title":"1. Order Predicates by Selectivity","text":"<pre><code># Good - Most selective predicate first\ncondition = KBS::Condition.new(\n  :temperature,\n  sensor_id: 42,              # Likely filters to 1 fact\n  value: -&gt;(v) { v &gt; 80 }     # Then check value\n)\n\n# Less optimal - Expensive check first\ncondition = KBS::Condition.new(\n  :temperature,\n  value: -&gt;(v) { expensive_calculation(v) },  # Runs on many facts\n  sensor_id: 42               # Could have filtered first\n)\n</code></pre> <p>Note: Within a single condition, Ruby evaluates hash in insertion order (Ruby 1.9+), but RETE evaluates all constraints anyway. The real optimization is condition ordering in rules.</p>"},{"location":"api/facts/#2-avoid-expensive-predicates","title":"2. Avoid Expensive Predicates","text":"<pre><code># Bad - Complex regex on every fact\ncondition = KBS::Condition.new(\n  :log_entry,\n  message: -&gt;(m) { m =~ /very.*complex.*regex.*pattern/ }\n)\n\n# Better - Simple check first, complex check in action\nrule \"complex_log_analysis\" do\n  on :log_entry, level: \"ERROR\", message: :msg?  # Simple literal filter\n  perform do |bindings|\n    if bindings[:msg?] =~ /very.*complex.*regex.*pattern/\n      # Expensive check runs only on ERROR logs\n    end\n  end\nend\n</code></pre>"},{"location":"api/facts/#3-use-literals-when-possible","title":"3. Use Literals When Possible","text":"<p>Literals are fastest (hash equality check). Predicates are slower (lambda call).</p> <pre><code># Fast\ncondition = KBS::Condition.new(:temperature, location: \"server_room\")\n\n# Slower (but necessary for ranges/complex checks)\ncondition = KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n</code></pre>"},{"location":"api/facts/#testing-patterns","title":"Testing Patterns","text":""},{"location":"api/facts/#testing-fact-matching","title":"Testing Fact Matching","text":"<pre><code>require 'minitest/autorun'\n\nclass TestFactMatching &lt; Minitest::Test\n  def test_literal_match\n    fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n    assert fact.matches?(type: :temperature)\n    assert fact.matches?(type: :temperature, location: \"server_room\")\n    refute fact.matches?(type: :temperature, location: \"lobby\")\n  end\n\n  def test_predicate_match\n    fact = KBS::Fact.new(:temperature, value: 85)\n\n    assert fact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 80 })\n    refute fact.matches?(type: :temperature, value: -&gt;(v) { v &gt; 100 })\n  end\n\n  def test_variable_binding\n    fact = KBS::Fact.new(:temperature, location: \"server_room\", value: 85)\n\n    # Variables always match\n    assert fact.matches?(type: :temperature, location: :loc?, value: :temp?)\n  end\n\n  def test_missing_attribute\n    fact = KBS::Fact.new(:temperature, value: 85)  # No :location\n\n    # Literal fails on missing\n    refute fact.matches?(type: :temperature, location: \"server_room\")\n\n    # Predicate fails on missing\n    refute fact.matches?(type: :temperature, location: -&gt;(l) { l.length &gt; 0 })\n\n    # Variable succeeds on missing (binds to nil)\n    assert fact.matches?(type: :temperature, location: :loc?)\n  end\nend\n</code></pre>"},{"location":"api/facts/#testing-variable-extraction","title":"Testing Variable Extraction","text":"<pre><code>class TestVariableExtraction &lt; Minitest::Test\n  def test_variable_bindings\n    condition = KBS::Condition.new(\n      :temperature,\n      location: :loc?,\n      value: :temp?\n    )\n\n    expected = { :loc? =&gt; :location, :temp? =&gt; :value }\n    assert_equal expected, condition.variable_bindings\n  end\n\n  def test_no_variables\n    condition = KBS::Condition.new(:temperature, location: \"server_room\")\n\n    assert_empty condition.variable_bindings\n  end\nend\n</code></pre>"},{"location":"api/facts/#see-also","title":"See Also","text":"<ul> <li>Engine API - Adding facts to engines</li> <li>Rules API - Using conditions in rules</li> <li>Pattern Matching Guide - Detailed pattern semantics</li> <li>Variable Binding Guide - Join tests and bindings</li> <li>DSL Guide - Declarative condition syntax</li> </ul>"},{"location":"api/rules/","title":"Rules API Reference","text":"<p>Complete API reference for rule classes in KBS.</p>"},{"location":"api/rules/#table-of-contents","title":"Table of Contents","text":"<ul> <li>KBS::Rule - Production rule with conditions and action</li> <li>Rule Lifecycle</li> <li>Rule Patterns</li> <li>Best Practices</li> </ul>"},{"location":"api/rules/#kbsrule","title":"KBS::Rule","text":"<p>A production rule that fires when all conditions match.</p> <p>Structure: A rule consists of: 1. Name - Unique identifier 2. Priority - Execution order (higher = more urgent) 3. Conditions - Array of patterns to match 4. Action - Lambda executed when all conditions match</p>"},{"location":"api/rules/#constructor","title":"Constructor","text":""},{"location":"api/rules/#initializename-conditions-action-nil-priority-0-block","title":"<code>initialize(name, conditions: [], action: nil, priority: 0, &amp;block)</code>","text":"<p>Creates a new rule.</p> <p>Parameters: - <code>name</code> (Symbol or String) - Unique rule identifier - <code>conditions</code> (Array, optional) - Conditions to match (default: <code>[]</code>) - <code>action</code> (Proc, optional) - Action lambda to execute (default: <code>nil</code>) - <code>priority</code> (Integer, optional) - Rule priority (default: <code>0</code>) - <code>&amp;block</code> (Block, optional) - Configuration block yielding self <p>Returns: <code>KBS::Rule</code> instance</p> <p>Example - Direct Construction: <pre><code># Minimal rule\nrule = KBS::Rule.new(:high_temperature)\n\n# Rule with all parameters\nrule = KBS::Rule.new(\n  :high_temperature,\n  conditions: [\n    KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n  ],\n  action: -&gt;(facts) { puts \"High temperature detected!\" },\n  priority: 10\n)\n</code></pre></p> <p>Example - Block Configuration: <pre><code>rule = KBS::Rule.new(:high_temperature) do |r|\n  r.conditions &lt;&lt; KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n  r.action = -&gt;(facts) { puts \"High temperature: #{facts[0][:value]}\" }\nend\n</code></pre></p> <p>Example - Using DSL (recommended): <pre><code>kb = KBS.knowledge_base do\n  rule \"high_temperature\", priority: 10 do\n    on :temperature, value: greater_than(80)\n    perform do |bindings|\n      puts \"High temperature: #{bindings[:value?]}\"\n    end\n  end\nend\n\n# Add to engine\nkb.rules.each { |r| engine.add_rule(r) }\n</code></pre></p>"},{"location":"api/rules/#public-attributes","title":"Public Attributes","text":""},{"location":"api/rules/#name","title":"<code>name</code>","text":"<p>Type: <code>Symbol</code> or <code>String</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Unique rule identifier</p> <p>Example: <pre><code>rule = KBS::Rule.new(:high_temperature, priority: 10)\nputs rule.name  # =&gt; :high_temperature\n</code></pre></p> <p>Best Practice: Use descriptive names that indicate the rule's purpose: <pre><code># Good\n:high_temperature_alert\n:low_inventory_reorder\n:fraud_detection_high_risk\n\n# Less clear\n:rule1\n:temp_rule\n:check\n</code></pre></p>"},{"location":"api/rules/#priority","title":"<code>priority</code>","text":"<p>Type: <code>Integer</code></p> <p>Read-only: Yes (via <code>attr_reader</code>)</p> <p>Description: Rule priority (higher = executes first in KBS::Blackboard::Engine)</p> <p>Default: <code>0</code></p> <p>Range: Any integer (commonly 0-100)</p> <p>Example: <pre><code>rule = KBS::Rule.new(:critical_alert, priority: 100)\nputs rule.priority  # =&gt; 100\n</code></pre></p> <p>Priority Semantics: - KBS::Engine: Priority is stored but NOT used for execution order (rules fire in arbitrary order) - KBS::Blackboard::Engine: Higher priority rules fire first within production nodes</p> <p>Common Priority Ranges: <pre><code># Critical safety rules\npriority: 100\n\n# Important business rules\npriority: 50\n\n# Standard rules\npriority: 10\n\n# Cleanup/logging rules\npriority: 0\n\n# Background tasks\npriority: -10\n</code></pre></p> <p>Example - Priority Ordering: <pre><code>kb = KBS.knowledge_base do\n  rule \"log_temperature\", priority: 0 do\n    on :temperature, value: :temp?\n    perform { |b| puts \"Logged: #{b[:temp?]}\" }\n  end\n\n  rule \"critical_alert\", priority: 100 do\n    on :temperature, value: greater_than(100)\n    perform { puts \"CRITICAL TEMPERATURE!\" }\n  end\n\n  rule \"high_alert\", priority: 50 do\n    on :temperature, value: greater_than(80)\n    perform { puts \"High temperature warning\" }\n  end\nend\n\nengine = KBS::Blackboard::Engine.new\nkb.rules.each { |r| engine.add_rule(r) }\nengine.add_fact(:temperature, value: 110)\nengine.run\n\n# Output (in priority order):\n# CRITICAL TEMPERATURE!      (priority 100)\n# High temperature warning   (priority 50)\n# Logged: 110                (priority 0)\n</code></pre></p>"},{"location":"api/rules/#conditions","title":"<code>conditions</code>","text":"<p>Type: <code>Array&lt;KBS::Condition&gt;</code></p> <p>Read/Write: Yes (via <code>attr_accessor</code>)</p> <p>Description: Array of conditions that must all match for rule to fire</p> <p>Example: <pre><code>rule = KBS::Rule.new(:temperature_alert)\nrule.conditions &lt;&lt; KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\nrule.conditions &lt;&lt; KBS::Condition.new(:sensor, status: \"active\")\n\nputs rule.conditions.size  # =&gt; 2\n</code></pre></p> <p>Condition Order Matters (for performance): <pre><code># Good - Most selective condition first\nrule.conditions = [\n  KBS::Condition.new(:sensor, id: 42),             # Filters to 1 fact\n  KBS::Condition.new(:temperature, value: :temp?)  # Then match temperature\n]\n\n# Less optimal - Less selective first\nrule.conditions = [\n  KBS::Condition.new(:temperature, value: :temp?),  # Matches many facts\n  KBS::Condition.new(:sensor, id: 42)               # Could have filtered first\n]\n</code></pre></p> <p>See Performance Guide for condition ordering strategies.</p>"},{"location":"api/rules/#action","title":"<code>action</code>","text":"<p>Type: <code>Proc</code> (lambda or proc)</p> <p>Read/Write: Yes (via <code>attr_accessor</code>)</p> <p>Description: Lambda executed when all conditions match</p> <p>Signature: <code>action.call(facts)</code> or <code>action.call(facts, bindings)</code> (both supported)</p> <p>Parameters: - <code>facts</code> (Array) - Array of matched facts (parallel to conditions array) - <code>bindings</code> (Hash, optional) - Variable bindings extracted from facts <p>Example - Facts Parameter: <pre><code>rule.action = -&gt;(facts) do\n  temp_fact = facts[0]  # First condition's matched fact\n  sensor_fact = facts[1]  # Second condition's matched fact\n\n  puts \"Temperature: #{temp_fact[:value]} from sensor #{sensor_fact[:id]}\"\nend\n</code></pre></p> <p>Example - Bindings Parameter: <pre><code># Rule with variable bindings\nrule = KBS::Rule.new(:temperature_alert) do |r|\n  r.conditions &lt;&lt; KBS::Condition.new(:temperature, value: :temp?, location: :loc?)\n  r.action = -&gt;(facts, bindings) do\n    # bindings: {:temp? =&gt; 85, :loc? =&gt; \"server_room\"}\n    puts \"#{bindings[:loc?]}: #{bindings[:temp?]}\u00b0F\"\n  end\nend\n</code></pre></p> <p>Example - DSL Preferred: <pre><code>rule \"temperature_alert\" do\n  on :temperature, value: :temp?, location: :loc?\n  perform do |bindings|\n    # Cleaner - DSL automatically provides bindings\n    puts \"#{bindings[:loc?]}: #{bindings[:temp?]}\u00b0F\"\n  end\nend\n</code></pre></p> <p>Action Requirements: - Must be a Proc (lambda or proc) - Should be idempotent if possible (safe to run multiple times) - Should not modify facts directly (use <code>engine.add_fact</code> / <code>engine.remove_fact</code> instead) - May add/remove facts (triggers new rule evaluation)</p>"},{"location":"api/rules/#public-methods","title":"Public Methods","text":""},{"location":"api/rules/#firefacts","title":"<code>fire(facts)</code>","text":"<p>Executes the rule's action with matched facts.</p> <p>Parameters: - <code>facts</code> (Array) - Matched facts (one per condition) <p>Returns: Result of action lambda, or <code>nil</code> if no action</p> <p>Side Effects: - Increments internal <code>@fired_count</code> - Executes action lambda - Action may modify external state, add/remove facts, etc.</p> <p>Example: <pre><code>rule = KBS::Rule.new(:log_temperature) do |r|\n  r.conditions &lt;&lt; KBS::Condition.new(:temperature, value: :temp?)\n  r.action = -&gt;(facts, bindings) do\n    puts \"Temperature: #{bindings[:temp?]}\"\n  end\nend\n\nfact = KBS::Fact.new(:temperature, value: 85)\nrule.fire([fact])\n# Output: Temperature: 85\n</code></pre></p> <p>Note: Typically called by the RETE engine, not user code. Users call <code>engine.run</code> which fires all activated rules.</p>"},{"location":"api/rules/#rule-lifecycle","title":"Rule Lifecycle","text":""},{"location":"api/rules/#1-rule-creation","title":"1. Rule Creation","text":"<pre><code># Via DSL (recommended)\nkb = KBS.knowledge_base do\n  rule \"my_rule\", priority: 10 do\n    on :temperature, value: :temp?\n    perform { |b| puts b[:temp?] }\n  end\nend\n\n# Or programmatically\nrule = KBS::Rule.new(\n  :my_rule,\n  conditions: [KBS::Condition.new(:temperature, value: :temp?)],\n  action: -&gt;(facts) { puts facts[0][:value] },\n  priority: 10\n)\n</code></pre>"},{"location":"api/rules/#2-rule-registration","title":"2. Rule Registration","text":"<pre><code>engine.add_rule(rule)\n# Internally:\n# - Adds rule to @rules array\n# - Compiles rule into RETE network\n# - Creates alpha memories for condition patterns\n# - Creates join nodes (or negation nodes)\n# - Creates production node for rule\n# - Activates existing facts through new network\n</code></pre>"},{"location":"api/rules/#3-rule-activation","title":"3. Rule Activation","text":"<pre><code>engine.add_fact(:temperature, value: 85)\n# Internally:\n# - Fact activates matching alpha memories\n# - Propagates through join nodes\n# - Creates tokens in beta memories\n# - Token reaches production node\n# - Rule is \"activated\" (ready to fire)\n</code></pre>"},{"location":"api/rules/#4-rule-firing","title":"4. Rule Firing","text":"<pre><code>engine.run\n# Internally (KBS::Engine):\n# - Iterates production nodes\n# - For each token in production node:\n#   - Calls rule.fire(token.facts)\n#   - Executes action lambda\n\n# Internally (KBS::Blackboard::Engine):\n# - Same as above, but:\n#   - Logs rule firing to audit trail\n#   - Marks token as fired (prevents duplicate firing)\n#   - Records variable bindings\n</code></pre>"},{"location":"api/rules/#5-rule-re-firing","title":"5. Rule Re-firing","text":"<p>Rules can fire multiple times:</p> <pre><code>rule \"log_temperature\" do\n  on :temperature, value: :temp?\n  perform { |b| puts \"Temperature: #{b[:temp?]}\" }\nend\n\nengine.add_fact(:temperature, value: 85)\nengine.add_fact(:temperature, value: 90)\nengine.add_fact(:temperature, value: 95)\nengine.run\n\n# Output:\n# Temperature: 85\n# Temperature: 90\n# Temperature: 95\n</code></pre> <p>Each fact creates a separate activation (token) that fires independently.</p>"},{"location":"api/rules/#rule-patterns","title":"Rule Patterns","text":""},{"location":"api/rules/#1-simple-rule-one-condition","title":"1. Simple Rule (One Condition)","text":"<p>Match single fact type:</p> <pre><code>rule \"log_all_temperatures\" do\n  on :temperature, value: :temp?\n  perform do |bindings|\n    puts \"Temperature: #{bindings[:temp?]}\"\n  end\nend\n</code></pre>"},{"location":"api/rules/#2-join-rule-multiple-conditions","title":"2. Join Rule (Multiple Conditions)","text":"<p>Match multiple related facts:</p> <pre><code>rule \"sensor_temperature_alert\" do\n  on :sensor, id: :sensor_id?, status: \"active\"\n  on :temperature, sensor_id: :sensor_id?, value: greater_than(80)\n  perform do |bindings|\n    puts \"Sensor #{bindings[:sensor_id?]} reports high temperature\"\n  end\nend\n\n# Matches when:\n# - sensor fact with id=42, status=\"active\" exists\n# - temperature fact with sensor_id=42, value &gt; 80 exists\n</code></pre> <p>Variable Binding: <code>:sensor_id?</code> in first condition must equal <code>sensor_id</code> in second condition (join test).</p>"},{"location":"api/rules/#3-guard-rule-negation","title":"3. Guard Rule (Negation)","text":"<p>Match when fact is absent:</p> <pre><code>rule \"all_clear\" do\n  on :system, status: \"running\"\n  negated :alert, level: \"critical\"  # Fire when NO critical alerts exist\n  perform do\n    puts \"All systems normal\"\n  end\nend\n</code></pre>"},{"location":"api/rules/#4-state-machine-rule","title":"4. State Machine Rule","text":"<p>Rules can implement state transitions:</p> <pre><code>rule \"pending_to_processing\" do\n  on :order, id: :order_id?, status: \"pending\"\n  on :worker, status: \"available\", id: :worker_id?\n  perform do |bindings|\n    # Transition order to processing\n    order = find_order(bindings[:order_id?])\n    order.update(status: \"processing\", worker_id: bindings[:worker_id?])\n\n    # Update worker\n    worker = find_worker(bindings[:worker_id?])\n    worker.update(status: \"busy\")\n  end\nend\n</code></pre>"},{"location":"api/rules/#5-cleanup-rule","title":"5. Cleanup Rule","text":"<p>Low-priority rules that clean up old facts:</p> <pre><code>rule \"expire_old_temperatures\", priority: 0 do\n  on :temperature, timestamp: less_than(Time.now - 3600)\n  perform do |bindings|\n    fact = bindings[:matched_fact?]\n    fact.retract  # Remove old temperature reading\n  end\nend\n</code></pre>"},{"location":"api/rules/#6-aggregation-rule","title":"6. Aggregation Rule","text":"<p>Collect multiple facts and compute aggregate:</p> <pre><code>rule \"daily_temperature_summary\", priority: 5 do\n  on :trigger, event: \"end_of_day\"\n  perform do\n    temps = engine.working_memory.facts\n      .select { |f| f.type == :temperature }\n      .map { |f| f[:value] }\n\n    avg = temps.sum / temps.size.to_f\n    max = temps.max\n    min = temps.min\n\n    engine.add_fact(:daily_summary, avg: avg, max: max, min: min, date: Date.today)\n  end\nend\n</code></pre>"},{"location":"api/rules/#7-conflict-resolution-rule","title":"7. Conflict Resolution Rule","text":"<p>Higher priority rule overrides lower priority:</p> <pre><code>rule \"high_risk_order\", priority: 100 do\n  on :order, id: :order_id?, total: greater_than(10000)\n  perform do |bindings|\n    puts \"HIGH RISK: Order #{bindings[:order_id?]} requires manual review\"\n    # This fires first due to priority\n  end\nend\n\nrule \"auto_approve_order\", priority: 10 do\n  on :order, id: :order_id?, status: \"pending\"\n  perform do |bindings|\n    puts \"Auto-approving order #{bindings[:order_id?]}\"\n    # This fires later (if at all)\n  end\nend\n</code></pre>"},{"location":"api/rules/#8-recursive-rule","title":"8. Recursive Rule","text":"<p>Rule that adds facts triggering other rules:</p> <pre><code>rule \"calculate_fibonacci\" do\n  on :fib_request, n: :n?\n  negated :fib_result, n: :n?  # Not already calculated\n  perform do |bindings|\n    n = bindings[:n?]\n\n    if n &lt;= 1\n      engine.add_fact(:fib_result, n: n, value: n)\n    else\n      # Request sub-problems\n      engine.add_fact(:fib_request, n: n - 1)\n      engine.add_fact(:fib_request, n: n - 2)\n\n      # Wait for sub-results in another rule...\n    end\n  end\nend\n\nrule \"combine_fibonacci\" do\n  on :fib_request, n: :n?\n  on :fib_result, n: :n_minus_1?, value: :val1?\n  on :fib_result, n: :n_minus_2?, value: :val2?\n  # ... (complex join test: ?n_minus_1 == ?n - 1, etc.)\n  perform do |bindings|\n    result = bindings[:val1?] + bindings[:val2?]\n    engine.add_fact(:fib_result, n: bindings[:n?], value: result)\n  end\nend\n</code></pre>"},{"location":"api/rules/#best-practices","title":"Best Practices","text":""},{"location":"api/rules/#1-descriptive-rule-names","title":"1. Descriptive Rule Names","text":"<pre><code># Good\nrule \"high_temperature_alert\"\nrule \"low_inventory_reorder\"\nrule \"fraud_detection_suspicious_transaction\"\n\n# Bad\nrule \"rule1\"\nrule \"temp\"\nrule \"check\"\n</code></pre>"},{"location":"api/rules/#2-order-conditions-by-selectivity","title":"2. Order Conditions by Selectivity","text":"<p>Most selective (fewest matching facts) first:</p> <pre><code># Good - sensor_id=42 filters to ~1 fact\nrule \"sensor_alert\" do\n  on :sensor, id: 42, status: :status?              # Very selective\n  on :temperature, sensor_id: 42, value: :temp?     # Also selective\n  perform { ... }\nend\n\n# Bad - :temperature matches many facts\nrule \"sensor_alert\" do\n  on :temperature, value: :temp?                    # Matches 1000s of facts\n  on :sensor, id: 42, status: :status?              # Could have filtered first\n  perform { ... }\nend\n</code></pre> <p>Why: RETE builds network from first to last condition. Fewer intermediate tokens = faster.</p>"},{"location":"api/rules/#3-use-priority-for-critical-rules","title":"3. Use Priority for Critical Rules","text":"<pre><code>rule \"critical_shutdown\", priority: 1000 do\n  on :temperature, value: greater_than(120)\n  perform { shutdown_system! }\nend\n\nrule \"log_temperature\", priority: 0 do\n  on :temperature, value: :temp?\n  perform { |b| log(b[:temp?]) }\nend\n</code></pre> <p>Critical safety rules should have high priority to fire before less important rules.</p>"},{"location":"api/rules/#4-keep-actions-idempotent","title":"4. Keep Actions Idempotent","text":"<pre><code># Good - Idempotent (safe to run multiple times)\nrule \"alert_high_temp\" do\n  on :temperature, value: greater_than(80)\n  perform do |bindings|\n    # Check if alert already sent\n    unless alert_sent?(bindings[:temp?])\n      send_alert(bindings[:temp?])\n      mark_alert_sent(bindings[:temp?])\n    end\n  end\nend\n\n# Bad - Not idempotent (sends duplicate alerts)\nrule \"alert_high_temp\" do\n  on :temperature, value: greater_than(80)\n  perform do |bindings|\n    send_alert(bindings[:temp?])  # Sends every time rule fires\n  end\nend\n</code></pre>"},{"location":"api/rules/#5-avoid-side-effects-in-conditions","title":"5. Avoid Side Effects in Conditions","text":"<pre><code># Bad - Side effect in condition predicate\ncounter = 0\nrule \"count_temps\" do\n  on :temperature, value: -&gt;(v) { counter += 1; v &gt; 80 }  # BAD!\n  perform { puts \"Count: #{counter}\" }\nend\n\n# Good - Side effects in action only\ncounter = 0\nrule \"count_temps\" do\n  on :temperature, value: greater_than(80)\n  perform { counter += 1; puts \"Count: #{counter}\" }\nend\n</code></pre> <p>Why: Predicates run during pattern matching (potentially multiple times). Side effects cause unpredictable behavior.</p>"},{"location":"api/rules/#6-use-variable-bindings-for-joins","title":"6. Use Variable Bindings for Joins","text":"<pre><code># Good - Variable binding creates join test\nrule \"order_inventory_check\" do\n  on :order, product_id: :pid?, quantity: :qty?\n  on :inventory, product_id: :pid?, available: :available?\n  perform do |bindings|\n    if bindings[:available?] &lt; bindings[:qty?]\n      puts \"Insufficient inventory for product #{bindings[:pid?]}\"\n    end\n  end\nend\n\n# Bad - No join test (matches all combinations)\nrule \"order_inventory_check\" do\n  on :order, product_id: :pid1?, quantity: :qty?\n  on :inventory, product_id: :pid2?, available: :available?\n  perform do |bindings|\n    # No guarantee pid1 == pid2!\n    if bindings[:pid1?] == bindings[:pid2?]  # Manual check in action (inefficient)\n      ...\n    end\n  end\nend\n</code></pre>"},{"location":"api/rules/#7-document-complex-rules","title":"7. Document Complex Rules","text":"<pre><code># Good - Documented\nrule \"portfolio_rebalancing\", priority: 50 do\n  # Triggers when portfolio drift exceeds threshold\n  # Conditions:\n  # 1. Portfolio exists and is active\n  # 2. Current allocation deviates &gt; 5% from target\n  # Action:\n  # - Calculates rebalancing trades\n  # - Creates pending orders\n\n  on :portfolio, id: :portfolio_id?, status: \"active\"\n  on :drift_calculation, portfolio_id: :portfolio_id?, drift: greater_than(0.05)\n  perform do |bindings|\n    # Implementation...\n  end\nend\n</code></pre>"},{"location":"api/rules/#8-test-rules-in-isolation","title":"8. Test Rules in Isolation","text":"<pre><code>require 'minitest/autorun'\n\nclass TestHighTemperatureRule &lt; Minitest::Test\n  def setup\n    @engine = KBS::Blackboard::Engine.new\n    @fired = false\n\n    @rule = KBS::Rule.new(:high_temp) do |r|\n      r.conditions &lt;&lt; KBS::Condition.new(:temperature, value: -&gt;(v) { v &gt; 80 })\n      r.action = -&gt;(facts) { @fired = true }\n    end\n\n    @engine.add_rule(@rule)\n  end\n\n  def test_fires_when_temperature_high\n    @engine.add_fact(:temperature, value: 85)\n    @engine.run\n    assert @fired\n  end\n\n  def test_does_not_fire_when_temperature_low\n    @engine.add_fact(:temperature, value: 75)\n    @engine.run\n    refute @fired\n  end\nend\n</code></pre>"},{"location":"api/rules/#9-use-negation-for-guards","title":"9. Use Negation for Guards","text":"<pre><code># Good - Negation ensures system ready\nrule \"start_processing\" do\n  on :work_item, status: \"pending\"\n  negated :system_error  # Don't process if system has errors\n  perform { process_work_item }\nend\n\n# Alternative - Check in action (less efficient)\nrule \"start_processing\" do\n  on :work_item, status: \"pending\"\n  perform do\n    unless system_has_errors?\n      process_work_item\n    end\n  end\nend\n</code></pre> <p>Why: Negation in condition prevents token creation. Action-based check still creates token (wastes memory).</p>"},{"location":"api/rules/#10-limit-fact-growth","title":"10. Limit Fact Growth","text":"<pre><code># Good - Cleanup rule prevents unbounded growth\nrule \"expire_old_facts\", priority: 0 do\n  on :temperature, timestamp: less_than(Time.now - 3600)\n  perform do |bindings|\n    fact = bindings[:matched_fact?]\n    fact.retract\n  end\nend\n\n# Bad - No cleanup (memory leak)\nloop do\n  engine.add_fact(:temperature, value: rand(100), timestamp: Time.now)\n  engine.run\n  sleep 1\n  # Facts accumulate forever!\nend\n</code></pre>"},{"location":"api/rules/#common-patterns-reference","title":"Common Patterns Reference","text":""},{"location":"api/rules/#rule-priority-examples","title":"Rule Priority Examples","text":"<pre><code># Emergency shutdown\npriority: 1000\n\n# Critical alerts\npriority: 500\n\n# Business logic\npriority: 100\n\n# Data validation\npriority: 50\n\n# Standard processing\npriority: 10\n\n# Logging/auditing\npriority: 5\n\n# Cleanup\npriority: 0\n</code></pre>"},{"location":"api/rules/#action-signatures","title":"Action Signatures","text":"<pre><code># 1. Facts only\naction: -&gt;(facts) do\n  temp_fact = facts[0]\n  puts temp_fact[:value]\nend\n\n# 2. Facts and bindings (recommended)\naction: -&gt;(facts, bindings) do\n  puts bindings[:temp?]\nend\n\n# 3. DSL style (cleanest)\nperform do |bindings|\n  puts bindings[:temp?]\nend\n</code></pre>"},{"location":"api/rules/#condition-patterns","title":"Condition Patterns","text":"<pre><code># Literal matching\non :temperature, location: \"server_room\"\n\n# Range check\non :temperature, value: between(70, 90)\non :temperature, value: greater_than(80)\non :temperature, value: less_than(100)\n\n# Variable binding\non :temperature, location: :loc?, value: :temp?\n\n# Predicate\non :temperature, value: -&gt;(v) { v &gt; 80 &amp;&amp; v &lt; 100 }\n\n# Negation\nnegated :alert, level: \"critical\"\n\n# Collection membership\non :order, status: one_of(\"pending\", \"processing\", \"completed\")\n</code></pre>"},{"location":"api/rules/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/rules/#rule-compilation-cost","title":"Rule Compilation Cost","text":"<p>Adding a rule to the engine compiles it into the RETE network:</p> <pre><code># Cost: O(C) where C = number of conditions\nengine.add_rule(rule)\n</code></pre> <p>Optimization: Add all rules before adding facts:</p> <pre><code># Good\nkb.rules.each { |r| engine.add_rule(r) }  # Compile all rules first\nfacts.each { |f| engine.add_fact(f.type, f.attributes) }  # Then add facts\nengine.run\n\n# Less optimal\nfacts.each do |f|\n  engine.add_fact(f.type, f.attributes)\n  kb.rules.each { |r| engine.add_rule(r) }  # Recompiling for each fact!\n  engine.run\nend\n</code></pre>"},{"location":"api/rules/#condition-ordering","title":"Condition Ordering","text":"<p>Order conditions from most to least selective:</p> <pre><code># Assume:\n# - 10,000 temperature facts\n# - 100 sensor facts\n# - 10 sensors with id=42\n\n# Good (selective first)\nrule \"alert\" do\n  on :sensor, id: 42, status: :status?        # Filters to 10 facts\n  on :temperature, sensor_id: 42, value: :v?  # Then filters to ~100 facts\n  # Creates ~10 intermediate tokens\nend\n\n# Bad (unselective first)\nrule \"alert\" do\n  on :temperature, value: :v?                 # Matches 10,000 facts!\n  on :sensor, id: 42, status: :status?        # Then filters\n  # Creates 10,000 intermediate tokens (slow, memory-intensive)\nend\n</code></pre>"},{"location":"api/rules/#action-complexity","title":"Action Complexity","text":"<p>Keep actions fast:</p> <pre><code># Good - Fast action\nperform do |bindings|\n  puts \"Temperature: #{bindings[:temp?]}\"\nend\n\n# Bad - Slow action blocks engine\nperform do |bindings|\n  sleep 5  # Blocks engine for 5 seconds!\n  send_email_alert(bindings[:temp?])  # Network I/O\nend\n\n# Better - Offload slow work\nperform do |bindings|\n  # Post message for async worker\n  engine.post_message(\"alert_system\", \"email_queue\", bindings)\nend\n</code></pre>"},{"location":"api/rules/#debugging-rules","title":"Debugging Rules","text":""},{"location":"api/rules/#why-didnt-my-rule-fire","title":"Why Didn't My Rule Fire?","text":"<pre><code>def debug_rule(engine, rule_name)\n  rule = engine.rules.find { |r| r.name == rule_name }\n  return \"Rule not found\" unless rule\n\n  puts \"Rule: #{rule.name}\"\n  puts \"Conditions (#{rule.conditions.size}):\"\n\n  rule.conditions.each_with_index do |cond, i|\n    matching_facts = engine.working_memory.facts.select { |f| f.matches?(cond.pattern.merge(type: cond.type)) }\n\n    puts \"  #{i + 1}. #{cond.type} #{cond.pattern}\"\n    puts \"     Negated: #{cond.negated}\"\n    puts \"     Matching facts: #{matching_facts.size}\"\n\n    if matching_facts.empty?\n      puts \"     \u274c NO MATCHING FACTS (rule can't fire)\"\n    else\n      puts \"     \u2713 #{matching_facts.size} facts match\"\n      matching_facts.first(3).each do |f|\n        puts \"       - #{f}\"\n      end\n    end\n  end\n\n  # Check production node\n  prod_node = engine.production_nodes[rule.name]\n  if prod_node\n    puts \"Production node activations: #{prod_node.tokens.size}\"\n  else\n    puts \"Production node not found (rule not compiled?)\"\n  end\nend\n\ndebug_rule(engine, :high_temperature)\n</code></pre>"},{"location":"api/rules/#see-also","title":"See Also","text":"<ul> <li>Engine API - Registering and running rules</li> <li>Facts API - Understanding fact matching</li> <li>DSL Guide - Declarative rule syntax</li> <li>Writing Rules Guide - Best practices and patterns</li> <li>Performance Guide - Optimization strategies</li> <li>Testing Guide - Testing rules in isolation</li> </ul>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>KBS is built on a layered architecture that separates concerns while maintaining high performance.</p>"},{"location":"architecture/#system-layers","title":"System Layers","text":"<p>KBS uses a layered architecture where facts flow from your application through the DSL, RETE engine, and working memory to one of two storage backends.</p>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#1-rete-engine","title":"1. RETE Engine","text":"<p>The heart of KBS. Implements Charles Forgy's RETE algorithm with modern optimizations.</p> <p>Key Files: - <code>lib/kbs/rete_engine.rb</code> - Main engine coordinator - <code>lib/kbs/alpha_memory.rb</code> - Pattern-level fact storage - <code>lib/kbs/beta_memory.rb</code> - Token (partial match) storage - <code>lib/kbs/join_node.rb</code> - Inter-condition joins - <code>lib/kbs/negation_node.rb</code> - Negated condition handling - <code>lib/kbs/production_node.rb</code> - Rule firing coordination</p> <p>Responsibilities: - Compile rules into discrimination networks - Propagate fact changes through the network - Maintain partial matches (tokens) - Fire rules when all conditions are satisfied</p> <p>Learn more: RETE Algorithm Details</p>"},{"location":"architecture/#2-working-memory","title":"2. Working Memory","text":"<p>Stores facts and notifies the RETE engine of changes using the Observer pattern.</p> <p>Variants: - <code>WorkingMemory</code>: Transient in-memory storage - <code>Blackboard::Memory</code>: Persistent storage with audit trails</p> <p>Responsibilities: - Store facts - Notify observers when facts are added/removed - Support queries and bulk operations</p> <p>Learn more: Blackboard Architecture</p>"},{"location":"architecture/#3-dsl-layer","title":"3. DSL Layer","text":"<p>Provides a Ruby-native interface for defining rules, conditions, and patterns.</p> <p>Key Classes: - <code>Rule</code> - Production rule with conditions and actions - <code>Condition</code> - Pattern specification for fact matching - <code>Fact</code> - Knowledge representation unit</p> <p>Example: <pre><code>Rule.new(\"alert\") do |r|\n  r.conditions = [\n    Condition.new(:sensor, { temp: :t? }),\n    Condition.new(:threshold, { max: :max? })\n  ]\n\n  r.action = lambda { |facts, bindings|\n    puts \"Alert!\" if bindings[:t?] &gt; bindings[:max?]\n  }\nend\n</code></pre></p>"},{"location":"architecture/#4-blackboard-system","title":"4. Blackboard System","text":"<p>Multi-agent collaboration framework with persistent shared memory.</p> <p>Components: - Memory - Central workspace for facts - MessageQueue - Priority-based agent communication - AuditLog - Complete history of changes - Persistence - Pluggable storage backends (SQLite, Redis, Hybrid)</p> <p>Use Cases: - Multi-agent problem solving - Audit requirements - Long-running systems - Distributed reasoning</p> <p>Learn more: Blackboard System Details</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#adding-a-fact","title":"Adding a Fact","text":"<pre><code>User Code\n   \u2502\n   \u251c\u2500\u2192 engine.add_fact(:stock, price: 150)\n   \u2502\n   \u25bc\nWorkingMemory.add_fact(fact)\n   \u2502\n   \u251c\u2500\u2192 @facts &lt;&lt; fact\n   \u2514\u2500\u2192 notify_observers(:add, fact)\n          \u2502\n          \u25bc\n       Engine.update(:add, fact)\n          \u2502\n          \u2514\u2500\u2192 For each AlphaMemory:\n                 if fact.matches?(pattern)\n                    \u2502\n                    \u25bc\n                 AlphaMemory.activate(fact)\n                    \u2502\n                    \u2514\u2500\u2192 JoinNode.right_activate(fact)\n                           \u2502\n                           \u2514\u2500\u2192 Create tokens, propagate...\n                                  \u2502\n                                  \u25bc\n                               ProductionNode\n</code></pre>"},{"location":"architecture/#firing-rules","title":"Firing Rules","text":"<pre><code>User Code\n   \u2502\n   \u251c\u2500\u2192 engine.run()\n   \u2502\n   \u25bc\nFor each ProductionNode:\n   \u2502\n   \u251c\u2500\u2192 For each token:\n   \u2502      \u2502\n   \u2502      \u2514\u2500\u2192 rule.fire(token.facts)\n   \u2502             \u2502\n   \u2502             \u2514\u2500\u2192 Extract bindings\n   \u2502                    \u2502\n   \u2502                    \u2514\u2500\u2192 Execute action lambda\n   \u2502                           \u2502\n   \u2502                           \u2514\u2500\u2192 User code in action\n   \u2502\n   \u2514\u2500\u2192 Mark tokens as fired\n</code></pre>"},{"location":"architecture/#network-compilation","title":"Network Compilation","text":"<p>When you add a rule, KBS compiles it into a discrimination network:</p> <pre><code>rule = Rule.new(\"example\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :sym? }),\n    Condition.new(:alert, { symbol: :sym? }, negated: true)\n  ]\n  r.action = -&gt;(facts, bindings) { puts bindings[:sym?] }\nend\n\nengine.add_rule(rule)\n</code></pre> <p>Compiled Network:</p> <p></p> <p>The rule compiles into a network with alpha memories for each condition type, join nodes to combine matches, a negation node for the NOT condition, and a production node that fires when all conditions are satisfied.</p> <p>Learn more: Network Structure</p>"},{"location":"architecture/#performance-characteristics","title":"Performance Characteristics","text":"Operation Complexity Notes Add rule O(C \u00d7 F) C = conditions, F = existing facts Add fact O(N) N = activated nodes (typically &lt;&lt; total) Remove fact O(T) T = tokens containing fact Fire rules O(M) M = complete matches Network sharing O(1) Same pattern \u2192 same alpha memory"},{"location":"architecture/#design-principles","title":"Design Principles","text":""},{"location":"architecture/#1-algorithm-fidelity","title":"1. Algorithm Fidelity","text":"<p>Maintain RETE correctness per Forgy's specifications. No shortcuts that break semantics.</p>"},{"location":"architecture/#2-separation-of-concerns","title":"2. Separation of Concerns","text":"<ul> <li>Engine: Pattern matching</li> <li>Memory: Storage</li> <li>DSL: User interface</li> <li>Blackboard: Collaboration</li> </ul> <p>Each component is independently testable and swappable.</p>"},{"location":"architecture/#3-performance-through-clarity","title":"3. Performance Through Clarity","text":"<p>Optimize algorithm first (unlinking, network sharing), then profile before micro-optimizations.</p>"},{"location":"architecture/#4-testability","title":"4. Testability","text":"<p>Every method testable in isolation. Dependency injection for external services.</p>"},{"location":"architecture/#5-graceful-degradation","title":"5. Graceful Degradation","text":"<p>Optional features (Redis, AI) don't block core functionality. Fallback to SQLite or in-memory.</p>"},{"location":"architecture/#6-auditability","title":"6. Auditability","text":"<p>Complete audit trails for production systems. Know why a rule fired.</p>"},{"location":"architecture/#extension-points","title":"Extension Points","text":""},{"location":"architecture/#custom-persistence","title":"Custom Persistence","text":"<p>Implement <code>KBS::Blackboard::Persistence::Store</code>:</p> <pre><code>class MyStore\n  def save_fact(fact) ... end\n  def load_facts(type) ... end\n  def delete_fact(id) ... end\n  # ...\nend\n\nengine = KBS::Blackboard::Engine.new(store: MyStore.new)\n</code></pre>"},{"location":"architecture/#custom-pattern-matching","title":"Custom Pattern Matching","text":"<p>Override <code>Fact#matches?</code>:</p> <pre><code>class MyFact &lt; KBS::Fact\n  def matches?(pattern)\n    # Custom matching logic\n  end\nend\n</code></pre>"},{"location":"architecture/#custom-rule-actions","title":"Custom Rule Actions","text":"<p>Actions are lambdas - inject any Ruby code:</p> <pre><code>r.action = lambda do |facts, bindings|\n  send_email(bindings[:alert?])\n  log_to_database(facts)\n  trigger_api_call(bindings)\nend\n</code></pre>"},{"location":"architecture/#file-organization","title":"File Organization","text":"<pre><code>lib/kbs/\n\u251c\u2500\u2500 rete_engine.rb         # Main engine\n\u251c\u2500\u2500 working_memory.rb      # Fact storage\n\u251c\u2500\u2500 fact.rb                # Fact representation\n\u251c\u2500\u2500 rule.rb                # Rule definition\n\u251c\u2500\u2500 condition.rb           # Pattern specification\n\u251c\u2500\u2500 token.rb               # Partial match\n\u251c\u2500\u2500 alpha_memory.rb        # Pattern-level cache\n\u251c\u2500\u2500 beta_memory.rb         # Token storage\n\u251c\u2500\u2500 join_node.rb           # Inter-condition joins\n\u251c\u2500\u2500 negation_node.rb       # Negated conditions\n\u251c\u2500\u2500 production_node.rb     # Rule firing\n\u2514\u2500\u2500 blackboard/            # Persistent memory\n    \u251c\u2500\u2500 engine.rb          # Blackboard-aware RETE\n    \u251c\u2500\u2500 memory.rb          # Central workspace\n    \u251c\u2500\u2500 fact.rb            # Persisted fact\n    \u251c\u2500\u2500 message_queue.rb   # Agent communication\n    \u251c\u2500\u2500 audit_log.rb       # Change history\n    \u2514\u2500\u2500 persistence/       # Storage backends\n        \u251c\u2500\u2500 store.rb       # Abstract interface\n        \u251c\u2500\u2500 sqlite_store.rb\n        \u251c\u2500\u2500 redis_store.rb\n        \u2514\u2500\u2500 hybrid_store.rb\n</code></pre>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<ul> <li>RETE Algorithm - Deep dive into pattern matching</li> <li>Blackboard System - Persistent memory architecture</li> <li>Network Structure - How rules compile into networks</li> <li>API Reference - Complete class documentation</li> </ul>"},{"location":"architecture/blackboard/","title":"Blackboard Architecture","text":"<p>The Blackboard pattern is a powerful approach to multi-agent problem-solving where independent knowledge sources collaborate through a shared workspace.</p>"},{"location":"architecture/blackboard/#overview","title":"Overview","text":"<p>Blackboard system with multiple agents reading and writing to shared persistent memory with pluggable storage backends.</p>"},{"location":"architecture/blackboard/#core-concept","title":"Core Concept","text":"<p>The blackboard architecture consists of three main components:</p> <ol> <li>Blackboard (Memory): Central shared workspace for facts</li> <li>Knowledge Sources (Agents): Independent experts that read and write facts</li> <li>Control Component: Coordinates agent execution (often via rules)</li> </ol> <p>Agents operate asynchronously, triggered by changes to the blackboard state. Each agent: - Reads relevant facts from the blackboard - Performs reasoning or computation - Writes conclusions back to the blackboard - Triggers other agents via fact changes</p>"},{"location":"architecture/blackboard/#kbs-implementation","title":"KBS Implementation","text":""},{"location":"architecture/blackboard/#blackboardmemory","title":"Blackboard::Memory","text":"<p>The central workspace that replaces <code>WorkingMemory</code> with persistence:</p> <pre><code>require 'kbs/blackboard'\n\n# Create blackboard with SQLite backend\nmemory = KBS::Blackboard::Memory.new(db_path: 'knowledge_base.db')\n\n# Add facts (persisted automatically)\nfact = memory.add_fact(:stock, {\n  symbol: \"AAPL\",\n  price: 150.50,\n  timestamp: Time.now\n})\n# =&gt; #&lt;KBS::Blackboard::Fact uuid=\"abc-123\" ...&gt;\n\n# Query facts\nstocks = memory.facts_of_type(:stock)\n# =&gt; [#&lt;KBS::Blackboard::Fact ...&gt;, ...]\n\n# Facts survive process restart\nmemory2 = KBS::Blackboard::Memory.new(db_path: 'knowledge_base.db')\nmemory2.facts_of_type(:stock)\n# =&gt; Still there!\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/memory.rb</code></p>"},{"location":"architecture/blackboard/#blackboardengine","title":"Blackboard::Engine","text":"<p>RETE engine with persistent blackboard memory:</p> <pre><code># Create engine with blackboard\nengine = KBS::Blackboard::Engine.new(db_path: 'trading.db')\n\n# Define rules (persisted in the database)\nengine.add_rule(Rule.new(\"buy_signal\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :sym?, price: :price? }),\n    Condition.new(:threshold, { symbol: :sym?, max: :max? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:price?] &lt; bindings[:max?]\n      # Write new fact to blackboard\n      engine.add_fact(:order, {\n        symbol: bindings[:sym?],\n        action: \"BUY\",\n        price: bindings[:price?]\n      })\n    end\n  end\nend)\n\n# Facts trigger rules, which create new facts\nengine.add_fact(:stock, symbol: \"AAPL\", price: 145.0)\nengine.add_fact(:threshold, symbol: \"AAPL\", max: 150.0)\nengine.run\n# =&gt; Creates :order fact in blackboard\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/engine.rb</code></p>"},{"location":"architecture/blackboard/#message-queue","title":"Message Queue","text":"<p>Priority-based communication between agents:</p> <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'system.db')\nqueue = memory.message_queue\n\n# Agent 1: Post high-priority message\nqueue.post(\"risk_analysis\", {\n  alert: \"High volatility detected\",\n  severity: \"critical\"\n}, priority: 10)\n\n# Agent 2: Read and process messages\nmessages = queue.read(\"risk_analysis\", limit: 5)\nmessages.each do |msg|\n  puts \"Processing: #{msg[:data][:alert]}\"\n  queue.acknowledge(msg[:id])\nend\n\n# Unacknowledged messages remain in queue\npending = queue.pending(\"risk_analysis\")\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/message_queue.rb</code></p>"},{"location":"architecture/blackboard/#audit-log","title":"Audit Log","text":"<p>Complete history of all changes for compliance and debugging:</p> <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'audit.db')\naudit = memory.audit_log\n\n# All fact changes are logged automatically\nfact = memory.add_fact(:stock, symbol: \"AAPL\", price: 150)\nmemory.update_fact(fact.id, price: 155)\nmemory.remove_fact(fact)\n\n# Query audit trail\nhistory = audit.fact_history(fact.id)\n# =&gt; [\n#   { action: \"created\", timestamp: ..., data: {price: 150} },\n#   { action: \"updated\", timestamp: ..., data: {price: 155} },\n#   { action: \"deleted\", timestamp: ... }\n# ]\n\n# See what rules fired\nrule_log = audit.rules_fired(limit: 10)\n# =&gt; [\n#   { rule_name: \"buy_signal\", timestamp: ..., facts: [...] },\n#   ...\n# ]\n\n# Recent changes across all facts\nrecent = audit.recent_changes(limit: 20)\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/audit_log.rb</code></p>"},{"location":"architecture/blackboard/#persistence-backends","title":"Persistence Backends","text":""},{"location":"architecture/blackboard/#sqlite-store-default","title":"SQLite Store (Default)","text":"<p>Best for: Single-process applications, development, small-to-medium data.</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n</code></pre> <p>Pros: - \u2705 Zero configuration (no server needed) - \u2705 ACID transactions - \u2705 Durable across restarts - \u2705 Simple backup (copy .db file) - \u2705 Full-text search capabilities</p> <p>Cons: - \u26a0\ufe0f Slower than Redis (still fast for most use cases) - \u26a0\ufe0f Single-writer limitation - \u26a0\ufe0f Not distributed</p> <p>Schema: <pre><code>CREATE TABLE facts (\n  id TEXT PRIMARY KEY,\n  fact_type TEXT NOT NULL,\n  attributes TEXT NOT NULL, -- JSON\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE audit_log (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  fact_id TEXT,\n  action TEXT NOT NULL,\n  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n  data TEXT -- JSON\n);\n\nCREATE TABLE messages (\n  id TEXT PRIMARY KEY,\n  topic TEXT NOT NULL,\n  priority INTEGER DEFAULT 0,\n  data TEXT NOT NULL, -- JSON\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  acknowledged BOOLEAN DEFAULT 0\n);\n</code></pre></p> <p>Implementation: <code>lib/kbs/blackboard/persistence/sqlite_store.rb</code></p>"},{"location":"architecture/blackboard/#redis-store","title":"Redis Store","text":"<p>Best for: High-throughput applications, distributed systems, real-time trading.</p> <pre><code>store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>Pros: - \u2705 100x faster than SQLite for reads/writes - \u2705 Supports distributed agents (multiple processes, machines) - \u2705 Built-in pub/sub for real-time notifications - \u2705 Atomic operations - \u2705 TTL support for ephemeral facts</p> <p>Cons: - \u26a0\ufe0f Requires Redis server - \u26a0\ufe0f Volatile by default (enable RDB/AOF for durability) - \u26a0\ufe0f More complex deployment</p> <p>Data Structures: <pre><code># Facts stored as Redis hashes\nfact:{uuid} \u2192 { type: \"stock\", symbol: \"AAPL\", price: 150 }\n\n# Indexes for efficient queries\nfacts:type:stock \u2192 Set of fact UUIDs\nfacts:active \u2192 Set of all active fact UUIDs\n\n# Messages as sorted sets (by priority)\nmessages:risk_alerts \u2192 ZSet[(msg1, priority), (msg2, priority), ...]\n\n# Audit as lists\nfact_history:{uuid} \u2192 List of change records\nrules_fired:all \u2192 List of rule executions\n</code></pre></p> <p>Implementation: <code>lib/kbs/blackboard/persistence/redis_store.rb</code></p>"},{"location":"architecture/blackboard/#hybrid-store","title":"Hybrid Store","text":"<p>Best for: Production systems needing speed + durability + audit.</p> <pre><code>store = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>Strategy: - Redis: Facts and messages (fast access) - SQLite: Audit log (durable history)</p> <p>Pros: - \u2705 Fast fact operations (Redis) - \u2705 Durable audit trail (SQLite) - \u2705 Best of both worlds</p> <p>Cons: - \u26a0\ufe0f Requires both Redis and SQLite - \u26a0\ufe0f Slightly more complex</p> <p>Implementation: <code>lib/kbs/blackboard/persistence/hybrid_store.rb</code></p>"},{"location":"architecture/blackboard/#multi-agent-example","title":"Multi-Agent Example","text":"<p>Trading system with four specialized agents:</p> <pre><code># Shared blackboard\nblackboard = KBS::Blackboard::Engine.new(db_path: 'trading.db')\n\n# Agent 1: Market Data Collector\ndata_agent = KBS::Rule.new(\"collect_data\", priority: 5) do |r|\n  r.conditions = [\n    Condition.new(:market_open, { status: true }),\n    Condition.new(:stock_data, { symbol: :sym? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    price = fetch_current_price(bindings[:sym?])\n    blackboard.add_fact(:stock_data, {\n      symbol: bindings[:sym?],\n      price: price,\n      timestamp: Time.now\n    })\n  end\nend\n\n# Agent 2: Signal Generator\nsignal_agent = KBS::Rule.new(\"generate_signals\", priority: 10) do |r|\n  r.conditions = [\n    Condition.new(:stock_data, { symbol: :sym?, price: :price? }),\n    Condition.new(:sma_data, { symbol: :sym?, sma: :sma? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:price?] &gt; bindings[:sma?]\n      blackboard.add_fact(:signal, {\n        symbol: bindings[:sym?],\n        direction: \"BUY\",\n        strength: (bindings[:price?] / bindings[:sma?]) - 1.0\n      })\n    end\n  end\nend\n\n# Agent 3: Risk Manager\nrisk_agent = KBS::Rule.new(\"check_risk\", priority: 20) do |r|\n  r.conditions = [\n    Condition.new(:signal, { symbol: :sym?, direction: :dir? }),\n    Condition.new(:portfolio, { symbol: :sym?, position: :pos? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:pos?] &gt; 1000 &amp;&amp; bindings[:dir?] == \"BUY\"\n      blackboard.add_fact(:risk_alert, {\n        symbol: bindings[:sym?],\n        reason: \"Position limit exceeded\"\n      })\n    else\n      blackboard.add_fact(:approved_signal, {\n        symbol: bindings[:sym?],\n        direction: bindings[:dir?]\n      })\n    end\n  end\nend\n\n# Agent 4: Order Executor\nexec_agent = KBS::Rule.new(\"execute_orders\", priority: 30) do |r|\n  r.conditions = [\n    Condition.new(:approved_signal, { symbol: :sym?, direction: :dir? }),\n    Condition.new(:risk_alert, { symbol: :sym? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    execute_trade(bindings[:sym?], bindings[:dir?])\n    blackboard.add_fact(:execution, {\n      symbol: bindings[:sym?],\n      direction: bindings[:dir?],\n      timestamp: Time.now\n    })\n  end\nend\n\n# Register all agents\n[data_agent, signal_agent, risk_agent, exec_agent].each do |agent|\n  blackboard.add_rule(agent)\nend\n\n# Trigger the system\nblackboard.add_fact(:market_open, status: true)\nblackboard.add_fact(:portfolio, symbol: \"AAPL\", position: 500)\n\n# Agents collaborate through blackboard\nblackboard.run\n</code></pre>"},{"location":"architecture/blackboard/#transactions","title":"Transactions","text":"<p>Ensure atomic multi-fact updates:</p> <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'trades.db')\n\nmemory.transaction do\n  # All or nothing\n  order = memory.add_fact(:order, {\n    symbol: \"AAPL\",\n    action: \"BUY\",\n    quantity: 100\n  })\n\n  execution = memory.add_fact(:execution, {\n    order_id: order.id,\n    price: 150.50,\n    timestamp: Time.now\n  })\n\n  memory.update_fact(order.id, status: \"filled\")\n\n  # If any operation fails, entire transaction rolls back\nend\n</code></pre> <p>Nested transactions are supported via reference counting.</p>"},{"location":"architecture/blackboard/#best-practices","title":"Best Practices","text":""},{"location":"architecture/blackboard/#1-agent-specialization","title":"1. Agent Specialization","text":"<p>Each agent should focus on one aspect of the problem: - \u2705 Data collection - \u2705 Signal generation - \u2705 Risk assessment - \u2705 Execution</p>"},{"location":"architecture/blackboard/#2-priority-based-execution","title":"2. Priority-Based Execution","text":"<p>Use rule priorities to ensure correct agent ordering: <pre><code>data_collector:  priority: 5\nsignal_generator: priority: 10\nrisk_manager:     priority: 20\nexecutor:         priority: 30\n</code></pre></p>"},{"location":"architecture/blackboard/#3-fact-versioning","title":"3. Fact Versioning","text":"<p>Include timestamps for temporal reasoning: <pre><code>engine.add_fact(:price, {\n  symbol: \"AAPL\",\n  value: 150,\n  timestamp: Time.now,\n  source: \"market_data_feed\"\n})\n</code></pre></p>"},{"location":"architecture/blackboard/#4-message-acknowledgment","title":"4. Message Acknowledgment","text":"<p>Always acknowledge processed messages: <pre><code>messages = queue.read(\"alerts\", limit: 10)\nmessages.each do |msg|\n  process_alert(msg[:data])\n  queue.acknowledge(msg[:id])  # Important!\nend\n</code></pre></p>"},{"location":"architecture/blackboard/#5-audit-everything","title":"5. Audit Everything","text":"<p>Use audit log for debugging and compliance: <pre><code># When something goes wrong, trace back\naudit = memory.audit_log\nchanges = audit.recent_changes(limit: 100)\nchanges.each do |change|\n  puts \"#{change[:timestamp]}: #{change[:action]} on #{change[:fact_type]}\"\nend\n</code></pre></p>"},{"location":"architecture/blackboard/#performance-tuning","title":"Performance Tuning","text":""},{"location":"architecture/blackboard/#choose-the-right-backend","title":"Choose the Right Backend","text":"Backend Use Case Performance Durability SQLite Development, single-process Good Excellent Redis High-frequency trading, distributed Excellent Good (with AOF) Hybrid Production systems Excellent Excellent"},{"location":"architecture/blackboard/#batch-operations","title":"Batch Operations","text":"<pre><code># Bad: Individual adds (slow)\n1000.times do |i|\n  memory.add_fact(:reading, sensor: i, value: rand)\nend\n\n# Good: Transaction batch (fast)\nmemory.transaction do\n  1000.times do |i|\n    memory.add_fact(:reading, sensor: i, value: rand)\n  end\nend\n</code></pre>"},{"location":"architecture/blackboard/#index-strategy-sqlite","title":"Index Strategy (SQLite)","text":"<pre><code>-- Add indexes for frequent queries\nCREATE INDEX idx_facts_type ON facts(fact_type);\nCREATE INDEX idx_facts_created ON facts(created_at);\nCREATE INDEX idx_messages_topic ON messages(topic, priority);\n</code></pre>"},{"location":"architecture/blackboard/#redis-memory-management","title":"Redis Memory Management","text":"<pre><code># Set TTL for ephemeral facts\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  ttl: 3600  # Facts expire after 1 hour\n)\n</code></pre>"},{"location":"architecture/blackboard/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"architecture/blackboard/#opportunistic-triggering","title":"Opportunistic Triggering","text":"<p>Agents activate when their preconditions are met:</p> <pre><code># Trigger fires only when specific fact exists\ntrigger_rule = Rule.new(\"on_critical_alert\") do |r|\n  r.conditions = [\n    Condition.new(:alert, { severity: \"critical\" })\n  ]\n\n  r.action = lambda { |facts|\n    notify_team(facts[0])\n  end\nend\n</code></pre>"},{"location":"architecture/blackboard/#blackboard-focus","title":"Blackboard Focus","text":"<p>Limit agent attention to relevant facts:</p> <pre><code># Agent only sees recent stock data\nrecent_data_rule = Rule.new(\"analyze_recent\") do |r|\n  r.conditions = [\n    Condition.new(:stock_data, {\n      symbol: :sym?,\n      timestamp: -&gt;(ts) { Time.now - ts &lt; 300 }  # Last 5 minutes\n    })\n  ]\n\n  r.action = lambda { |facts, bindings|\n    # Process recent data only\n  }\nend\n</code></pre>"},{"location":"architecture/blackboard/#conflict-resolution","title":"Conflict Resolution","text":"<p>When multiple agents could act, use priorities:</p> <pre><code># High priority: Stop-loss overrides everything\nstop_loss = Rule.new(\"stop_loss\", priority: 100)\n\n# Medium priority: Risk management\nrisk_check = Rule.new(\"risk_check\", priority: 50)\n\n# Low priority: Normal trading signals\nbuy_signal = Rule.new(\"buy\", priority: 10)\n</code></pre>"},{"location":"architecture/blackboard/#next-steps","title":"Next Steps","text":"<ul> <li>Network Structure - How blackboard integrates with RETE</li> <li>Persistence Guide - Choosing and configuring backends</li> <li>Multi-Agent Example - Complete working system</li> <li>Custom Persistence - Build your own backend</li> </ul>"},{"location":"architecture/network-structure/","title":"Network Structure","text":"<p>How RETE compiles rules into an efficient discrimination network.</p>"},{"location":"architecture/network-structure/#overview","title":"Overview","text":"<p>When you add a rule to the engine, KBS compiles it into a discrimination network\u2014a directed acyclic graph (DAG) of nodes that efficiently matches patterns against facts. This document explains the compilation process, node types, and optimization strategies.</p>"},{"location":"architecture/network-structure/#network-compilation-process","title":"Network Compilation Process","text":""},{"location":"architecture/network-structure/#step-1-parse-rule-conditions","title":"Step 1: Parse Rule Conditions","text":"<pre><code>rule = Rule.new(\"example\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :sym?, price: :price? }),\n    Condition.new(:threshold, { symbol: :sym?, max: :max? })\n  ]\n  r.action = lambda { |facts, bindings| ... }\nend\n</code></pre> <p>The engine extracts: - Condition types (<code>:stock</code>, <code>:threshold</code>) - Patterns (attribute constraints) - Variable bindings (<code>:sym?</code>, <code>:price?</code>, <code>:max?</code>) - Join tests (<code>:sym?</code> appears in both conditions)</p>"},{"location":"architecture/network-structure/#step-2-create-or-reuse-alpha-memories","title":"Step 2: Create or Reuse Alpha Memories","text":"<p>For each condition, the engine creates or reuses an <code>AlphaMemory</code> node:</p> <pre><code># Pattern for first condition\npattern1 = { type: :stock, symbol: :sym?, price: :price? }\nalpha1 = get_or_create_alpha_memory(pattern1)\n\n# Pattern for second condition\npattern2 = { type: :threshold, symbol: :sym?, max: :max? }\nalpha2 = get_or_create_alpha_memory(pattern2)\n</code></pre> <p>Network Sharing: If another rule has the same pattern, they share the same alpha memory node.</p>"},{"location":"architecture/network-structure/#step-3-build-join-network","title":"Step 3: Build Join Network","text":"<p>Connect conditions through join nodes:</p> <pre><code># Start with root beta memory (contains dummy token)\ncurrent_beta = @root_beta_memory\n\n# For each condition\nrule.conditions.each do |condition|\n  alpha_memory = get_or_create_alpha_memory(condition.pattern)\n\n  # Build join tests for variable consistency\n  tests = extract_join_tests(condition)\n\n  # Create join or negation node\n  if condition.negated\n    node = NegationNode.new(alpha_memory, current_beta, tests)\n  else\n    node = JoinNode.new(alpha_memory, current_beta, tests)\n  end\n\n  # Create beta memory to store results\n  new_beta = BetaMemory.new\n  node.successors &lt;&lt; new_beta\n  current_beta = new_beta\nend\n</code></pre>"},{"location":"architecture/network-structure/#step-4-attach-production-node","title":"Step 4: Attach Production Node","text":"<pre><code>production_node = ProductionNode.new(rule)\ncurrent_beta.successors &lt;&lt; production_node\n@production_nodes[rule.name] = production_node\n</code></pre>"},{"location":"architecture/network-structure/#node-types","title":"Node Types","text":""},{"location":"architecture/network-structure/#alpha-memory-nodes","title":"Alpha Memory Nodes","text":"<p>Purpose: Store facts matching a specific pattern</p> <p>Structure: <pre><code>class AlphaMemory\n  attr_accessor :items      # Facts that match pattern\n  attr_accessor :successors # Join nodes using this alpha\n  attr_accessor :pattern    # Pattern to match\n  attr_reader :linked       # Unlinking state\nend\n</code></pre></p> <p>Example: <pre><code>AlphaMemory(stock, symbol: \"AAPL\")\n  items: [stock(symbol: \"AAPL\", price: 150), ...]\n  successors: [JoinNode1, JoinNode2, ...]\n</code></pre></p>"},{"location":"architecture/network-structure/#beta-memory-nodes","title":"Beta Memory Nodes","text":"<p>Purpose: Store partial matches (tokens) as they propagate</p> <p>Structure: <pre><code>class BetaMemory\n  attr_accessor :tokens     # Partial matches\n  attr_accessor :successors # Next nodes in network\n  attr_reader :linked       # Unlinking state\nend\n</code></pre></p> <p>Example: <pre><code>BetaMemory\n  tokens: [\n    Token(parent: root, fact: stock(...)),\n    Token(parent: root, fact: stock(...))\n  ]\n  successors: [JoinNode2]\n</code></pre></p>"},{"location":"architecture/network-structure/#join-nodes","title":"Join Nodes","text":"<p>Purpose: Combine facts from alpha memory with tokens from beta memory</p> <p>Structure: <pre><code>class JoinNode\n  attr_accessor :alpha_memory  # Right input\n  attr_accessor :beta_memory   # Left input\n  attr_accessor :tests         # Join tests to perform\n  attr_accessor :successors    # Beta memory nodes\nend\n</code></pre></p> <p>Join Tests: <pre><code>{\n  token_field_index: 0,    # Check first fact in token\n  token_field: :symbol,    # Get its :symbol attribute\n  fact_field: :symbol,     # Compare with new fact's :symbol\n  operation: :eq           # Must be equal\n}\n</code></pre></p>"},{"location":"architecture/network-structure/#negation-nodes","title":"Negation Nodes","text":"<p>Purpose: Implement negated conditions (match when pattern is absent)</p> <p>Structure: <pre><code>class NegationNode\n  attr_accessor :alpha_memory       # Pattern to check\n  attr_accessor :beta_memory        # Tokens to test\n  attr_accessor :tests              # Join tests\n  attr_accessor :tokens_with_matches # Track inhibiting facts\nend\n</code></pre></p> <p>Behavior: - Token arrives \u2192 check alpha memory for matches - No matches found \u2192 propagate token (condition satisfied) - Matches found \u2192 block token (condition not satisfied) - Match removed \u2192 unblock token</p>"},{"location":"architecture/network-structure/#production-nodes","title":"Production Nodes","text":"<p>Purpose: Fire rule actions when all conditions match</p> <p>Structure: <pre><code>class ProductionNode\n  attr_accessor :rule   # Rule to fire\n  attr_accessor :tokens # Complete matches ready to fire\nend\n</code></pre></p>"},{"location":"architecture/network-structure/#complete-example","title":"Complete Example","text":""},{"location":"architecture/network-structure/#rule-definition","title":"Rule Definition","text":"<pre><code>rule = Rule.new(\"trading_signal\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :sym?, price: :price? }),\n    Condition.new(:threshold, { symbol: :sym?, buy_below: :threshold? }),\n    Condition.new(:order, { symbol: :sym? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:price?] &lt; bindings[:threshold?]\n      puts \"BUY #{bindings[:sym?]}\"\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/network-structure/#compiled-network","title":"Compiled Network","text":"<p>The trading signal rule compiles into a network with three join points. The first two join nodes combine stock and threshold facts based on matching symbols. The negation node ensures no existing order for that symbol. Tokens propagate through beta memories, carrying partial matches until reaching the production node.</p>"},{"location":"architecture/network-structure/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"architecture/network-structure/#network-sharing","title":"Network Sharing","text":"<p>Multiple rules with common patterns share alpha memory nodes:</p> <pre><code># Rule 1\nCondition.new(:stock, { symbol: \"AAPL\" })\n\n# Rule 2\nCondition.new(:stock, { symbol: \"AAPL\" })\n\n# Both use the same AlphaMemory node\n# Only one pattern match, one fact storage\n</code></pre>"},{"location":"architecture/network-structure/#unlinking","title":"Unlinking","text":"<p>Empty nodes automatically disconnect to avoid wasted computation:</p> <pre><code># BetaMemory becomes empty\nbeta_memory.remove_token(last_token)\n# =&gt; Calls unlink!\n\n# Downstream nodes stop processing\njoin_node.left_activate(token)  # Returns early if !@left_linked\n</code></pre>"},{"location":"architecture/network-structure/#condition-ordering","title":"Condition Ordering","text":"<p>Place selective conditions first to minimize beta memory size:</p> <pre><code># Good: Specific condition first\nconditions = [\n  Condition.new(:critical_alert, { severity: \"critical\" }),  # Few matches\n  Condition.new(:stock, { symbol: :sym? })                   # Many matches\n]\n\n# Bad: General condition first\nconditions = [\n  Condition.new(:stock, { symbol: :sym? }),                  # Many matches\n  Condition.new(:critical_alert, { severity: \"critical\" })   # Few matches\n]\n</code></pre>"},{"location":"architecture/network-structure/#variable-binding-extraction","title":"Variable Binding Extraction","text":"<p>Variables create join tests automatically:</p> <pre><code># Rule with :sym? in two conditions\ntests = [\n  {\n    token_field_index: 0,     # First fact in token (stock)\n    token_field: :symbol,\n    fact_field: :symbol,      # New fact (threshold)\n    operation: :eq\n  }\n]\n</code></pre>"},{"location":"architecture/network-structure/#network-inspection","title":"Network Inspection","text":""},{"location":"architecture/network-structure/#debugging-network-structure","title":"Debugging Network Structure","text":"<pre><code># See all alpha memories\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern: #{pattern}\"\n  puts \"  Facts: #{memory.items.size}\"\n  puts \"  Linked: #{memory.linked}\"\n  puts \"  Successors: #{memory.successors.size}\"\nend\n\n# See production nodes\nengine.production_nodes.each do |name, node|\n  puts \"Rule: #{name}\"\n  puts \"  Tokens: #{node.tokens.size}\"\nend\n</code></pre>"},{"location":"architecture/network-structure/#visualizing-token-flow","title":"Visualizing Token Flow","text":"<p>Enable tracing in actions:</p> <pre><code>r.action = lambda do |facts, bindings|\n  puts \"Rule '#{rule.name}' fired\"\n  puts \"  Facts: #{facts.map(&amp;:to_s).join(', ')}\"\n  puts \"  Bindings: #{bindings.inspect}\"\nend\n</code></pre>"},{"location":"architecture/network-structure/#performance-implications","title":"Performance Implications","text":""},{"location":"architecture/network-structure/#time-complexity","title":"Time Complexity","text":"Operation Complexity Notes Add rule O(C \u00d7 F) C = conditions, F = facts Network sharing lookup O(1) Hash-based pattern cache Join test O(T) T = number of tests Token propagation O(S) S = successors"},{"location":"architecture/network-structure/#space-complexity","title":"Space Complexity","text":"Structure Space Notes Alpha memories O(P) P = unique patterns across all rules Beta memories O(R \u00d7 C) R = rules, C = avg conditions Tokens O(M \u00d7 C) M = complete matches Join nodes O(R \u00d7 C) One per condition"},{"location":"architecture/network-structure/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Maximize network sharing: Design rules to reuse common patterns</li> <li>Order conditions by selectivity: Specific first, general last</li> <li>Minimize negations: Expensive to maintain</li> <li>Use predicates sparingly: Can't be shared across rules</li> <li>Profile your rules: Use debugging to identify bottlenecks</li> </ol>"},{"location":"architecture/network-structure/#next-steps","title":"Next Steps","text":"<ul> <li>RETE Algorithm - Understand the full execution cycle</li> <li>Blackboard System - Persistent network state</li> <li>Performance Tuning - Optimize for production</li> <li>Debugging Guide - Inspect network state</li> </ul> <p>This document describes implementation details in <code>lib/kbs/rete_engine.rb:58</code> (network compilation) and related node classes.</p>"},{"location":"architecture/rete-algorithm/","title":"The RETE Algorithm in KBS","text":""},{"location":"architecture/rete-algorithm/#overview","title":"Overview","text":"<p>The RETE algorithm is a pattern matching algorithm for implementing production rule systems. Developed by Charles Forgy in 1979, RETE (Latin for \"network\") creates a discrimination network that efficiently matches rules against a working memory of facts. KBS implements the RETE algorithm with the critical unlinking optimization for improved performance.</p>"},{"location":"architecture/rete-algorithm/#why-rete","title":"Why RETE?","text":"<p>Traditional rule engines evaluate all rules against all facts on every cycle, resulting in O(R \u00d7 F) complexity where R is the number of rules and F is the number of facts. RETE achieves near-constant time per working memory change by:</p> <ol> <li>Sharing common patterns across rules in a compiled network</li> <li>Maintaining state between cycles (incremental matching)</li> <li>Processing only changes rather than re-evaluating everything</li> <li>Unlinking empty nodes to skip unnecessary computation (RETE optimization)</li> </ol>"},{"location":"architecture/rete-algorithm/#core-concepts","title":"Core Concepts","text":""},{"location":"architecture/rete-algorithm/#facts","title":"Facts","text":"<p>Facts are the fundamental units of knowledge in the system. Each fact has:</p> <ul> <li>Type: A symbol identifying the kind of fact (e.g., <code>:stock</code>, <code>:alert</code>, <code>:order</code>)</li> <li>Attributes: Key-value pairs containing the fact's data</li> <li>ID: A unique identifier (object_id for transient facts, UUID for persisted facts)</li> </ul> <pre><code># Creating a fact\nfact = engine.add_fact(:stock, symbol: \"AAPL\", price: 150.0, volume: 1000000)\n\n# Fact structure\n# =&gt; stock(symbol: AAPL, price: 150.0, volume: 1000000)\n</code></pre> <p>Implementation: <code>lib/kbs/fact.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#working-memory","title":"Working Memory","text":"<p>Working memory is the collection of all facts currently known to the system. It implements the Observer pattern to notify the RETE network when facts are added or removed.</p> <pre><code>class WorkingMemory\n  def add_fact(fact)\n    @facts &lt;&lt; fact\n    notify_observers(:add, fact)  # Triggers RETE propagation\n  end\n\n  def remove_fact(fact)\n    @facts.delete(fact)\n    notify_observers(:remove, fact)  # Triggers retraction\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/working_memory.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#conditions-and-patterns","title":"Conditions and Patterns","text":"<p>A condition specifies a pattern that facts must match. Patterns can include:</p> <ul> <li>Type matching: <code>{ type: :stock }</code></li> <li>Literal values: <code>{ symbol: \"AAPL\" }</code></li> <li>Variable bindings: <code>{ price: :price? }</code> (variables start with <code>?</code>)</li> <li>Predicates: <code>{ price: -&gt;(p) { p &gt; 100 } }</code></li> <li>Negation: <code>negated: true</code> (match when pattern is absent)</li> </ul> <pre><code># Match any stock with symbol \"AAPL\"\nCondition.new(:stock, { symbol: \"AAPL\" })\n\n# Match stock and bind price to ?price variable\nCondition.new(:stock, { symbol: \"AAPL\", price: :price? })\n\n# Match when there is NO alert for \"AAPL\"\nCondition.new(:alert, { symbol: \"AAPL\" }, negated: true)\n</code></pre> <p>Implementation: <code>lib/kbs/condition.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#rules","title":"Rules","text":"<p>Rules are production rules consisting of:</p> <ul> <li>Conditions (IF part): Patterns to match in working memory</li> <li>Action (THEN part): Code to execute when all conditions match</li> <li>Priority: Optional integer for conflict resolution (higher fires first)</li> </ul> <pre><code>rule = Rule.new(\"high_price_alert\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :symbol?, price: :price? }),\n    Condition.new(:threshold, { symbol: :symbol?, max: :max? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:price?] &gt; bindings[:max?]\n      puts \"Alert: #{bindings[:symbol?]} at #{bindings[:price?]}\"\n    end\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/rule.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#tokens","title":"Tokens","text":"<p>Tokens represent partial matches as they flow through the RETE network. A token is a linked list of facts that have matched conditions so far.</p> <pre><code>class Token\n  attr_accessor :parent, :fact, :node, :children\n\n  # Reconstruct the full chain of matched facts\n  def facts\n    facts = []\n    token = self\n    while token\n      facts.unshift(token.fact) if token.fact\n      token = token.parent\n    end\n    facts\n  end\nend\n</code></pre> <p>Key insights: - The root token has <code>parent = nil</code>, <code>fact = nil</code> and represents \"no conditions matched yet\" - Each join creates a new token linking to its parent token plus a new fact - Tokens form a tree structure via the <code>children</code> array, enabling efficient retraction</p> <p>Implementation: <code>lib/kbs/token.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#network-architecture","title":"Network Architecture","text":"<p>The RETE network is a directed acyclic graph (DAG) consisting of three layers:</p> <p></p> <p>The three-layer RETE network architecture showing alpha memories (pattern matching), beta network (join processing), and production nodes (rule firing).</p>"},{"location":"architecture/rete-algorithm/#layer-1-alpha-network","title":"Layer 1: Alpha Network","text":"<p>The alpha network performs intra-condition tests - matching individual facts against patterns. Each <code>AlphaMemory</code> node:</p> <ul> <li>Stores facts matching a specific pattern</li> <li>Is shared across all rules using the same pattern (network sharing)</li> <li>Propagates matches to successor join nodes</li> </ul> <pre><code>class AlphaMemory\n  attr_accessor :items, :successors, :pattern\n\n  def activate(fact)\n    return unless @linked\n    @items &lt;&lt; fact\n    @successors.each { |s| s.right_activate(fact) }\n  end\nend\n</code></pre> <p>Example: If three rules all match <code>stock(symbol: \"AAPL\")</code>, they share one <code>AlphaMemory</code> node for that pattern.</p> <p>Implementation: <code>lib/kbs/alpha_memory.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#layer-2-beta-network","title":"Layer 2: Beta Network","text":"<p>The beta network performs inter-condition tests - joining facts from different conditions. It consists of:</p>"},{"location":"architecture/rete-algorithm/#join-nodes","title":"Join Nodes","text":"<p><code>JoinNode</code> combines tokens from beta memory (left input) with facts from alpha memory (right input):</p> <pre><code>class JoinNode\n  def left_activate(token)\n    return unless @left_linked &amp;&amp; @right_linked\n\n    @alpha_memory.items.each do |fact|\n      if perform_join_tests(token, fact)\n        new_token = Token.new(token, fact, self)\n        @successors.each { |s| s.activate(new_token) }\n      end\n    end\n  end\n\n  def right_activate(fact)\n    return unless @left_linked &amp;&amp; @right_linked\n\n    @beta_memory.tokens.each do |token|\n      if perform_join_tests(token, fact)\n        new_token = Token.new(token, fact, self)\n        @successors.each { |s| s.activate(new_token) }\n      end\n    end\n  end\nend\n</code></pre> <p>Join tests verify: - Variable consistency (e.g., both conditions match same <code>:symbol?</code>) - Cross-condition predicates (e.g., price1 &gt; price2)</p> <p>Implementation: <code>lib/kbs/join_node.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#beta-memory","title":"Beta Memory","text":"<p><code>BetaMemory</code> stores tokens (partial matches) and implements the unlinking optimization:</p> <pre><code>class BetaMemory\n  def add_token(token)\n    @tokens &lt;&lt; token\n    unlink! if @tokens.empty?     # Unlink when empty\n    relink! if @tokens.size == 1  # Relink when first token arrives\n  end\n\n  def remove_token(token)\n    @tokens.delete(token)\n    unlink! if @tokens.empty?     # Unlink when last token removed\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/beta_memory.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#negation-nodes","title":"Negation Nodes","text":"<p><code>NegationNode</code> implements negated conditions (e.g., \"when there is NO matching fact\"):</p> <pre><code>class NegationNode\n  def left_activate(token)\n    matches = @alpha_memory.items.select { |fact| perform_join_tests(token, fact) }\n\n    if matches.empty?\n      # No inhibiting facts found - propagate the token\n      new_token = Token.new(token, nil, self)\n      @successors.each { |s| s.activate(new_token) }\n    else\n      # Found inhibiting facts - block propagation\n      @tokens_with_matches[token] = matches\n    end\n  end\n\n  def right_deactivate(fact)\n    # When an inhibiting fact is removed, check if we can now propagate\n    @beta_memory.tokens.each do |token|\n      if @tokens_with_matches[token].include?(fact)\n        @tokens_with_matches[token].delete(fact)\n\n        if @tokens_with_matches[token].empty?\n          new_token = Token.new(token, nil, self)\n          @successors.each { |s| s.activate(new_token) }\n        end\n      end\n    end\n  end\nend\n</code></pre> <p>Key insight: Negation nodes propagate tokens with <code>fact = nil</code> since there's no actual fact to include.</p> <p>Implementation: <code>lib/kbs/negation_node.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#layer-3-production-nodes","title":"Layer 3: Production Nodes","text":"<p><code>ProductionNode</code> is the terminal node for each rule. When a token reaches a production node, all rule conditions have been satisfied:</p> <pre><code>class ProductionNode\n  def activate(token)\n    @tokens &lt;&lt; token\n    # Don't fire immediately - wait for engine.run()\n  end\n\n  def fire_rule(token)\n    return if token.fired?\n    @rule.fire(token.facts)\n    token.mark_fired!\n  end\nend\n</code></pre> <p>Why delay firing? Negation nodes may need to deactivate tokens after they're created but before they fire. The two-phase approach (collect tokens, then fire) ensures correctness.</p> <p>Implementation: <code>lib/kbs/production_node.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#the-rete-cycle","title":"The RETE Cycle","text":""},{"location":"architecture/rete-algorithm/#1-network-construction","title":"1. Network Construction","text":"<p>When a rule is added via <code>engine.add_rule(rule)</code>, the network is built:</p> <pre><code>def build_network_for_rule(rule)\n  current_beta = @root_beta_memory\n\n  rule.conditions.each_with_index do |condition, index|\n    # Create or reuse alpha memory\n    pattern = condition.pattern.merge(type: condition.type)\n    alpha_memory = get_or_create_alpha_memory(pattern)\n\n    # Build join tests for variable consistency\n    tests = build_join_tests(condition, index)\n\n    # Create join or negation node\n    if condition.negated\n      negation_node = NegationNode.new(alpha_memory, current_beta, tests)\n      new_beta = BetaMemory.new\n      negation_node.successors &lt;&lt; new_beta\n      current_beta = new_beta\n    else\n      join_node = JoinNode.new(alpha_memory, current_beta, tests)\n      new_beta = BetaMemory.new\n      join_node.successors &lt;&lt; new_beta\n      current_beta = new_beta\n    end\n  end\n\n  # Terminal production node\n  production_node = ProductionNode.new(rule)\n  current_beta.successors &lt;&lt; production_node\n  @production_nodes[rule.name] = production_node\nend\n</code></pre> <p>Implementation: <code>lib/kbs/rete_engine.rb:58</code></p>"},{"location":"architecture/rete-algorithm/#2-fact-assertion","title":"2. Fact Assertion","text":"<p>When <code>engine.add_fact(:stock, symbol: \"AAPL\", price: 150)</code> is called:</p> <p></p> <p>Step-by-step flow showing how a fact propagates through the RETE network from working memory to production nodes.</p>"},{"location":"architecture/rete-algorithm/#3-pattern-matching-flow","title":"3. Pattern Matching Flow","text":"<p>Let's trace a fact through the network for this rule:</p> <pre><code># Rule: Alert when AAPL stock exists but no alert exists\nrule = Rule.new(\"no_alert\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: \"AAPL\" }),\n    Condition.new(:alert, { symbol: \"AAPL\" }, negated: true)\n  ]\n  r.action = -&gt;(facts) { puts \"No alert for AAPL!\" }\nend\n</code></pre> <p></p> <p>Complete trace showing how negation works: adding a stock fact fires the rule, adding an alert inhibits it, and removing the alert reactivates the rule.</p>"},{"location":"architecture/rete-algorithm/#4-rule-execution","title":"4. Rule Execution","text":"<p>The final phase is <code>engine.run()</code>:</p> <pre><code>def run\n  @production_nodes.values.each do |node|\n    node.tokens.each do |token|\n      node.fire_rule(token)\n    end\n  end\nend\n</code></pre> <p>Each production node fires its accumulated tokens. The <code>fired?</code> flag prevents duplicate firing.</p> <p>Implementation: <code>lib/kbs/rete_engine.rb:48</code></p>"},{"location":"architecture/rete-algorithm/#rete-optimization-unlinking","title":"RETE Optimization: Unlinking","text":""},{"location":"architecture/rete-algorithm/#the-problem","title":"The Problem","text":"<p>In basic RETE, join nodes always process activations even when one input is empty:</p> <pre><code>BetaMemory (0 tokens) \u2500\u2500\u2510\n                        \u251c\u2500\u2500\u2192 JoinNode \u2500\u2500\u2192 (does useless work!)\nAlphaMemory (100 facts) \u2518\n</code></pre> <p>If beta memory is empty, the join will produce zero results, wasting CPU cycles.</p>"},{"location":"architecture/rete-algorithm/#the-solution","title":"The Solution","text":"<p>RETE introduces dynamic unlinking: nodes automatically disconnect from the network when empty and reconnect when non-empty.</p> <pre><code>class BetaMemory\n  def add_token(token)\n    @tokens &lt;&lt; token\n    relink! if @tokens.size == 1  # Reconnect when first token arrives\n  end\n\n  def remove_token(token)\n    @tokens.delete(token)\n    unlink! if @tokens.empty?     # Disconnect when empty\n  end\n\n  def relink!\n    @linked = true\n    @successors.each { |s| s.left_relink! }\n  end\n\n  def unlink!\n    @linked = false\n    @successors.each { |s| s.left_unlink! }\n  end\nend\n</code></pre> <p>Join node respects linking state:</p> <pre><code>class JoinNode\n  def left_activate(token)\n    return unless @left_linked &amp;&amp; @right_linked  # Skip if unlinked!\n    # ... perform join ...\n  end\n\n  def right_activate(fact)\n    return unless @left_linked &amp;&amp; @right_linked  # Skip if unlinked!\n    # ... perform join ...\n  end\nend\n</code></pre>"},{"location":"architecture/rete-algorithm/#performance-impact","title":"Performance Impact","text":"<p>For rules with many conditions, unlinking can reduce RETE network activations by 90%+:</p> <ul> <li>Empty alpha memories don't trigger join operations</li> <li>Empty beta memories don't process fact assertions</li> <li>Network \"lights up\" only the relevant paths</li> </ul> <p>This is especially critical for: - Negated conditions (often have empty alpha memories) - Rare patterns (e.g., \"critical alert\" facts) - Complex rules (many conditions = more opportunities for empty nodes)</p>"},{"location":"architecture/rete-algorithm/#variable-binding","title":"Variable Binding","text":"<p>Variables (symbols starting with <code>?</code>) enable cross-condition constraints and action parameterization:</p>"},{"location":"architecture/rete-algorithm/#extraction-during-network-build","title":"Extraction During Network Build","text":"<pre><code>class Condition\n  def extract_variables(pattern)\n    vars = {}\n    pattern.each do |key, value|\n      if value.is_a?(Symbol) &amp;&amp; value.to_s.start_with?('?')\n        vars[value] = key  # { :symbol? =&gt; :symbol, :price? =&gt; :price }\n      end\n    end\n    vars\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/condition.rb:16</code></p>"},{"location":"architecture/rete-algorithm/#join-test-generation","title":"Join Test Generation","text":"<p>Variables create join tests to ensure consistency:</p> <pre><code># Rule with shared ?symbol variable\nconditions = [\n  Condition.new(:stock, { symbol: :symbol?, price: :price? }),\n  Condition.new(:order, { symbol: :symbol?, quantity: 100 })\n]\n\n# Generates join test:\n{\n  token_field_index: 0,      # Check first fact in token (stock)\n  token_field: :symbol,       # Get its :symbol attribute\n  fact_field: :symbol,        # Compare with order's :symbol attribute\n  operation: :eq              # Must be equal\n}\n</code></pre> <p>Implementation: <code>lib/kbs/join_node.rb:89</code></p>"},{"location":"architecture/rete-algorithm/#action-binding","title":"Action Binding","text":"<p>When a rule fires, bindings are extracted for the action:</p> <pre><code>def fire(facts)\n  bindings = extract_bindings(facts)\n  # bindings = { :symbol? =&gt; \"AAPL\", :price? =&gt; 150.0 }\n\n  @action.call(facts, bindings)\nend\n\ndef extract_bindings(facts)\n  bindings = {}\n  @conditions.each_with_index do |condition, index|\n    next if condition.negated  # Negated conditions have no fact\n    fact = facts[index]\n    condition.variable_bindings.each do |var, field|\n      bindings[var] = fact.attributes[field]\n    end\n  end\n  bindings\nend\n</code></pre> <p>Implementation: <code>lib/kbs/rule.rb:34</code></p>"},{"location":"architecture/rete-algorithm/#advanced-topics","title":"Advanced Topics","text":""},{"location":"architecture/rete-algorithm/#conflict-resolution","title":"Conflict Resolution","text":"<p>When multiple rules are activated simultaneously, KBS uses priority (higher values fire first):</p> <pre><code>rule1 = Rule.new(\"urgent\", priority: 10) { ... }\nrule2 = Rule.new(\"normal\", priority: 0) { ... }\n\n# rule1 fires before rule2\n</code></pre> <p>For same-priority rules, firing order is deterministic but unspecified (depends on hash ordering).</p>"},{"location":"architecture/rete-algorithm/#fact-retraction","title":"Fact Retraction","text":"<p>Removing facts triggers recursive token deletion:</p> <pre><code>class JoinNode\n  def right_deactivate(fact)\n    tokens_to_remove = []\n\n    @beta_memory.tokens.each do |token|\n      # Find child tokens containing this fact\n      token.children.select { |child| child.fact == fact }.each do |child|\n        tokens_to_remove &lt;&lt; child\n        @successors.each { |s| s.deactivate(child) }  # Recursive!\n      end\n    end\n\n    tokens_to_remove.each { |token| token.parent.children.delete(token) }\n  end\nend\n</code></pre> <p>This ensures truth maintenance: when a premise is removed, all derived conclusions are also removed.</p> <p>Implementation: <code>lib/kbs/join_node.rb:72</code></p>"},{"location":"architecture/rete-algorithm/#network-sharing","title":"Network Sharing","text":"<p>Alpha memories are shared across rules using pattern as the hash key:</p> <pre><code>def get_or_create_alpha_memory(pattern)\n  @alpha_memories[pattern] ||= AlphaMemory.new(pattern)\nend\n</code></pre> <p>If 10 rules all match <code>stock(symbol: \"AAPL\")</code>, they share one <code>AlphaMemory</code> node, reducing: - Memory usage (one fact store instead of 10) - Computation (one pattern match instead of 10)</p> <p>Implementation: <code>lib/kbs/rete_engine.rb:104</code></p>"},{"location":"architecture/rete-algorithm/#incremental-matching","title":"Incremental Matching","text":"<p>RETE is incremental: after the initial network build, only changes are processed. Adding a fact activates a small subgraph, not the entire network.</p> <p>Complexity: - Initial build: O(R \u00d7 F) where R = rules, F = facts - Per-fact addition: O(N) where N = activated nodes (typically &lt;&lt; R \u00d7 F) - Per-fact removal: O(T) where T = tokens to remove</p> <p>In practice, RETE can handle millions of facts with sub-millisecond updates.</p>"},{"location":"architecture/rete-algorithm/#debugging-rete-networks","title":"Debugging RETE Networks","text":""},{"location":"architecture/rete-algorithm/#visualizing-token-flow","title":"Visualizing Token Flow","text":"<p>Enable token tracing:</p> <pre><code>class Token\n  def to_s\n    \"Token(#{facts.map(&amp;:to_s).join(', ')})\"\n  end\nend\n\n# In your rule action:\nr.action = lambda do |facts, bindings|\n  puts \"Fired with facts: #{facts.map(&amp;:to_s).join(', ')}\"\n  puts \"Bindings: #{bindings.inspect}\"\nend\n</code></pre>"},{"location":"architecture/rete-algorithm/#inspecting-network-state","title":"Inspecting Network State","text":"<p>Check what's in memories:</p> <pre><code># Alpha memory contents\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern #{pattern}: #{memory.items.size} facts\"\n  memory.items.each { |f| puts \"  - #{f}\" }\nend\n\n# Beta memory contents (requires introspection)\ndef walk_beta_network(beta)\n  puts \"Beta memory: #{beta.tokens.size} tokens\"\n  beta.tokens.each { |t| puts \"  - #{t}\" }\n  beta.successors.each do |node|\n    if node.is_a?(BetaMemory)\n      walk_beta_network(node)\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/rete-algorithm/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Forgetting to call <code>engine.run()</code>: Tokens accumulate but rules don't fire</li> <li>Pattern mismatches: <code>{ type: :stock }</code> vs <code>Condition.new(:stock, {})</code> - the latter doesn't filter by type!</li> <li>Variable binding errors: Using <code>?symbol</code> (string) instead of <code>:symbol?</code> (symbol)</li> <li>Negation timing: Negated conditions only fire when facts are absent, not after they're removed (use <code>engine.run()</code> to re-evaluate)</li> </ol>"},{"location":"architecture/rete-algorithm/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/rete-algorithm/#time-complexity","title":"Time Complexity","text":"Operation Complexity Notes Add rule O(C \u00d7 F) C = conditions, F = existing facts Add fact O(N) N = activated nodes (avg &lt;&lt; total nodes) Remove fact O(T) T = tokens containing fact Run rules O(M) M = matched tokens in production nodes"},{"location":"architecture/rete-algorithm/#space-complexity","title":"Space Complexity","text":"Structure Space Notes Alpha memories O(F \u00d7 P) F = facts, P = unique patterns Beta memories O(T) T = partial match tokens Tokens O(C \u00d7 M) C = conditions, M = complete matches Network nodes O(R \u00d7 C) R = rules, C = avg conditions per rule"},{"location":"architecture/rete-algorithm/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Pattern specificity: Put most selective conditions first to reduce beta memory size</li> <li>Negation placement: Place negated conditions last (they don't add facts to tokens)</li> <li>Shared patterns: Design rules to share common patterns</li> <li>Fact pruning: Remove obsolete facts to trigger unlinking</li> <li>Priority tuning: Use priority to fire expensive rules last</li> </ol>"},{"location":"architecture/rete-algorithm/#comparison-with-other-algorithms","title":"Comparison with Other Algorithms","text":""},{"location":"architecture/rete-algorithm/#naive-match-all","title":"Naive Match-All","text":"<pre><code># O(R \u00d7 F) on every cycle\ndef naive_fire_rules\n  rules.each do |rule|\n    facts.each do |fact|\n      if rule.matches?(fact)\n        rule.fire(fact)\n      end\n    end\n  end\nend\n</code></pre> <p>Problem: Re-evaluates everything, no state preservation.</p>"},{"location":"architecture/rete-algorithm/#treat","title":"TREAT","text":"<p>TREAT eliminates alpha/beta network in favor of lazy evaluation: - Pros: Simpler implementation, lower memory - Cons: Slower for rules that fire frequently (no memoization)</p> <p>RETE is better when rules fire often; TREAT is better for sparse firing.</p>"},{"location":"architecture/rete-algorithm/#basic-rete-vs-rete-with-unlinking","title":"Basic RETE vs RETE with Unlinking","text":"<p>Early RETE implementations lacked unlinking: - Without unlinking: All nodes always active, many wasted join operations - With unlinking: Nodes disconnect when empty, up to 10\u00d7 faster</p> <p>KBS implements RETE with unlinking optimization.</p>"},{"location":"architecture/rete-algorithm/#implementation-files","title":"Implementation Files","text":"Component File Lines Core engine <code>lib/kbs/rete_engine.rb</code> ~110 Working memory <code>lib/kbs/working_memory.rb</code> ~35 Facts <code>lib/kbs/fact.rb</code> ~45 Tokens <code>lib/kbs/token.rb</code> ~40 Alpha memory <code>lib/kbs/alpha_memory.rb</code> ~40 Beta memory <code>lib/kbs/beta_memory.rb</code> ~60 Join nodes <code>lib/kbs/join_node.rb</code> ~120 Negation nodes <code>lib/kbs/negation_node.rb</code> ~90 Production nodes <code>lib/kbs/production_node.rb</code> ~30 Conditions <code>lib/kbs/condition.rb</code> ~30 Rules <code>lib/kbs/rule.rb</code> ~50 <p>Total: ~650 lines of core RETE implementation.</p>"},{"location":"architecture/rete-algorithm/#further-reading","title":"Further Reading","text":""},{"location":"architecture/rete-algorithm/#academic-papers","title":"Academic Papers","text":"<ul> <li>Forgy, C. (1982). \"Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem\". Artificial Intelligence, 19(1), 17-37.</li> <li>Forgy, C. (1989). \"Rete: A Fast Match Algorithm\". AI Expert, 4(1), 34-40.</li> </ul>"},{"location":"architecture/rete-algorithm/#textbooks","title":"Textbooks","text":"<ul> <li>Giarratano, J., &amp; Riley, G. (2004). Expert Systems: Principles and Programming (4<sup>th</sup> ed.). Course Technology.</li> <li>Russell, S., &amp; Norvig, P. (2020). Artificial Intelligence: A Modern Approach (4<sup>th</sup> ed.). Pearson. (Chapter on Rule-Based Systems)</li> </ul>"},{"location":"architecture/rete-algorithm/#online-resources","title":"Online Resources","text":"<ul> <li>RETE Algorithm Visualization - Jess documentation</li> <li>Production Systems - Wikipedia</li> <li>Rule-Based Expert Systems - University of Toronto</li> </ul>"},{"location":"architecture/rete-algorithm/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Guide: Learn how to write rules using KBS's Ruby DSL</li> <li>Blackboard Architecture: Understand persistent memory and multi-agent systems</li> <li>Examples: See RETE in action with stock trading and expert systems</li> <li>Performance Tuning: Optimize your rule-based system</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Real-world applications of KBS.</p> <ul> <li>Stock Trading - Algorithmic trading system</li> <li>Expert Systems - Diagnostic and decision support</li> <li>Multi-Agent Systems - Collaborative problem-solving</li> </ul> <p>See also: Quick Start Guide</p>"},{"location":"examples/expert-systems/","title":"Expert Systems","text":"<p>Build diagnostic expert systems using KBS with knowledge representation, inference engines, explanation facilities, and confidence factors.</p>"},{"location":"examples/expert-systems/#system-overview","title":"System Overview","text":"<p>This example demonstrates a medical diagnostic system with:</p> <ul> <li>Knowledge Base - Medical symptoms and disease rules</li> <li>Inference Engine - Forward and backward chaining</li> <li>Explanation Facility - Justification for diagnoses</li> <li>Confidence Factors - Probabilistic reasoning</li> <li>User Interface - Interactive consultation</li> </ul>"},{"location":"examples/expert-systems/#architecture","title":"Architecture","text":"<pre><code>Patient Symptoms \u2192 Symptom Analysis \u2192 Disease Hypotheses \u2192 Diagnosis\n                       \u2193                      \u2193                \u2193\n                  Working Memory      Confidence Scores    Explanation\n</code></pre>"},{"location":"examples/expert-systems/#complete-implementation","title":"Complete Implementation","text":""},{"location":"examples/expert-systems/#medical-diagnosis-system","title":"Medical Diagnosis System","text":"<pre><code>require 'kbs'\n\nclass MedicalExpertSystem\n  def initialize(db_path: 'medical.db')\n    @engine = KBS::Blackboard::Engine.new(db_path: db_path)\n    @explanations = []\n    setup_knowledge_base\n  end\n\n  def setup_knowledge_base\n    # Rule 1: Detect fever pattern\n    fever_rule = KBS::Rule.new(\"detect_fever\", priority: 100) do |r|\n      r.conditions = [\n        KBS::Condition.new(:symptom, {\n          type: \"temperature\",\n          value: :temp?\n        }, predicate: lambda { |f| f[:value] &gt; 38.0 }),\n\n        KBS::Condition.new(:fever_detected, {}, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        confidence = calculate_fever_confidence(bindings[:temp?])\n\n        @engine.add_fact(:fever_detected, {\n          severity: fever_severity(bindings[:temp?]),\n          confidence: confidence,\n          temperature: bindings[:temp?]\n        })\n\n        @explanations &lt;&lt; {\n          rule: \"detect_fever\",\n          reasoning: \"Temperature #{bindings[:temp?]}\u00b0C exceeds normal (37\u00b0C)\",\n          confidence: confidence\n        }\n      end\n    end\n\n    # Rule 2: Flu hypothesis\n    flu_rule = KBS::Rule.new(\"hypothesize_flu\", priority: 90) do |r|\n      r.conditions = [\n        KBS::Condition.new(:fever_detected, { severity: :severity? }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"body_aches\",\n          present: true\n        }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"fatigue\",\n          present: true\n        }),\n\n        KBS::Condition.new(:diagnosis, { disease: \"flu\" }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        # Calculate confidence based on symptom presence\n        base_confidence = 0.6\n\n        # Adjust for fever severity\n        fever_bonus = bindings[:severity?] == \"high\" ? 0.2 : 0.1\n\n        # Check for additional symptoms\n        cough = @engine.facts.any? { |f|\n          f.type == :symptom &amp;&amp; f[:type] == \"cough\" &amp;&amp; f[:present]\n        }\n        cough_bonus = cough ? 0.1 : 0.0\n\n        confidence = [base_confidence + fever_bonus + cough_bonus, 1.0].min\n\n        @engine.add_fact(:diagnosis, {\n          disease: \"flu\",\n          confidence: confidence,\n          symptoms: [\"fever\", \"body_aches\", \"fatigue\"]\n        })\n\n        @explanations &lt;&lt; {\n          rule: \"hypothesize_flu\",\n          reasoning: \"Classic flu triad: fever + body aches + fatigue\",\n          confidence: confidence\n        }\n      end\n    end\n\n    # Rule 3: Strep throat hypothesis\n    strep_rule = KBS::Rule.new(\"hypothesize_strep_throat\", priority: 90) do |r|\n      r.conditions = [\n        KBS::Condition.new(:symptom, {\n          type: \"sore_throat\",\n          severity: :throat_severity?\n        }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"swollen_lymph_nodes\",\n          present: true\n        }),\n\n        KBS::Condition.new(:fever_detected, {}),\n\n        # No cough (distinguishes from viral)\n        KBS::Condition.new(:symptom, {\n          type: \"cough\",\n          present: true\n        }, negated: true),\n\n        KBS::Condition.new(:diagnosis, { disease: \"strep_throat\" }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        base_confidence = 0.7\n\n        # Severe sore throat increases confidence\n        severity_bonus = bindings[:throat_severity?] == \"severe\" ? 0.2 : 0.1\n\n        confidence = [base_confidence + severity_bonus, 0.95].min\n\n        @engine.add_fact(:diagnosis, {\n          disease: \"strep_throat\",\n          confidence: confidence,\n          symptoms: [\"sore_throat\", \"swollen_lymph_nodes\", \"fever\", \"no_cough\"]\n        })\n\n        @explanations &lt;&lt; {\n          rule: \"hypothesize_strep_throat\",\n          reasoning: \"Sore throat + swollen nodes + fever WITHOUT cough suggests bacterial infection\",\n          confidence: confidence\n        }\n      end\n    end\n\n    # Rule 4: Common cold hypothesis\n    cold_rule = KBS::Rule.new(\"hypothesize_cold\", priority: 85) do |r|\n      r.conditions = [\n        KBS::Condition.new(:symptom, {\n          type: \"runny_nose\",\n          present: true\n        }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"sneezing\",\n          present: true\n        }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"congestion\",\n          present: true\n        }),\n\n        # Mild or no fever\n        KBS::Condition.new(:fever_detected, {\n          severity: \"high\"\n        }, negated: true),\n\n        KBS::Condition.new(:diagnosis, { disease: \"common_cold\" }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        confidence = 0.75\n\n        # Adjust if low fever present\n        low_fever = @engine.facts.any? { |f|\n          f.type == :fever_detected &amp;&amp; f[:severity] == \"low\"\n        }\n        confidence += 0.1 if low_fever\n\n        @engine.add_fact(:diagnosis, {\n          disease: \"common_cold\",\n          confidence: confidence,\n          symptoms: [\"runny_nose\", \"sneezing\", \"congestion\"]\n        })\n\n        @explanations &lt;&lt; {\n          rule: \"hypothesize_cold\",\n          reasoning: \"Upper respiratory symptoms without high fever typical of viral cold\",\n          confidence: confidence\n        }\n      end\n    end\n\n    # Rule 5: Allergy hypothesis\n    allergy_rule = KBS::Rule.new(\"hypothesize_allergy\", priority: 85) do |r|\n      r.conditions = [\n        KBS::Condition.new(:symptom, {\n          type: \"sneezing\",\n          frequency: :freq?\n        }, predicate: lambda { |f| f[:frequency] == \"frequent\" }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"itchy_eyes\",\n          present: true\n        }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"runny_nose\",\n          present: true\n        }),\n\n        # No fever (key differentiator from infection)\n        KBS::Condition.new(:fever_detected, {}, negated: true),\n\n        KBS::Condition.new(:diagnosis, { disease: \"allergies\" }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        confidence = 0.8\n\n        @engine.add_fact(:diagnosis, {\n          disease: \"allergies\",\n          confidence: confidence,\n          symptoms: [\"frequent_sneezing\", \"itchy_eyes\", \"runny_nose\", \"no_fever\"]\n        })\n\n        @explanations &lt;&lt; {\n          rule: \"hypothesize_allergy\",\n          reasoning: \"Frequent sneezing + itchy eyes + runny nose WITHOUT fever suggests allergic reaction\",\n          confidence: confidence\n        }\n      end\n    end\n\n    # Rule 6: Migraine hypothesis\n    migraine_rule = KBS::Rule.new(\"hypothesize_migraine\", priority: 88) do |r|\n      r.conditions = [\n        KBS::Condition.new(:symptom, {\n          type: \"headache\",\n          location: \"unilateral\",\n          severity: :severity?\n        }, predicate: lambda { |f| f[:severity] == \"severe\" }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"nausea\",\n          present: true\n        }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"light_sensitivity\",\n          present: true\n        }),\n\n        KBS::Condition.new(:diagnosis, { disease: \"migraine\" }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        base_confidence = 0.85\n\n        # Check for aura\n        aura = @engine.facts.any? { |f|\n          f.type == :symptom &amp;&amp; f[:type] == \"visual_disturbance\"\n        }\n        aura_bonus = aura ? 0.1 : 0.0\n\n        confidence = [base_confidence + aura_bonus, 0.95].min\n\n        @engine.add_fact(:diagnosis, {\n          disease: \"migraine\",\n          confidence: confidence,\n          symptoms: [\"severe_unilateral_headache\", \"nausea\", \"photophobia\"]\n        })\n\n        @explanations &lt;&lt; {\n          rule: \"hypothesize_migraine\",\n          reasoning: \"Severe one-sided headache with nausea and light sensitivity characteristic of migraine\",\n          confidence: confidence\n        }\n      end\n    end\n\n    # Rule 7: Recommend diagnostic test\n    test_rule = KBS::Rule.new(\"recommend_diagnostic_test\", priority: 70) do |r|\n      r.conditions = [\n        KBS::Condition.new(:diagnosis, {\n          disease: :disease?,\n          confidence: :conf?\n        }, predicate: lambda { |f| f[:confidence] &gt; 0.7 &amp;&amp; f[:confidence] &lt; 0.9 }),\n\n        KBS::Condition.new(:test_recommended, {\n          disease: :disease?\n        }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        test = diagnostic_test_for(bindings[:disease?])\n\n        @engine.add_fact(:test_recommended, {\n          disease: bindings[:disease?],\n          test: test,\n          reason: \"Confidence #{bindings[:conf?]} warrants confirmation\"\n        })\n\n        @explanations &lt;&lt; {\n          rule: \"recommend_diagnostic_test\",\n          reasoning: \"Moderate confidence (#{bindings[:conf?]}) suggests #{test} for confirmation\",\n          confidence: 1.0\n        }\n      end\n    end\n\n    # Rule 8: Final diagnosis\n    final_diagnosis_rule = KBS::Rule.new(\"select_final_diagnosis\", priority: 60) do |r|\n      r.conditions = [\n        KBS::Condition.new(:diagnosis, {\n          disease: :disease?,\n          confidence: :conf?\n        }),\n\n        KBS::Condition.new(:final_diagnosis, {}, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        # Find highest confidence diagnosis\n        all_diagnoses = facts.select { |f| f.type == :diagnosis }\n        best = all_diagnoses.max_by { |d| d[:confidence] }\n\n        @engine.add_fact(:final_diagnosis, {\n          disease: best[:disease],\n          confidence: best[:confidence],\n          symptoms: best[:symptoms],\n          timestamp: Time.now\n        })\n\n        @explanations &lt;&lt; {\n          rule: \"select_final_diagnosis\",\n          reasoning: \"Selected #{best[:disease]} (#{best[:confidence]} confidence) as most likely diagnosis\",\n          confidence: 1.0\n        }\n      end\n    end\n\n    @engine.add_rule(fever_rule)\n    @engine.add_rule(flu_rule)\n    @engine.add_rule(strep_rule)\n    @engine.add_rule(cold_rule)\n    @engine.add_rule(allergy_rule)\n    @engine.add_rule(migraine_rule)\n    @engine.add_rule(test_rule)\n    @engine.add_rule(final_diagnosis_rule)\n  end\n\n  def add_symptom(type, attributes = {})\n    @engine.add_fact(:symptom, { type: type, **attributes })\n  end\n\n  def diagnose\n    @explanations.clear\n    @engine.run\n\n    final = @engine.facts.find { |f| f.type == :final_diagnosis }\n\n    {\n      diagnosis: final,\n      all_hypotheses: @engine.facts.select { |f| f.type == :diagnosis },\n      explanations: @explanations,\n      recommended_tests: @engine.facts.select { |f| f.type == :test_recommended }\n    }\n  end\n\n  def explain_reasoning\n    @explanations.each_with_index do |exp, i|\n      puts \"\\n#{i + 1}. Rule: #{exp[:rule]} (Confidence: #{exp[:confidence]})\"\n      puts \"   Reasoning: #{exp[:reasoning]}\"\n    end\n  end\n\n  private\n\n  def calculate_fever_confidence(temp)\n    case temp\n    when 38.0..38.5\n      0.6\n    when 38.5..39.0\n      0.75\n    when 39.0..40.0\n      0.9\n    else\n      0.95\n    end\n  end\n\n  def fever_severity(temp)\n    case temp\n    when 38.0..38.5\n      \"low\"\n    when 38.5..39.5\n      \"moderate\"\n    else\n      \"high\"\n    end\n  end\n\n  def diagnostic_test_for(disease)\n    {\n      \"flu\" =&gt; \"Rapid influenza test\",\n      \"strep_throat\" =&gt; \"Rapid strep test (throat swab)\",\n      \"migraine\" =&gt; \"MRI (if first occurrence or atypical presentation)\",\n      \"common_cold\" =&gt; \"None (clinical diagnosis)\",\n      \"allergies\" =&gt; \"Allergy skin test or IgE blood test\"\n    }[disease] || \"Consult physician\"\n  end\nend\n\n# Usage Example 1: Flu Diagnosis\nputs \"=== Example 1: Flu Diagnosis ===\"\nsystem = MedicalExpertSystem.new(db_path: ':memory:')\n\nsystem.add_symptom(\"temperature\", value: 39.2)\nsystem.add_symptom(\"body_aches\", present: true)\nsystem.add_symptom(\"fatigue\", present: true)\nsystem.add_symptom(\"cough\", present: true)\n\nresult = system.diagnose\n\nputs \"\\nFinal Diagnosis:\"\nif result[:diagnosis]\n  puts \"  Disease: #{result[:diagnosis][:disease]}\"\n  puts \"  Confidence: #{(result[:diagnosis][:confidence] * 100).round(1)}%\"\n  puts \"  Symptoms: #{result[:diagnosis][:symptoms].join(', ')}\"\nend\n\nputs \"\\nAll Hypotheses:\"\nresult[:all_hypotheses].each do |h|\n  puts \"  - #{h[:disease]}: #{(h[:confidence] * 100).round(1)}%\"\nend\n\nputs \"\\nReasoning Chain:\"\nsystem.explain_reasoning\n\n# Usage Example 2: Strep Throat\nputs \"\\n\\n=== Example 2: Strep Throat Diagnosis ===\"\nsystem2 = MedicalExpertSystem.new(db_path: ':memory:')\n\nsystem2.add_symptom(\"temperature\", value: 38.8)\nsystem2.add_symptom(\"sore_throat\", severity: \"severe\", present: true)\nsystem2.add_symptom(\"swollen_lymph_nodes\", present: true)\n# Note: No cough symptom added\n\nresult2 = system2.diagnose\n\nputs \"\\nFinal Diagnosis:\"\nif result2[:diagnosis]\n  puts \"  Disease: #{result2[:diagnosis][:disease]}\"\n  puts \"  Confidence: #{(result2[:diagnosis][:confidence] * 100).round(1)}%\"\nend\n\nif result2[:recommended_tests].any?\n  puts \"\\nRecommended Tests:\"\n  result2[:recommended_tests].each do |test|\n    puts \"  - #{test[:test]} for #{test[:disease]}\"\n    puts \"    Reason: #{test[:reason]}\"\n  end\nend\n\nputs \"\\nReasoning Chain:\"\nsystem2.explain_reasoning\n\n# Usage Example 3: Allergies\nputs \"\\n\\n=== Example 3: Allergy Diagnosis ===\"\nsystem3 = MedicalExpertSystem.new(db_path: ':memory:')\n\nsystem3.add_symptom(\"sneezing\", frequency: \"frequent\", present: true)\nsystem3.add_symptom(\"itchy_eyes\", present: true)\nsystem3.add_symptom(\"runny_nose\", present: true)\nsystem3.add_symptom(\"congestion\", present: true)\n# Note: No fever\n\nresult3 = system3.diagnose\n\nputs \"\\nFinal Diagnosis:\"\nif result3[:diagnosis]\n  puts \"  Disease: #{result3[:diagnosis][:disease]}\"\n  puts \"  Confidence: #{(result3[:diagnosis][:confidence] * 100).round(1)}%\"\nend\n\nputs \"\\nReasoning Chain:\"\nsystem3.explain_reasoning\n</code></pre>"},{"location":"examples/expert-systems/#key-features","title":"Key Features","text":""},{"location":"examples/expert-systems/#1-knowledge-representation","title":"1. Knowledge Representation","text":"<p>Rules encode medical knowledge in a structured format:</p> <pre><code># Rule encodes: \"IF fever AND body_aches AND fatigue THEN possibly flu\"\nKBS::Rule.new(\"hypothesize_flu\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:fever_detected, { severity: :severity? }),\n    KBS::Condition.new(:symptom, { type: \"body_aches\", present: true }),\n    KBS::Condition.new(:symptom, { type: \"fatigue\", present: true })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Calculate confidence and add diagnosis\n  end\nend\n</code></pre>"},{"location":"examples/expert-systems/#2-confidence-factors","title":"2. Confidence Factors","text":"<p>Probabilistic reasoning using confidence scores:</p> <pre><code>base_confidence = 0.6\nfever_bonus = bindings[:severity?] == \"high\" ? 0.2 : 0.1\ncough_bonus = cough_present? ? 0.1 : 0.0\n\nconfidence = [base_confidence + fever_bonus + cough_bonus, 1.0].min\n</code></pre>"},{"location":"examples/expert-systems/#3-explanation-facility","title":"3. Explanation Facility","text":"<p>Track reasoning for transparency:</p> <pre><code>@explanations &lt;&lt; {\n  rule: \"hypothesize_flu\",\n  reasoning: \"Classic flu triad: fever + body aches + fatigue\",\n  confidence: confidence\n}\n</code></pre>"},{"location":"examples/expert-systems/#4-differential-diagnosis","title":"4. Differential Diagnosis","text":"<p>Multiple hypotheses with varying confidence:</p> <pre><code># System can maintain:\n# - Flu: 85% confidence\n# - Common cold: 60% confidence\n# - Strep throat: 40% confidence\n\nall_diagnoses = facts.select { |f| f.type == :diagnosis }\nbest = all_diagnoses.max_by { |d| d[:confidence] }\n</code></pre>"},{"location":"examples/expert-systems/#5-negation-for-diagnosis","title":"5. Negation for Diagnosis","text":"<p>Use absence of symptoms to refine diagnosis:</p> <pre><code># Strep throat: sore throat + fever WITHOUT cough\nKBS::Condition.new(:symptom, {\n  type: \"cough\",\n  present: true\n}, negated: true)\n</code></pre>"},{"location":"examples/expert-systems/#expert-system-patterns","title":"Expert System Patterns","text":""},{"location":"examples/expert-systems/#forward-chaining","title":"Forward Chaining","text":"<p>Data-driven reasoning from symptoms to diagnosis:</p> <pre><code>Symptoms \u2192 Intermediate Facts \u2192 Hypotheses \u2192 Final Diagnosis\n</code></pre> <pre><code># 1. Symptom facts added\nadd_symptom(\"temperature\", value: 39.2)\n\n# 2. Engine detects fever\nfever_detected fact created\n\n# 3. Engine hypothesizes diseases\ndiagnosis facts created\n\n# 4. Engine selects best diagnosis\nfinal_diagnosis fact created\n</code></pre>"},{"location":"examples/expert-systems/#backward-chaining","title":"Backward Chaining","text":"<p>Goal-driven reasoning (query mode):</p> <pre><code>class BackwardChainingExpert &lt; MedicalExpertSystem\n  def why_diagnosis?(disease)\n    diagnosis = @engine.facts.find { |f|\n      f.type == :diagnosis &amp;&amp; f[:disease] == disease\n    }\n\n    return nil unless diagnosis\n\n    # Find which symptoms led to this diagnosis\n    required_symptoms = diagnosis[:symptoms]\n    present_symptoms = @engine.facts.select { |f|\n      f.type == :symptom &amp;&amp; required_symptoms.include?(f[:type])\n    }\n\n    {\n      disease: disease,\n      confidence: diagnosis[:confidence],\n      supporting_symptoms: present_symptoms,\n      reasoning: @explanations.find { |e| e[:rule].include?(disease) }\n    }\n  end\nend\n\n# Usage\nexpert = BackwardChainingExpert.new\nexpert.add_symptom(\"fever\", value: 39.0)\nexpert.add_symptom(\"body_aches\", present: true)\nexpert.diagnose\n\nwhy = expert.why_diagnosis?(\"flu\")\nputs \"Why flu?\"\nputs \"  Confidence: #{why[:confidence]}\"\nputs \"  Supporting: #{why[:supporting_symptoms].map(&amp;:type).join(', ')}\"\n</code></pre>"},{"location":"examples/expert-systems/#certainty-factors","title":"Certainty Factors","text":"<p>Combine evidence with certainty calculus:</p> <pre><code>def combine_certainty_factors(cf1, cf2)\n  if cf1 &gt; 0 &amp;&amp; cf2 &gt; 0\n    cf1 + cf2 * (1 - cf1)\n  elsif cf1 &lt; 0 &amp;&amp; cf2 &lt; 0\n    cf1 + cf2 * (1 + cf1)\n  else\n    (cf1 + cf2) / (1 - [cf1.abs, cf2.abs].min)\n  end\nend\n\n# Example: Multiple pieces of evidence for flu\nfever_cf = 0.6\naches_cf = 0.4\ncough_cf = 0.3\n\ncombined = combine_certainty_factors(fever_cf, aches_cf)\ncombined = combine_certainty_factors(combined, cough_cf)\n# Result: Higher confidence with more evidence\n</code></pre>"},{"location":"examples/expert-systems/#meta-rules","title":"Meta-Rules","text":"<p>Rules about rules:</p> <pre><code># Meta-rule: If confidence moderate, recommend test\nKBS::Rule.new(\"recommend_test_meta\", priority: 50) do |r|\n  r.conditions = [\n    KBS::Condition.new(:diagnosis, {\n      confidence: :conf?\n    }, predicate: lambda { |f| f[:confidence].between?(0.5, 0.85) })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    @engine.add_fact(:action_needed, {\n      type: \"diagnostic_test\",\n      reason: \"Confidence not high enough for treatment\"\n    })\n  end\nend\n</code></pre>"},{"location":"examples/expert-systems/#advanced-features","title":"Advanced Features","text":""},{"location":"examples/expert-systems/#temporal-reasoning","title":"Temporal Reasoning","text":"<p>Track symptom progression:</p> <pre><code>class TemporalExpertSystem &lt; MedicalExpertSystem\n  def add_symptom_with_timing(type, onset, attributes = {})\n    @engine.add_fact(:symptom, {\n      type: type,\n      onset: onset,\n      **attributes\n    })\n  end\n\n  def setup_temporal_rules\n    # Rule: Rapid onset fever + headache suggests infection\n    rapid_onset_rule = KBS::Rule.new(\"rapid_onset_infection\") do |r|\n      r.conditions = [\n        KBS::Condition.new(:symptom, {\n          type: \"fever\",\n          onset: :onset1?\n        }, predicate: lambda { |f|\n          (Time.now - f[:onset]) &lt; 3600 * 24  # &lt; 24 hours\n        }),\n\n        KBS::Condition.new(:symptom, {\n          type: \"headache\",\n          onset: :onset2?\n        }, predicate: lambda { |f|\n          (Time.now - f[:onset]) &lt; 3600 * 24\n        })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:diagnosis, {\n          disease: \"acute_infection\",\n          confidence: 0.75,\n          reasoning: \"Rapid onset suggests acute process\"\n        })\n      end\n    end\n\n    @engine.add_rule(rapid_onset_rule)\n  end\nend\n</code></pre>"},{"location":"examples/expert-systems/#conflict-resolution","title":"Conflict Resolution","text":"<p>Handle contradictory evidence:</p> <pre><code># Rule: Resolve conflicting diagnoses\nKBS::Rule.new(\"resolve_conflicts\", priority: 55) do |r|\n  r.conditions = [\n    KBS::Condition.new(:diagnosis, {\n      disease: \"flu\",\n      confidence: :flu_conf?\n    }),\n\n    KBS::Condition.new(:diagnosis, {\n      disease: \"common_cold\",\n      confidence: :cold_conf?\n    })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Flu and cold are mutually exclusive\n    if bindings[:flu_conf?] &gt; bindings[:cold_conf?]\n      cold = facts.find { |f| f.type == :diagnosis &amp;&amp; f[:disease] == \"common_cold\" }\n      @engine.remove_fact(cold)\n    else\n      flu = facts.find { |f| f.type == :diagnosis &amp;&amp; f[:disease] == \"flu\" }\n      @engine.remove_fact(flu)\n    end\n  end\nend\n</code></pre>"},{"location":"examples/expert-systems/#learning-from-cases","title":"Learning from Cases","text":"<p>Update confidence factors based on outcomes:</p> <pre><code>class LearningExpertSystem &lt; MedicalExpertSystem\n  def initialize(db_path: 'medical_learning.db')\n    super\n    @case_history = load_case_history\n  end\n\n  def record_outcome(symptoms, actual_diagnosis)\n    # Store case for learning\n    @case_history &lt;&lt; {\n      symptoms: symptoms,\n      diagnosis: actual_diagnosis,\n      timestamp: Time.now\n    }\n\n    save_case_history\n    update_confidence_weights\n  end\n\n  def update_confidence_weights\n    # Analyze historical accuracy\n    # Adjust confidence factors for rules\n    @case_history.group_by { |c| c[:diagnosis] }.each do |disease, cases|\n      accuracy = calculate_accuracy(disease, cases)\n      adjust_rule_confidence(disease, accuracy)\n    end\n  end\n\n  private\n\n  def calculate_accuracy(disease, cases)\n    # Calculate how often diagnosis was correct\n    cases.count { |c| c[:confirmed] }.to_f / cases.size\n  end\n\n  def adjust_rule_confidence(disease, accuracy)\n    # Modify confidence factors based on historical performance\n    # Implementation depends on your confidence model\n  end\nend\n</code></pre>"},{"location":"examples/expert-systems/#testing","title":"Testing","text":"<pre><code>require 'minitest/autorun'\n\nclass TestMedicalExpertSystem &lt; Minitest::Test\n  def setup\n    @system = MedicalExpertSystem.new(db_path: ':memory:')\n  end\n\n  def test_flu_diagnosis\n    @system.add_symptom(\"temperature\", value: 39.0)\n    @system.add_symptom(\"body_aches\", present: true)\n    @system.add_symptom(\"fatigue\", present: true)\n\n    result = @system.diagnose\n\n    assert_equal \"flu\", result[:diagnosis][:disease]\n    assert result[:diagnosis][:confidence] &gt; 0.6\n  end\n\n  def test_strep_throat_vs_viral\n    @system.add_symptom(\"temperature\", value: 38.8)\n    @system.add_symptom(\"sore_throat\", severity: \"severe\", present: true)\n    @system.add_symptom(\"swollen_lymph_nodes\", present: true)\n    # No cough - key differentiator\n\n    result = @system.diagnose\n\n    assert_equal \"strep_throat\", result[:diagnosis][:disease]\n    assert result[:diagnosis][:confidence] &gt; 0.7\n  end\n\n  def test_allergy_no_fever\n    @system.add_symptom(\"sneezing\", frequency: \"frequent\", present: true)\n    @system.add_symptom(\"itchy_eyes\", present: true)\n    @system.add_symptom(\"runny_nose\", present: true)\n\n    result = @system.diagnose\n\n    assert_equal \"allergies\", result[:diagnosis][:disease]\n\n    # Should NOT detect fever\n    fever_facts = @system.instance_variable_get(:@engine).facts.select { |f|\n      f.type == :fever_detected\n    }\n    assert_empty fever_facts\n  end\n\n  def test_differential_diagnosis\n    @system.add_symptom(\"temperature\", value: 38.2)\n    @system.add_symptom(\"runny_nose\", present: true)\n    @system.add_symptom(\"congestion\", present: true)\n    @system.add_symptom(\"sneezing\", present: true)\n\n    result = @system.diagnose\n\n    # Should have multiple hypotheses\n    assert result[:all_hypotheses].size &gt; 1\n\n    # Cold should win (has all symptoms)\n    assert_equal \"common_cold\", result[:diagnosis][:disease]\n  end\n\n  def test_confidence_factors\n    @system.add_symptom(\"temperature\", value: 40.5)  # Very high fever\n    @system.add_symptom(\"body_aches\", present: true)\n    @system.add_symptom(\"fatigue\", present: true)\n    @system.add_symptom(\"cough\", present: true)\n\n    result = @system.diagnose\n\n    # High fever + all symptoms = high confidence\n    assert result[:diagnosis][:confidence] &gt; 0.8\n  end\n\n  def test_explanation_facility\n    @system.add_symptom(\"temperature\", value: 39.0)\n    @system.add_symptom(\"body_aches\", present: true)\n    @system.add_symptom(\"fatigue\", present: true)\n\n    result = @system.diagnose\n\n    explanations = result[:explanations]\n\n    # Should have explanations for each rule fired\n    assert explanations.size &gt; 0\n\n    # Each explanation should have rule, reasoning, confidence\n    explanations.each do |exp|\n      assert exp[:rule]\n      assert exp[:reasoning]\n      assert exp[:confidence]\n    end\n  end\n\n  def test_diagnostic_test_recommendation\n    @system.add_symptom(\"temperature\", value: 38.5)\n    @system.add_symptom(\"body_aches\", present: true)\n    @system.add_symptom(\"fatigue\", present: true)\n    # Moderate confidence scenario\n\n    result = @system.diagnose\n\n    # Should recommend confirmatory test if confidence moderate\n    if result[:diagnosis][:confidence].between?(0.7, 0.9)\n      assert result[:recommended_tests].any?\n    end\n  end\nend\n</code></pre>"},{"location":"examples/expert-systems/#performance-optimization","title":"Performance Optimization","text":""},{"location":"examples/expert-systems/#use-blackboard-for-complex-cases","title":"Use Blackboard for Complex Cases","text":"<pre><code># For large knowledge bases, use persistent storage\nsystem = MedicalExpertSystem.new(db_path: 'medical_kb.db')\n\n# Facts persist across consultations\n# Audit trail for medical record keeping\n</code></pre>"},{"location":"examples/expert-systems/#index-common-queries","title":"Index Common Queries","text":"<pre><code>class OptimizedExpertSystem &lt; MedicalExpertSystem\n  def initialize(db_path:)\n    super\n    @symptom_index = {}\n    @diagnosis_cache = {}\n  end\n\n  def add_symptom(type, attributes = {})\n    super\n\n    # Index for fast lookup\n    @symptom_index[type] ||= []\n    @symptom_index[type] &lt;&lt; attributes\n  end\n\n  def has_symptom?(type)\n    @symptom_index.key?(type)\n  end\nend\n</code></pre>"},{"location":"examples/expert-systems/#production-considerations","title":"Production Considerations","text":""},{"location":"examples/expert-systems/#disclaimer-and-safety","title":"Disclaimer and Safety","text":"<pre><code>def diagnose\n  result = super\n\n  result[:disclaimer] = \"This is an expert system for educational purposes. \" \\\n                        \"Always consult a qualified healthcare professional \" \\\n                        \"for medical advice.\"\n\n  result\nend\n</code></pre>"},{"location":"examples/expert-systems/#audit-trail","title":"Audit Trail","text":"<pre><code># Blackboard automatically logs all reasoning\nsystem = MedicalExpertSystem.new(db_path: 'medical_audit.db')\n\n# Later: Review consultation\nconsultation = system.instance_variable_get(:@engine)\n  .fact_history\n  .select { |h| h[:fact_type] == :diagnosis }\n\nputs \"Diagnosis history:\"\nconsultation.each do |entry|\n  puts \"#{entry[:timestamp]}: #{entry[:attributes][:disease]} (#{entry[:attributes][:confidence]})\"\nend\n</code></pre>"},{"location":"examples/expert-systems/#integration-with-clinical-systems","title":"Integration with Clinical Systems","text":"<pre><code>class ClinicalExpertSystem &lt; MedicalExpertSystem\n  def import_from_ehr(patient_id, ehr_client)\n    # Import symptoms from Electronic Health Record\n    symptoms = ehr_client.get_symptoms(patient_id)\n\n    symptoms.each do |symptom|\n      add_symptom(symptom[:type], symptom[:attributes])\n    end\n  end\n\n  def export_diagnosis_to_ehr(patient_id, ehr_client)\n    result = diagnose\n\n    ehr_client.add_note(patient_id, {\n      type: \"expert_system_consultation\",\n      diagnosis: result[:diagnosis],\n      confidence: result[:diagnosis][:confidence],\n      reasoning: result[:explanations],\n      timestamp: Time.now\n    })\n  end\nend\n</code></pre>"},{"location":"examples/expert-systems/#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Agent Example - Multiple expert systems collaborating</li> <li>Blackboard Memory - Persistent knowledge bases</li> <li>Performance Guide - Optimize large knowledge bases</li> <li>Testing Guide - Test expert system rules</li> </ul> <p>Expert systems encode domain expertise in rules and reasoning. KBS provides the inference engine, you provide the knowledge.</p>"},{"location":"examples/multi-agent/","title":"Multi-Agent Systems","text":"<p>Build collaborative multi-agent systems using KBS blackboard memory for coordination, message passing, and distributed reasoning.</p>"},{"location":"examples/multi-agent/#system-overview","title":"System Overview","text":"<p>This example demonstrates a smart home automation system with:</p> <ul> <li>Multiple Specialized Agents - Temperature, security, energy, scheduling</li> <li>Blackboard Coordination - Shared persistent workspace</li> <li>Message Passing - Inter-agent communication via priority queues</li> <li>Conflict Resolution - Arbitration when agents disagree</li> <li>Emergent Behavior - Complex system behavior from simple agent rules</li> </ul>"},{"location":"examples/multi-agent/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Blackboard Memory \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                         \u2502\n\u2502  Facts: sensor_reading, alert, command, agent_status   \u2502\n\u2502  Messages: priority queues for agent communication     \u2502\n\u2502  Audit: complete history of all agent actions          \u2502\n\u2502                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502              \u2502              \u2502              \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n  \u2502 Temp     \u2502   \u2502 Security \u2502  \u2502 Energy   \u2502  \u2502 Schedule \u2502\n  \u2502 Agent    \u2502   \u2502 Agent    \u2502  \u2502 Agent    \u2502  \u2502 Agent    \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/multi-agent/#complete-implementation","title":"Complete Implementation","text":""},{"location":"examples/multi-agent/#multi-agent-smart-home","title":"Multi-Agent Smart Home","text":"<pre><code>require 'kbs'\n\n# Base agent class\nclass Agent\n  attr_reader :name, :engine\n\n  def initialize(name, engine)\n    @name = name\n    @engine = engine\n    @running = false\n  end\n\n  def start\n    @running = true\n    @engine.add_fact(:agent_status, {\n      agent: @name,\n      status: \"started\",\n      timestamp: Time.now\n    })\n  end\n\n  def stop\n    @running = false\n    @engine.add_fact(:agent_status, {\n      agent: @name,\n      status: \"stopped\",\n      timestamp: Time.now\n    })\n  end\n\n  def running?\n    @running\n  end\n\n  def send_message(topic, content, priority: 50)\n    @engine.send_message(topic, {\n      from: @name,\n      content: content,\n      timestamp: Time.now\n    }, priority: priority)\n  end\n\n  def receive_messages(topic)\n    messages = []\n    while (msg = @engine.pop_message(topic))\n      messages &lt;&lt; msg\n    end\n    messages\n  end\n\n  # Override in subclasses\n  def process\n    raise NotImplementedError, \"Subclass must implement process\"\n  end\n\n  def run_cycle\n    return unless running?\n    process\n  end\nend\n\n# Temperature control agent\nclass TemperatureAgent &lt; Agent\n  def initialize(engine, target_temp: 22.0)\n    super(\"TemperatureAgent\", engine)\n    @target_temp = target_temp\n    setup_rules\n  end\n\n  def setup_rules\n    # Rule 1: Detect high temperature\n    high_temp_rule = KBS::Rule.new(\"detect_high_temperature\", priority: 100) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor_reading, {\n          type: \"temperature\",\n          location: :location?,\n          value: :temp?\n        }, predicate: lambda { |f| f[:value] &gt; @target_temp + 2 }),\n\n        KBS::Condition.new(:temperature_alert, {\n          location: :location?\n        }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:temperature_alert, {\n          location: bindings[:location?],\n          temperature: bindings[:temp?],\n          severity: \"high\",\n          timestamp: Time.now\n        })\n\n        send_message(:hvac_control, {\n          action: \"cool\",\n          location: bindings[:location?],\n          target: @target_temp\n        }, priority: 80)\n      end\n    end\n\n    # Rule 2: Detect low temperature\n    low_temp_rule = KBS::Rule.new(\"detect_low_temperature\", priority: 100) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor_reading, {\n          type: \"temperature\",\n          location: :location?,\n          value: :temp?\n        }, predicate: lambda { |f| f[:value] &lt; @target_temp - 2 }),\n\n        KBS::Condition.new(:temperature_alert, {\n          location: :location?\n        }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:temperature_alert, {\n          location: bindings[:location?],\n          temperature: bindings[:temp?],\n          severity: \"low\",\n          timestamp: Time.now\n        })\n\n        send_message(:hvac_control, {\n          action: \"heat\",\n          location: bindings[:location?],\n          target: @target_temp\n        }, priority: 80)\n      end\n    end\n\n    # Rule 3: Clear alert when temperature normalized\n    clear_alert_rule = KBS::Rule.new(\"clear_temperature_alert\", priority: 90) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor_reading, {\n          type: \"temperature\",\n          location: :location?,\n          value: :temp?\n        }, predicate: lambda { |f|\n          (f[:value] - @target_temp).abs &lt;= 1\n        }),\n\n        KBS::Condition.new(:temperature_alert, {\n          location: :location?\n        })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        alert = facts.find { |f|\n          f.type == :temperature_alert &amp;&amp; f[:location] == bindings[:location?]\n        }\n        @engine.remove_fact(alert) if alert\n\n        send_message(:hvac_control, {\n          action: \"off\",\n          location: bindings[:location?]\n        }, priority: 50)\n      end\n    end\n\n    @engine.add_rule(high_temp_rule)\n    @engine.add_rule(low_temp_rule)\n    @engine.add_rule(clear_alert_rule)\n  end\n\n  def process\n    @engine.run\n  end\nend\n\n# Security monitoring agent\nclass SecurityAgent &lt; Agent\n  def initialize(engine)\n    super(\"SecurityAgent\", engine)\n    setup_rules\n  end\n\n  def setup_rules\n    # Rule 1: Detect intrusion\n    intrusion_rule = KBS::Rule.new(\"detect_intrusion\", priority: 100) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor_reading, {\n          type: \"motion\",\n          location: :location?,\n          detected: true\n        }),\n\n        KBS::Condition.new(:occupancy, {\n          status: \"away\"\n        }),\n\n        KBS::Condition.new(:security_alert, {\n          type: \"intrusion\",\n          location: :location?\n        }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:security_alert, {\n          type: \"intrusion\",\n          location: bindings[:location?],\n          severity: \"critical\",\n          timestamp: Time.now\n        })\n\n        send_message(:security_system, {\n          action: \"alarm\",\n          location: bindings[:location?]\n        }, priority: 100)\n\n        send_message(:notifications, {\n          type: \"security\",\n          message: \"Intrusion detected at #{bindings[:location?]}\"\n        }, priority: 100)\n      end\n    end\n\n    # Rule 2: Door left open\n    door_open_rule = KBS::Rule.new(\"detect_door_open\", priority: 90) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor_reading, {\n          type: \"door\",\n          location: :location?,\n          state: \"open\",\n          timestamp: :time?\n        }, predicate: lambda { |f|\n          (Time.now - f[:timestamp]) &gt; 300  # Open for 5 minutes\n        }),\n\n        KBS::Condition.new(:security_alert, {\n          type: \"door_open\",\n          location: :location?\n        }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:security_alert, {\n          type: \"door_open\",\n          location: bindings[:location?],\n          severity: \"medium\",\n          timestamp: Time.now\n        })\n\n        send_message(:notifications, {\n          type: \"security\",\n          message: \"Door at #{bindings[:location?]} left open\"\n        }, priority: 70)\n      end\n    end\n\n    @engine.add_rule(intrusion_rule)\n    @engine.add_rule(door_open_rule)\n  end\n\n  def process\n    @engine.run\n  end\nend\n\n# Energy management agent\nclass EnergyAgent &lt; Agent\n  def initialize(engine, max_usage: 5000)\n    super(\"EnergyAgent\", engine)\n    @max_usage = max_usage  # watts\n    setup_rules\n  end\n\n  def setup_rules\n    # Rule 1: High energy consumption\n    high_consumption_rule = KBS::Rule.new(\"detect_high_consumption\", priority: 80) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor_reading, {\n          type: \"power\",\n          value: :usage?\n        }, predicate: lambda { |f| f[:value] &gt; @max_usage }),\n\n        KBS::Condition.new(:energy_alert, {\n          type: \"high_consumption\"\n        }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:energy_alert, {\n          type: \"high_consumption\",\n          usage: bindings[:usage?],\n          limit: @max_usage,\n          timestamp: Time.now\n        })\n\n        # Request non-essential devices to reduce consumption\n        send_message(:device_control, {\n          action: \"reduce_consumption\",\n          priority_level: \"low\"\n        }, priority: 60)\n\n        send_message(:notifications, {\n          type: \"energy\",\n          message: \"High energy usage: #{bindings[:usage?]}W (limit: #{@max_usage}W)\"\n        }, priority: 60)\n      end\n    end\n\n    # Rule 2: Coordinate with HVAC during high usage\n    hvac_coordination_rule = KBS::Rule.new(\"coordinate_hvac_energy\", priority: 75) do |r|\n      r.conditions = [\n        KBS::Condition.new(:energy_alert, {\n          type: \"high_consumption\"\n        }),\n\n        KBS::Condition.new(:temperature_alert, {\n          location: :location?\n        })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        # Ask temperature agent to reduce HVAC intensity\n        send_message(:hvac_control, {\n          action: \"eco_mode\",\n          location: bindings[:location?]\n        }, priority: 70)\n      end\n    end\n\n    @engine.add_rule(high_consumption_rule)\n    @engine.add_rule(hvac_coordination_rule)\n  end\n\n  def process\n    @engine.run\n  end\nend\n\n# Scheduling agent\nclass ScheduleAgent &lt; Agent\n  def initialize(engine)\n    super(\"ScheduleAgent\", engine)\n    setup_rules\n  end\n\n  def setup_rules\n    # Rule 1: Morning routine\n    morning_rule = KBS::Rule.new(\"morning_routine\", priority: 70) do |r|\n      r.conditions = [\n        KBS::Condition.new(:time_event, {\n          event: \"morning\",\n          hour: :hour?\n        }),\n\n        KBS::Condition.new(:routine_executed, {\n          type: \"morning\"\n        }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:routine_executed, {\n          type: \"morning\",\n          timestamp: Time.now\n        })\n\n        # Update occupancy\n        @engine.add_fact(:occupancy, { status: \"home\" })\n\n        # Adjust temperature\n        send_message(:temperature_control, {\n          action: \"set_target\",\n          temperature: 22\n        }, priority: 50)\n\n        # Turn on lights\n        send_message(:device_control, {\n          action: \"lights_on\",\n          locations: [\"bedroom\", \"kitchen\"]\n        }, priority: 40)\n      end\n    end\n\n    # Rule 2: Night routine\n    night_rule = KBS::Rule.new(\"night_routine\", priority: 70) do |r|\n      r.conditions = [\n        KBS::Condition.new(:time_event, {\n          event: \"night\",\n          hour: :hour?\n        }),\n\n        KBS::Condition.new(:routine_executed, {\n          type: \"night\"\n        }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @engine.add_fact(:routine_executed, {\n          type: \"night\",\n          timestamp: Time.now\n        })\n\n        # Update occupancy\n        @engine.add_fact(:occupancy, { status: \"sleeping\" })\n\n        # Lower temperature\n        send_message(:temperature_control, {\n          action: \"set_target\",\n          temperature: 18\n        }, priority: 50)\n\n        # Turn off lights except nightlights\n        send_message(:device_control, {\n          action: \"lights_off\",\n          exclude: [\"bathroom_nightlight\"]\n        }, priority: 40)\n\n        # Enable security\n        send_message(:security_system, {\n          action: \"arm_night_mode\"\n        }, priority: 60)\n      end\n    end\n\n    # Rule 3: Away mode\n    away_rule = KBS::Rule.new(\"away_mode\", priority: 70) do |r|\n      r.conditions = [\n        KBS::Condition.new(:time_event, {\n          event: \"departure\"\n        }),\n\n        KBS::Condition.new(:occupancy, {\n          status: \"away\"\n        }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        old_occupancy = @engine.facts.find { |f| f.type == :occupancy }\n        @engine.remove_fact(old_occupancy) if old_occupancy\n\n        @engine.add_fact(:occupancy, { status: \"away\" })\n\n        # Turn off all lights\n        send_message(:device_control, {\n          action: \"all_lights_off\"\n        }, priority: 40)\n\n        # Energy saving mode\n        send_message(:temperature_control, {\n          action: \"eco_mode\"\n        }, priority: 50)\n\n        # Arm security\n        send_message(:security_system, {\n          action: \"arm_away_mode\"\n        }, priority: 80)\n      end\n    end\n\n    @engine.add_rule(morning_rule)\n    @engine.add_rule(night_rule)\n    @engine.add_rule(away_rule)\n  end\n\n  def process\n    @engine.run\n  end\nend\n\n# Arbitration agent - resolves conflicts\nclass ArbitrationAgent &lt; Agent\n  def initialize(engine)\n    super(\"ArbitrationAgent\", engine)\n    setup_rules\n  end\n\n  def setup_rules\n    # Rule: Security overrides energy savings\n    security_priority_rule = KBS::Rule.new(\"security_overrides_energy\", priority: 95) do |r|\n      r.conditions = [\n        KBS::Condition.new(:security_alert, {\n          severity: \"critical\"\n        }),\n\n        KBS::Condition.new(:energy_alert, {\n          type: \"high_consumption\"\n        })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        # Cancel energy reduction requests\n        send_message(:device_control, {\n          action: \"cancel_energy_reduction\",\n          reason: \"security_priority\"\n        }, priority: 95)\n\n        # Notify\n        send_message(:notifications, {\n          type: \"system\",\n          message: \"Security takes priority over energy savings\"\n        }, priority: 90)\n      end\n    end\n\n    # Rule: Comfort overrides energy during occupied hours\n    comfort_priority_rule = KBS::Rule.new(\"comfort_during_occupied\", priority: 85) do |r|\n      r.conditions = [\n        KBS::Condition.new(:occupancy, {\n          status: :status?\n        }, predicate: lambda { |f| f[:status] == \"home\" || f[:status] == \"sleeping\" }),\n\n        KBS::Condition.new(:temperature_alert, {\n          severity: :severity?\n        }),\n\n        KBS::Condition.new(:energy_alert, {\n          type: \"high_consumption\"\n        })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        # Allow HVAC to continue despite high energy\n        send_message(:hvac_control, {\n          action: \"maintain_comfort\",\n          reason: \"occupancy_priority\"\n        }, priority: 85)\n      end\n    end\n\n    @engine.add_rule(security_priority_rule)\n    @engine.add_rule(comfort_priority_rule)\n  end\n\n  def process\n    @engine.run\n  end\nend\n\n# Multi-agent system coordinator\nclass SmartHomeSystem\n  attr_reader :engine, :agents\n\n  def initialize(db_path: 'smart_home.db')\n    @engine = KBS::Blackboard::Engine.new(db_path: db_path)\n    @agents = []\n    @running = false\n\n    setup_agents\n  end\n\n  def setup_agents\n    @agents &lt;&lt; TemperatureAgent.new(@engine, target_temp: 22.0)\n    @agents &lt;&lt; SecurityAgent.new(@engine)\n    @agents &lt;&lt; EnergyAgent.new(@engine, max_usage: 5000)\n    @agents &lt;&lt; ScheduleAgent.new(@engine)\n    @agents &lt;&lt; ArbitrationAgent.new(@engine)\n  end\n\n  def start\n    @running = true\n    @agents.each(&amp;:start)\n\n    puts \"Smart Home System started with #{@agents.size} agents\"\n  end\n\n  def stop\n    @running = false\n    @agents.each(&amp;:stop)\n\n    @engine.close\n    puts \"Smart Home System stopped\"\n  end\n\n  def add_sensor_reading(type, attributes)\n    @engine.add_fact(:sensor_reading, {\n      type: type,\n      timestamp: Time.now,\n      **attributes\n    })\n  end\n\n  def trigger_time_event(event, attributes = {})\n    @engine.add_fact(:time_event, {\n      event: event,\n      timestamp: Time.now,\n      **attributes\n    })\n  end\n\n  def run_cycle\n    # Each agent processes in sequence\n    @agents.each(&amp;:run_cycle)\n  end\n\n  def run_continuous(interval: 1)\n    while @running\n      run_cycle\n      sleep interval\n    end\n  end\n\n  def status\n    {\n      running: @running,\n      agents: @agents.map { |a| { name: a.name, running: a.running? } },\n      facts: @engine.facts.size,\n      alerts: @engine.facts.select { |f| f.type.to_s.include?(\"alert\") }.size\n    }\n  end\nend\n\n# Usage Example 1: Temperature Control\nputs \"=== Example 1: Temperature Control ===\"\nsystem = SmartHomeSystem.new(db_path: ':memory:')\nsystem.start\n\n# Add temperature reading\nsystem.add_sensor_reading(\"temperature\", {\n  location: \"living_room\",\n  value: 26.0  # Above target (22\u00b0C)\n})\n\n# Run agent cycle\nsystem.run_cycle\n\n# Check for temperature alerts\nalerts = system.engine.facts.select { |f| f.type == :temperature_alert }\nputs \"\\nTemperature Alerts:\"\nalerts.each do |alert|\n  puts \"  Location: #{alert[:location]}\"\n  puts \"  Temperature: #{alert[:temperature]}\u00b0C\"\n  puts \"  Severity: #{alert[:severity]}\"\nend\n\n# Check HVAC messages\nhvac_messages = []\nwhile (msg = system.engine.pop_message(:hvac_control))\n  hvac_messages &lt;&lt; msg\nend\n\nputs \"\\nHVAC Control Messages:\"\nhvac_messages.each do |msg|\n  puts \"  From: #{msg[:content][:from]}\"\n  puts \"  Action: #{msg[:content][:content][:action]}\"\n  puts \"  Priority: #{msg[:priority]}\"\nend\n\n# Usage Example 2: Security Event\nputs \"\\n\\n=== Example 2: Security Event ===\"\nsystem2 = SmartHomeSystem.new(db_path: ':memory:')\nsystem2.start\n\n# Set away mode\nsystem2.engine.add_fact(:occupancy, { status: \"away\" })\n\n# Motion detected while away\nsystem2.add_sensor_reading(\"motion\", {\n  location: \"living_room\",\n  detected: true\n})\n\nsystem2.run_cycle\n\n# Check security alerts\nsecurity_alerts = system2.engine.facts.select { |f| f.type == :security_alert }\nputs \"\\nSecurity Alerts:\"\nsecurity_alerts.each do |alert|\n  puts \"  Type: #{alert[:type]}\"\n  puts \"  Location: #{alert[:location]}\"\n  puts \"  Severity: #{alert[:severity]}\"\nend\n\n# Check notifications\nnotifications = []\nwhile (msg = system2.engine.pop_message(:notifications))\n  notifications &lt;&lt; msg\nend\n\nputs \"\\nNotifications:\"\nnotifications.each do |msg|\n  puts \"  Type: #{msg[:content][:content][:type]}\"\n  puts \"  Message: #{msg[:content][:content][:message]}\"\n  puts \"  Priority: #{msg[:priority]}\"\nend\n\n# Usage Example 3: Energy Management with Arbitration\nputs \"\\n\\n=== Example 3: Energy Management ===\"\nsystem3 = SmartHomeSystem.new(db_path: ':memory:')\nsystem3.start\n\n# High energy consumption\nsystem3.add_sensor_reading(\"power\", { value: 6000 })  # Above 5000W limit\n\n# Also high temperature (competing concern)\nsystem3.add_sensor_reading(\"temperature\", {\n  location: \"bedroom\",\n  value: 26.0\n})\n\n# Home occupancy\nsystem3.engine.add_fact(:occupancy, { status: \"home\" })\n\nsystem3.run_cycle\n\n# Check arbitration\nenergy_alerts = system3.engine.facts.select { |f| f.type == :energy_alert }\ntemp_alerts = system3.engine.facts.select { |f| f.type == :temperature_alert }\n\nputs \"\\nEnergy Alerts: #{energy_alerts.size}\"\nputs \"Temperature Alerts: #{temp_alerts.size}\"\n\n# HVAC should maintain comfort despite high energy (arbitration)\nhvac_msgs = []\nwhile (msg = system3.engine.pop_message(:hvac_control))\n  hvac_msgs &lt;&lt; msg\nend\n\nputs \"\\nHVAC Messages:\"\nhvac_msgs.each do |msg|\n  puts \"  Action: #{msg[:content][:content][:action]}\"\nend\n\n# Usage Example 4: Morning Routine\nputs \"\\n\\n=== Example 4: Morning Routine ===\"\nsystem4 = SmartHomeSystem.new(db_path: ':memory:')\nsystem4.start\n\n# Trigger morning event\nsystem4.trigger_time_event(\"morning\", { hour: 7 })\n\nsystem4.run_cycle\n\n# Check messages sent to various subsystems\ntemp_msgs = []\nwhile (msg = system4.engine.pop_message(:temperature_control))\n  temp_msgs &lt;&lt; msg\nend\n\ndevice_msgs = []\nwhile (msg = system4.engine.pop_message(:device_control))\n  device_msgs &lt;&lt; msg\nend\n\nputs \"\\nMorning Routine Executed:\"\nputs \"  Temperature control messages: #{temp_msgs.size}\"\nputs \"  Device control messages: #{device_msgs.size}\"\n\ntemp_msgs.each do |msg|\n  puts \"  - Set temperature to #{msg[:content][:content][:temperature]}\u00b0C\"\nend\n\ndevice_msgs.each do |msg|\n  puts \"  - #{msg[:content][:content][:action]}\"\nend\n\nputs \"\\nSystem Status:\"\nputs system4.status.inspect\n</code></pre>"},{"location":"examples/multi-agent/#key-features","title":"Key Features","text":""},{"location":"examples/multi-agent/#1-agent-autonomy","title":"1. Agent Autonomy","text":"<p>Each agent operates independently:</p> <pre><code>class Agent\n  def run_cycle\n    return unless running?\n    process  # Agent-specific logic\n  end\nend\n</code></pre>"},{"location":"examples/multi-agent/#2-blackboard-coordination","title":"2. Blackboard Coordination","text":"<p>Shared workspace for collaboration:</p> <pre><code># Agent 1 writes fact\n@engine.add_fact(:temperature_alert, { location: \"bedroom\" })\n\n# Agent 2 reads fact and responds\ntemperature_alert = @engine.facts.find { |f|\n  f.type == :temperature_alert &amp;&amp; f[:location] == \"bedroom\"\n}\n</code></pre>"},{"location":"examples/multi-agent/#3-message-passing","title":"3. Message Passing","text":"<p>Priority-based communication:</p> <pre><code># Temperature agent sends message\nsend_message(:hvac_control, {\n  action: \"cool\",\n  location: \"bedroom\"\n}, priority: 80)\n\n# HVAC controller receives message\nmsg = @engine.pop_message(:hvac_control)\n# Process highest priority message first\n</code></pre>"},{"location":"examples/multi-agent/#4-conflict-resolution","title":"4. Conflict Resolution","text":"<p>Arbitration agent resolves competing goals:</p> <pre><code># Security overrides energy savings\nKBS::Rule.new(\"security_overrides_energy\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:security_alert, { severity: \"critical\" }),\n    KBS::Condition.new(:energy_alert, { type: \"high_consumption\" })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Cancel energy reduction\n    send_message(:device_control, {\n      action: \"cancel_energy_reduction\",\n      reason: \"security_priority\"\n    }, priority: 95)\n  end\nend\n</code></pre>"},{"location":"examples/multi-agent/#5-emergent-behavior","title":"5. Emergent Behavior","text":"<p>Complex system behavior from simple agent rules:</p> <pre><code># Temperature agent: \"Keep temperature at 22\u00b0C\"\n# Energy agent: \"Don't exceed 5000W\"\n# Arbitration agent: \"Comfort during occupied hours\"\n# Result: System automatically balances comfort and efficiency\n</code></pre>"},{"location":"examples/multi-agent/#multi-agent-patterns","title":"Multi-Agent Patterns","text":""},{"location":"examples/multi-agent/#agent-roles","title":"Agent Roles","text":"<p>Reactive Agents: Respond to immediate stimuli</p> <pre><code>class ReactiveAgent &lt; Agent\n  def process\n    # React to current sensor readings\n    sensor_facts = @engine.facts.select { |f| f.type == :sensor_reading }\n    sensor_facts.each { |fact| react_to(fact) }\n  end\nend\n</code></pre> <p>Proactive Agents: Plan and execute goals</p> <pre><code>class ProactiveAgent &lt; Agent\n  def process\n    # Check goals\n    goals = @engine.facts.select { |f| f.type == :goal }\n    goals.each { |goal| plan_for(goal) }\n  end\nend\n</code></pre> <p>Social Agents: Collaborate with other agents</p> <pre><code>class SocialAgent &lt; Agent\n  def process\n    # Coordinate with other agents\n    messages = receive_messages(:coordination)\n    messages.each { |msg| coordinate_with(msg) }\n  end\nend\n</code></pre>"},{"location":"examples/multi-agent/#communication-protocols","title":"Communication Protocols","text":"<p>Request-Reply:</p> <pre><code># Agent A sends request\nsend_message(:task_queue, {\n  type: \"request\",\n  request_id: SecureRandom.uuid,\n  action: \"analyze_data\"\n}, priority: 50)\n\n# Agent B processes and replies\nrequest = @engine.pop_message(:task_queue)\nresult = process_request(request)\n\nsend_message(:responses, {\n  type: \"reply\",\n  request_id: request[:content][:request_id],\n  result: result\n}, priority: 60)\n</code></pre> <p>Broadcast:</p> <pre><code># Agent sends to all\n@engine.add_fact(:broadcast, {\n  from: @name,\n  message: \"System shutdown in 5 minutes\"\n})\n\n# All agents read\nbroadcasts = @engine.facts.select { |f|\n  f.type == :broadcast &amp;&amp; f[:from] != @name\n}\n</code></pre> <p>Negotiation:</p> <pre><code># Agent proposes\n@engine.add_fact(:proposal, {\n  from: @name,\n  resource: \"hvac_bedroom\",\n  duration: 30,\n  priority: 5\n})\n\n# Other agents bid or decline\nexisting_proposals = @engine.facts.select { |f| f.type == :proposal }\nif can_accept?(existing_proposals)\n  @engine.add_fact(:acceptance, { proposal_id: proposal.id })\nelse\n  @engine.add_fact(:counter_proposal, { ... })\nend\n</code></pre>"},{"location":"examples/multi-agent/#coordination-strategies","title":"Coordination Strategies","text":"<p>Centralized Coordination:</p> <pre><code>class CoordinatorAgent &lt; Agent\n  def process\n    # Collect all agent requests\n    requests = []\n    @agents.each do |agent|\n      while (msg = @engine.pop_message(:\"#{agent.name}_requests\"))\n        requests &lt;&lt; msg\n      end\n    end\n\n    # Optimize schedule\n    schedule = optimize_schedule(requests)\n\n    # Dispatch commands\n    schedule.each do |task|\n      send_message(:\"#{task[:agent]}_commands\", task, priority: 70)\n    end\n  end\nend\n</code></pre> <p>Distributed Coordination:</p> <pre><code>class DistributedAgent &lt; Agent\n  def process\n    # Each agent coordinates locally\n    neighbors = find_neighbors\n    neighbors.each do |neighbor|\n      send_message(:\"#{neighbor}_coordination\", {\n        from: @name,\n        state: current_state\n      }, priority: 50)\n    end\n\n    # Adjust based on neighbor states\n    neighbor_states = receive_messages(:\"#{@name}_coordination\")\n    adjust_behavior(neighbor_states)\n  end\nend\n</code></pre> <p>Market-Based Coordination:</p> <pre><code>class MarketAgent &lt; Agent\n  def process\n    # Bid on tasks based on cost\n    tasks = @engine.facts.select { |f| f.type == :available_task }\n\n    tasks.each do |task|\n      cost = calculate_cost(task)\n      @engine.add_fact(:bid, {\n        agent: @name,\n        task_id: task.id,\n        cost: cost\n      })\n    end\n\n    # Winner takes task\n    my_bids = @engine.facts.select { |f|\n      f.type == :bid &amp;&amp; f[:agent] == @name\n    }\n\n    my_bids.each do |bid|\n      if winning_bid?(bid)\n        execute_task(bid[:task_id])\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"examples/multi-agent/#advanced-features","title":"Advanced Features","text":""},{"location":"examples/multi-agent/#agent-discovery","title":"Agent Discovery","text":"<pre><code>def discover_agents\n  agent_statuses = @engine.facts.select { |f| f.type == :agent_status }\n  active_agents = agent_statuses.select { |a| a[:status] == \"started\" }\n\n  active_agents.map { |a| a[:agent] }\nend\n</code></pre>"},{"location":"examples/multi-agent/#dynamic-agent-creation","title":"Dynamic Agent Creation","text":"<pre><code>def spawn_agent(agent_class, *args)\n  new_agent = agent_class.new(@engine, *args)\n  @agents &lt;&lt; new_agent\n  new_agent.start\n  new_agent\nend\n\n# Example: Spawn specialist agent\nif complex_problem_detected?\n  specialist = spawn_agent(SpecialistAgent, problem_type)\nend\n</code></pre>"},{"location":"examples/multi-agent/#agent-lifecycle-management","title":"Agent Lifecycle Management","text":"<pre><code>class AgentManager\n  def initialize(engine)\n    @engine = engine\n    @agents = {}\n  end\n\n  def register(agent)\n    @agents[agent.name] = agent\n\n    @engine.add_fact(:agent_registered, {\n      name: agent.name,\n      type: agent.class.name,\n      timestamp: Time.now\n    })\n  end\n\n  def deregister(agent_name)\n    agent = @agents.delete(agent_name)\n    agent&amp;.stop\n\n    @engine.add_fact(:agent_deregistered, {\n      name: agent_name,\n      timestamp: Time.now\n    })\n  end\n\n  def monitor_agents\n    @agents.each do |name, agent|\n      unless agent.running?\n        # Restart failed agent\n        agent.start\n        @engine.add_fact(:agent_restarted, {\n          name: name,\n          timestamp: Time.now\n        })\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"examples/multi-agent/#fault-tolerance","title":"Fault Tolerance","text":"<pre><code>class FaultTolerantAgent &lt; Agent\n  def run_cycle\n    return unless running?\n\n    begin\n      process\n    rescue =&gt; e\n      handle_error(e)\n    end\n  end\n\n  def handle_error(error)\n    @engine.add_fact(:agent_error, {\n      agent: @name,\n      error: error.message,\n      timestamp: Time.now\n    })\n\n    send_message(:system_alerts, {\n      type: \"agent_failure\",\n      agent: @name,\n      error: error.message\n    }, priority: 100)\n\n    # Attempt recovery\n    attempt_recovery\n  end\n\n  def attempt_recovery\n    # Restart agent's subsystems\n    # Or notify manager for replacement\n  end\nend\n</code></pre>"},{"location":"examples/multi-agent/#testing","title":"Testing","text":"<pre><code>require 'minitest/autorun'\n\nclass TestMultiAgentSystem &lt; Minitest::Test\n  def setup\n    @system = SmartHomeSystem.new(db_path: ':memory:')\n    @system.start\n  end\n\n  def teardown\n    @system.stop\n  end\n\n  def test_temperature_agent_creates_alert\n    @system.add_sensor_reading(\"temperature\", {\n      location: \"bedroom\",\n      value: 26.0\n    })\n\n    @system.run_cycle\n\n    alerts = @system.engine.facts.select { |f| f.type == :temperature_alert }\n\n    assert_equal 1, alerts.size\n    assert_equal \"bedroom\", alerts.first[:location]\n    assert_equal \"high\", alerts.first[:severity]\n  end\n\n  def test_security_agent_detects_intrusion\n    @system.engine.add_fact(:occupancy, { status: \"away\" })\n\n    @system.add_sensor_reading(\"motion\", {\n      location: \"living_room\",\n      detected: true\n    })\n\n    @system.run_cycle\n\n    alerts = @system.engine.facts.select { |f|\n      f.type == :security_alert &amp;&amp; f[:type] == \"intrusion\"\n    }\n\n    assert_equal 1, alerts.size\n    assert_equal \"critical\", alerts.first[:severity]\n  end\n\n  def test_energy_agent_triggers_reduction\n    @system.add_sensor_reading(\"power\", { value: 6000 })\n\n    @system.run_cycle\n\n    energy_alerts = @system.engine.facts.select { |f|\n      f.type == :energy_alert\n    }\n\n    assert_equal 1, energy_alerts.size\n\n    # Check for reduction message\n    msg = @system.engine.pop_message(:device_control)\n    assert msg\n    assert_equal \"reduce_consumption\", msg[:content][:content][:action]\n  end\n\n  def test_arbitration_security_over_energy\n    # Create conflict: security alert + energy alert\n    @system.engine.add_fact(:security_alert, {\n      type: \"intrusion\",\n      severity: \"critical\"\n    })\n\n    @system.add_sensor_reading(\"power\", { value: 6000 })\n\n    @system.run_cycle\n\n    # Arbitration should send cancellation\n    msg = @system.engine.pop_message(:device_control)\n    while msg\n      if msg[:content][:content][:action] == \"cancel_energy_reduction\"\n        assert_equal \"security_priority\", msg[:content][:content][:reason]\n        return\n      end\n      msg = @system.engine.pop_message(:device_control)\n    end\n\n    flunk \"Expected cancellation message not found\"\n  end\n\n  def test_schedule_agent_morning_routine\n    @system.trigger_time_event(\"morning\", { hour: 7 })\n\n    @system.run_cycle\n\n    # Check occupancy updated\n    occupancy = @system.engine.facts.find { |f| f.type == :occupancy }\n    assert_equal \"home\", occupancy[:status]\n\n    # Check routine executed\n    routine = @system.engine.facts.find { |f|\n      f.type == :routine_executed &amp;&amp; f[:type] == \"morning\"\n    }\n    assert routine\n  end\n\n  def test_agent_coordination_via_messages\n    temp_agent = @system.agents.find { |a| a.is_a?(TemperatureAgent) }\n\n    @system.add_sensor_reading(\"temperature\", {\n      location: \"bedroom\",\n      value: 26.0\n    })\n\n    @system.run_cycle\n\n    # Temperature agent should send HVAC message\n    msg = @system.engine.pop_message(:hvac_control)\n\n    assert msg\n    assert_equal \"TemperatureAgent\", msg[:content][:from]\n    assert_equal \"cool\", msg[:content][:content][:action]\n  end\n\n  def test_system_status\n    status = @system.status\n\n    assert status[:running]\n    assert_equal 5, status[:agents].size\n    assert status[:agents].all? { |a| a[:running] }\n  end\nend\n</code></pre>"},{"location":"examples/multi-agent/#performance-considerations","title":"Performance Considerations","text":""},{"location":"examples/multi-agent/#use-redis-for-high-throughput","title":"Use Redis for High-Throughput","text":"<pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\n\nsystem = SmartHomeSystem.new(store: store)\n# 100x faster message passing\n</code></pre>"},{"location":"examples/multi-agent/#agent-thread-pools","title":"Agent Thread Pools","text":"<pre><code>require 'concurrent'\n\nclass ThreadedSmartHomeSystem &lt; SmartHomeSystem\n  def run_continuous(interval: 1)\n    pool = Concurrent::FixedThreadPool.new(5)\n\n    while @running\n      @agents.each do |agent|\n        pool.post { agent.run_cycle }\n      end\n\n      sleep interval\n    end\n\n    pool.shutdown\n    pool.wait_for_termination\n  end\nend\n</code></pre>"},{"location":"examples/multi-agent/#next-steps","title":"Next Steps","text":"<ul> <li>Blackboard Memory - Shared workspace details</li> <li>Performance Guide - Optimize multi-agent systems</li> <li>Testing Guide - Test agent interactions</li> <li>API Reference - Blackboard API</li> </ul> <p>Multi-agent systems enable emergent intelligence through collaboration. Each agent contributes specialized expertise, and the system as a whole solves problems no single agent could solve alone.</p>"},{"location":"examples/stock-trading/","title":"Stock Trading System","text":"<p>Complete algorithmic trading system using KBS with market data collection, signal generation, risk management, and order execution.</p>"},{"location":"examples/stock-trading/#system-overview","title":"System Overview","text":"<p>This example demonstrates a production-ready trading system with:</p> <ul> <li>Market Data Agent - Fetches real-time quotes</li> <li>Signal Agent - Generates buy/sell signals using technical indicators</li> <li>Risk Agent - Validates trades against risk limits</li> <li>Execution Agent - Submits orders to broker</li> </ul>"},{"location":"examples/stock-trading/#architecture","title":"Architecture","text":"<pre><code>Market Data Agent \u2192 Blackboard \u2192 Signal Agent \u2192 Risk Agent \u2192 Execution Agent\n                       \u2193\n                 Persistent Storage (SQLite/Redis)\n                       \u2193\n                  Audit Trail\n</code></pre>"},{"location":"examples/stock-trading/#complete-implementation","title":"Complete Implementation","text":"<pre><code>require 'kbs'\nrequire 'net/http'\nrequire 'json'\n\nclass TradingSystem\n  def initialize(db_path: 'trading.db')\n    @engine = KBS::Blackboard::Engine.new(db_path: db_path)\n    setup_rules\n  end\n\n  def setup_rules\n    # Rule 1: Generate moving average crossover signals\n    signal_rule = KBS::Rule.new(\"ma_crossover_signal\", priority: 100) do |r|\n      r.conditions = [\n        KBS::Condition.new(:market_data, {\n          symbol: :sym?,\n          price: :price?,\n          ma_short: :ma_short?,\n          ma_long: :ma_long?\n        }),\n\n        # No existing signal for this symbol\n        KBS::Condition.new(:signal, { symbol: :sym? }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        short = bindings[:ma_short?]\n        long = bindings[:ma_long?]\n\n        # Golden cross: short MA crosses above long MA\n        if short &gt; long &amp;&amp; (short - long) / long &gt; 0.01  # 1% threshold\n          @engine.add_fact(:signal, {\n            symbol: bindings[:sym?],\n            type: \"buy\",\n            price: bindings[:price?],\n            confidence: calculate_confidence(short, long),\n            timestamp: Time.now\n          })\n        # Death cross: short MA crosses below long MA\n        elsif short &lt; long &amp;&amp; (long - short) / long &gt; 0.01\n          @engine.add_fact(:signal, {\n            symbol: bindings[:sym?],\n            type: \"sell\",\n            price: bindings[:price?],\n            confidence: calculate_confidence(short, long),\n            timestamp: Time.now\n          })\n        end\n      end\n    end\n\n    # Rule 2: Risk check for buy signals\n    risk_check_buy = KBS::Rule.new(\"risk_check_buy\", priority: 90) do |r|\n      r.conditions = [\n        KBS::Condition.new(:signal, {\n          symbol: :sym?,\n          type: \"buy\",\n          price: :price?\n        }),\n\n        KBS::Condition.new(:portfolio, {\n          cash: :cash?,\n          positions: :positions?\n        }),\n\n        # No risk approval yet\n        KBS::Condition.new(:risk_approved, { signal_id: :sig_id? }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        signal = facts.find { |f| f.type == :signal }\n        cash = bindings[:cash?]\n        positions = bindings[:positions?]\n        price = bindings[:price?]\n\n        # Risk checks\n        position_size = calculate_position_size(cash, price)\n        max_position_value = cash * 0.10  # Max 10% of cash per position\n\n        if position_size * price &lt;= max_position_value\n          # Check portfolio concentration\n          total_positions = positions.size\n\n          if total_positions &lt; 10  # Max 10 positions\n            @engine.add_fact(:risk_approved, {\n              signal_id: signal.id,\n              symbol: bindings[:sym?],\n              quantity: position_size,\n              approved_at: Time.now\n            })\n          else\n            @engine.add_fact(:risk_rejected, {\n              signal_id: signal.id,\n              reason: \"Portfolio concentration limit\"\n            })\n          end\n        else\n          @engine.add_fact(:risk_rejected, {\n            signal_id: signal.id,\n            reason: \"Position size exceeds limits\"\n          })\n        end\n      end\n    end\n\n    # Rule 3: Execute approved orders\n    execution_rule = KBS::Rule.new(\"execute_approved_orders\", priority: 80) do |r|\n      r.conditions = [\n        KBS::Condition.new(:risk_approved, {\n          signal_id: :sig_id?,\n          symbol: :sym?,\n          quantity: :qty?\n        }),\n\n        KBS::Condition.new(:signal, {\n          symbol: :sym?,\n          type: :type?,\n          price: :price?\n        }),\n\n        # Not yet executed\n        KBS::Condition.new(:order, { signal_id: :sig_id? }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        order_id = execute_order(\n          symbol: bindings[:sym?],\n          type: bindings[:type?],\n          quantity: bindings[:qty?],\n          price: bindings[:price?]\n        )\n\n        @engine.add_fact(:order, {\n          signal_id: bindings[:sig_id?],\n          order_id: order_id,\n          symbol: bindings[:sym?],\n          type: bindings[:type?],\n          quantity: bindings[:qty?],\n          price: bindings[:price?],\n          status: \"submitted\",\n          timestamp: Time.now\n        })\n\n        # Clean up signal and approval\n        signal = facts.find { |f| f.type == :signal }\n        approval = facts.find { |f| f.type == :risk_approved }\n        @engine.remove_fact(signal)\n        @engine.remove_fact(approval)\n      end\n    end\n\n    # Rule 4: Stop loss monitoring\n    stop_loss_rule = KBS::Rule.new(\"stop_loss_trigger\", priority: 95) do |r|\n      r.conditions = [\n        KBS::Condition.new(:position, {\n          symbol: :sym?,\n          entry_price: :entry?,\n          quantity: :qty?\n        }),\n\n        KBS::Condition.new(:market_data, {\n          symbol: :sym?,\n          price: :current_price?\n        }),\n\n        KBS::Condition.new(:stop_loss_triggered, { symbol: :sym? }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        entry = bindings[:entry?]\n        current = bindings[:current_price?]\n        loss_pct = (entry - current) / entry\n\n        # 5% stop loss\n        if loss_pct &gt; 0.05\n          @engine.add_fact(:signal, {\n            symbol: bindings[:sym?],\n            type: \"sell\",\n            price: current,\n            confidence: 1.0,\n            reason: \"stop_loss\",\n            timestamp: Time.now\n          })\n\n          @engine.add_fact(:stop_loss_triggered, {\n            symbol: bindings[:sym?],\n            entry_price: entry,\n            exit_price: current,\n            loss_pct: loss_pct\n          })\n        end\n      end\n    end\n\n    # Rule 5: Take profit monitoring\n    take_profit_rule = KBS::Rule.new(\"take_profit_trigger\", priority: 95) do |r|\n      r.conditions = [\n        KBS::Condition.new(:position, {\n          symbol: :sym?,\n          entry_price: :entry?,\n          quantity: :qty?\n        }),\n\n        KBS::Condition.new(:market_data, {\n          symbol: :sym?,\n          price: :current_price?\n        }),\n\n        KBS::Condition.new(:take_profit_triggered, { symbol: :sym? }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        entry = bindings[:entry?]\n        current = bindings[:current_price?]\n        gain_pct = (current - entry) / entry\n\n        # 15% take profit\n        if gain_pct &gt; 0.15\n          @engine.add_fact(:signal, {\n            symbol: bindings[:sym?],\n            type: \"sell\",\n            price: current,\n            confidence: 1.0,\n            reason: \"take_profit\",\n            timestamp: Time.now\n          })\n\n          @engine.add_fact(:take_profit_triggered, {\n            symbol: bindings[:sym?],\n            entry_price: entry,\n            exit_price: current,\n            gain_pct: gain_pct\n          })\n        end\n      end\n    end\n\n    @engine.add_rule(signal_rule)\n    @engine.add_rule(risk_check_buy)\n    @engine.add_rule(execution_rule)\n    @engine.add_rule(stop_loss_rule)\n    @engine.add_rule(take_profit_rule)\n  end\n\n  def update_market_data(symbol, price)\n    # Calculate moving averages\n    history = get_price_history(symbol, days: 50)\n    ma_short = calculate_ma(history, period: 10)\n    ma_long = calculate_ma(history, period: 50)\n\n    # Remove old market data\n    old = @engine.facts.find { |f| f.type == :market_data &amp;&amp; f[:symbol] == symbol }\n    @engine.remove_fact(old) if old\n\n    # Add new market data\n    @engine.add_fact(:market_data, {\n      symbol: symbol,\n      price: price,\n      ma_short: ma_short,\n      ma_long: ma_long,\n      timestamp: Time.now\n    })\n  end\n\n  def update_portfolio(cash:, positions:)\n    old = @engine.facts.find { |f| f.type == :portfolio }\n    @engine.remove_fact(old) if old\n\n    @engine.add_fact(:portfolio, {\n      cash: cash,\n      positions: positions,\n      updated_at: Time.now\n    })\n  end\n\n  def run_cycle\n    @engine.run\n  end\n\n  private\n\n  def calculate_confidence(short_ma, long_ma)\n    # Confidence based on divergence\n    divergence = ((short_ma - long_ma).abs / long_ma)\n    [divergence * 10, 1.0].min\n  end\n\n  def calculate_position_size(cash, price)\n    # Kelly criterion or fixed percentage\n    (cash * 0.05 / price).floor  # 5% of cash\n  end\n\n  def execute_order(symbol:, type:, quantity:, price:)\n    # Submit to broker API\n    # Returns order_id\n    \"ORD-#{Time.now.to_i}-#{symbol}\"\n  end\n\n  def get_price_history(symbol, days:)\n    # Fetch historical prices\n    # Returns array of prices\n    []\n  end\n\n  def calculate_ma(prices, period:)\n    return 0 if prices.size &lt; period\n    prices.last(period).sum / period.to_f\n  end\nend\n\n# Usage\ntrading = TradingSystem.new\n\n# Initialize portfolio\ntrading.update_portfolio(\n  cash: 100000,\n  positions: []\n)\n\n# Market data loop\nsymbols = [\"AAPL\", \"GOOGL\", \"MSFT\", \"TSLA\"]\n\nloop do\n  symbols.each do |symbol|\n    # Fetch current price (from API)\n    price = fetch_price(symbol)\n\n    # Update market data\n    trading.update_market_data(symbol, price)\n  end\n\n  # Run inference engine\n  trading.run_cycle\n\n  sleep 60  # Run every minute\nend\n</code></pre>"},{"location":"examples/stock-trading/#key-features","title":"Key Features","text":""},{"location":"examples/stock-trading/#1-moving-average-crossover","title":"1. Moving Average Crossover","text":"<p>Generates buy signals when short MA crosses above long MA (golden cross) and sell signals when it crosses below (death cross).</p>"},{"location":"examples/stock-trading/#2-risk-management","title":"2. Risk Management","text":"<ul> <li>Position sizing: Max 10% of cash per position</li> <li>Portfolio concentration: Max 10 positions</li> <li>Stop loss: Automatic exit at 5% loss</li> <li>Take profit: Automatic exit at 15% gain</li> </ul>"},{"location":"examples/stock-trading/#3-order-execution","title":"3. Order Execution","text":"<p>Approved signals become orders submitted to broker.</p>"},{"location":"examples/stock-trading/#4-audit-trail","title":"4. Audit Trail","text":"<p>All decisions logged to database:</p> <pre><code># Query signal history\nsignals = trading.engine.facts.select { |f| f.type == :signal }\n\n# Query order history\norders = trading.engine.facts.select { |f| f.type == :order }\n\n# Audit trail\ntrading.engine.fact_history(signal.id)\n</code></pre>"},{"location":"examples/stock-trading/#performance-optimization","title":"Performance Optimization","text":""},{"location":"examples/stock-trading/#use-redis-for-real-time-trading","title":"Use Redis for Real-Time Trading","text":"<pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\n\ntrading = TradingSystem.new(store: store)\n# 100x faster updates\n</code></pre>"},{"location":"examples/stock-trading/#hybrid-store-for-compliance","title":"Hybrid Store for Compliance","text":"<pre><code>require 'kbs/blackboard/persistence/hybrid_store'\n\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\n\ntrading = TradingSystem.new(store: store)\n# Fast + complete audit trail\n</code></pre>"},{"location":"examples/stock-trading/#testing","title":"Testing","text":"<pre><code>require 'minitest/autorun'\n\nclass TestTradingSystem &lt; Minitest::Test\n  def setup\n    @system = TradingSystem.new(db_path: ':memory:')\n  end\n\n  def test_golden_cross_generates_buy_signal\n    @system.update_portfolio(cash: 10000, positions: [])\n\n    # Short MA above long MA\n    @system.update_market_data(\"AAPL\", 150)\n    @system.engine.add_fact(:market_data, {\n      symbol: \"AAPL\",\n      price: 150,\n      ma_short: 155,  # Higher\n      ma_long: 145,   # Lower\n      timestamp: Time.now\n    })\n\n    @system.run_cycle\n\n    signals = @system.engine.facts.select { |f| f.type == :signal }\n    assert_equal 1, signals.size\n    assert_equal \"buy\", signals.first[:type]\n  end\n\n  def test_stop_loss_triggers_sell\n    @system.update_portfolio(cash: 10000, positions: [])\n\n    # Add position\n    @system.engine.add_fact(:position, {\n      symbol: \"AAPL\",\n      entry_price: 100,\n      quantity: 10\n    })\n\n    # Price drops 6%\n    @system.update_market_data(\"AAPL\", 94)\n\n    @system.run_cycle\n\n    signals = @system.engine.facts.select { |f|\n      f.type == :signal &amp;&amp; f[:reason] == \"stop_loss\"\n    }\n\n    assert_equal 1, signals.size\n  end\nend\n</code></pre>"},{"location":"examples/stock-trading/#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Agent Example - Distributed trading with multiple strategies</li> <li>Performance Guide - Optimize for high-frequency trading</li> <li>Blackboard Memory - Persistent state management</li> </ul> <p>This trading system demonstrates production-ready algorithmic trading with KBS. Always backtest thoroughly before live trading.</p>"},{"location":"guides/","title":"Guides","text":"<p>Practical guides for using KBS effectively.</p>"},{"location":"guides/#getting-started","title":"Getting Started","text":"<ul> <li>Getting Started - Your first rule-based system</li> <li>Writing Rules - Rule authoring best practices</li> <li>DSL Reference - Complete syntax guide</li> </ul>"},{"location":"guides/#core-concepts","title":"Core Concepts","text":"<ul> <li>Facts - Working with facts and queries</li> <li>Pattern Matching - Pattern syntax and operators</li> <li>Variable Binding - Using variables in rules</li> <li>Negation - Matching absent patterns</li> </ul>"},{"location":"guides/#persistence","title":"Persistence","text":"<ul> <li>Blackboard Memory - Persistent shared memory</li> <li>Persistence Options - SQLite, Redis, and Hybrid backends</li> </ul>"},{"location":"guides/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - See KBS in action</li> <li>Advanced Topics - Production optimization</li> <li>API Reference - Complete class documentation</li> </ul>"},{"location":"guides/blackboard-memory/","title":"Blackboard Memory","text":"<p>The blackboard pattern enables multiple agents to collaborate through a shared persistent workspace. This guide covers using KBS's blackboard memory for multi-agent systems, audit trails, and persistent knowledge bases.</p>"},{"location":"guides/blackboard-memory/#what-is-blackboard-memory","title":"What is Blackboard Memory?","text":"<p>The blackboard architecture consists of three components:</p> <ol> <li>Blackboard (<code>KBS::Blackboard::Memory</code>) - Central shared workspace</li> <li>Knowledge Sources (Agents) - Independent specialists that read/write facts</li> <li>Control (Rules + Priority) - Determines which agent acts when</li> </ol> <p></p> <p>KBS uses the blackboard pattern for persistent, multi-agent reasoning with complete audit trails.</p>"},{"location":"guides/blackboard-memory/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/blackboard-memory/#creating-a-blackboard-engine","title":"Creating a Blackboard Engine","text":"<pre><code>require 'kbs'\n\n# With SQLite (default)\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# Facts persist across restarts\nengine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\nengine.close\n\n# Next run\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nputs engine.facts.size  # =&gt; 1\n</code></pre>"},{"location":"guides/blackboard-memory/#blackboard-vs-regular-engine","title":"Blackboard vs Regular Engine","text":"<pre><code># Regular engine (transient)\nregular = KBS::Engine.new\nregular.add_fact(:foo, { bar: 1 })\n# Lost on exit\n\n# Blackboard engine (persistent)\nblackboard = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nblackboard.add_fact(:foo, { bar: 1 })\nblackboard.close\n# Persisted to database\n</code></pre>"},{"location":"guides/blackboard-memory/#persistent-facts","title":"Persistent Facts","text":""},{"location":"guides/blackboard-memory/#fact-lifecycle","title":"Fact Lifecycle","text":"<pre><code># Create fact\nfact = engine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\n\n# Fact has UUID\nputs fact.id  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Update fact\nengine.update_fact(fact.id, { temp: 30 })\n\n# Query fact history\nhistory = engine.fact_history(fact.id)\nhistory.each do |entry|\n  puts \"#{entry[:timestamp]}: #{entry[:operation]} - #{entry[:attributes]}\"\nend\n\n# Delete fact\nengine.delete_fact(fact.id)\n</code></pre>"},{"location":"guides/blackboard-memory/#fact-attributes","title":"Fact Attributes","text":"<p>Blackboard facts support the same interface as regular facts:</p> <pre><code>fact = engine.add_fact(:stock, { symbol: \"AAPL\", price: 150 })\n\n# Access\nfact.type           # =&gt; :stock\nfact[:symbol]       # =&gt; \"AAPL\"\nfact.attributes     # =&gt; { symbol: \"AAPL\", price: 150 }\nfact.id             # =&gt; UUID string\n\n# Metadata\nfact.created_at     # =&gt; Time object\nfact.updated_at     # =&gt; Time object\n</code></pre>"},{"location":"guides/blackboard-memory/#message-queue","title":"Message Queue","text":"<p>The blackboard includes a priority-based message queue for agent communication:</p>"},{"location":"guides/blackboard-memory/#sending-messages","title":"Sending Messages","text":"<pre><code># Add message to queue\nengine.send_message(:alerts, \"High temperature detected\", priority: 10)\nengine.send_message(:alerts, \"Critical failure\", priority: 100)  # Higher priority\n</code></pre>"},{"location":"guides/blackboard-memory/#receiving-messages","title":"Receiving Messages","text":"<pre><code># Pop highest priority message\nmsg = engine.pop_message(:alerts)\nputs msg[:content]   # =&gt; \"Critical failure\"\nputs msg[:priority]  # =&gt; 100\n\n# Process all messages\nwhile (msg = engine.pop_message(:alerts))\n  process_alert(msg[:content])\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#message-topics","title":"Message Topics","text":"<p>Organize messages by topic:</p> <pre><code># Different topics for different concerns\nengine.send_message(:sensor_alerts, \"Temp spike\", priority: 50)\nengine.send_message(:system_events, \"Startup complete\", priority: 10)\nengine.send_message(:user_notifications, \"Welcome!\", priority: 1)\n\n# Agents process their own topics\nsensor_agent_msg = engine.pop_message(:sensor_alerts)\nsystem_msg = engine.pop_message(:system_events)\nuser_msg = engine.pop_message(:user_notifications)\n</code></pre>"},{"location":"guides/blackboard-memory/#audit-trail","title":"Audit Trail","text":"<p>Blackboard automatically logs all changes:</p>"},{"location":"guides/blackboard-memory/#fact-audit-log","title":"Fact Audit Log","text":"<pre><code># Add fact\nfact = engine.add_fact(:order, { id: 1, status: \"pending\" })\n\n# Update fact\nengine.update_fact(fact.id, { status: \"processing\" })\n\n# Delete fact\nengine.delete_fact(fact.id)\n\n# Query audit trail\nhistory = engine.fact_history(fact.id)\nhistory.each do |entry|\n  puts \"#{entry[:timestamp]}: #{entry[:operation]}\"\n  puts \"  Attributes: #{entry[:attributes]}\"\nend\n\n# Output:\n# 2025-01-15 10:00:00: add\n#   Attributes: {id: 1, status: \"pending\"}\n# 2025-01-15 10:01:00: update\n#   Attributes: {id: 1, status: \"processing\"}\n# 2025-01-15 10:02:00: delete\n#   Attributes: {id: 1, status: \"processing\"}\n</code></pre>"},{"location":"guides/blackboard-memory/#rule-firing-log","title":"Rule Firing Log","text":"<pre><code># Enable rule firing audit\nengine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',\n  audit_rules: true\n)\n\n# Add and run rules\nengine.add_rule(my_rule)\nengine.run\n\n# Query rule firings\nfirings = engine.rule_firings(rule_name: \"my_rule\")\nfirings.each do |firing|\n  puts \"Rule '#{firing[:rule_name]}' fired at #{firing[:timestamp]}\"\n  puts \"  Facts: #{firing[:fact_ids]}\"\n  puts \"  Bindings: #{firing[:bindings]}\"\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#multi-agent-systems","title":"Multi-Agent Systems","text":""},{"location":"guides/blackboard-memory/#agent-pattern","title":"Agent Pattern","text":"<pre><code>class Agent\n  def initialize(name, engine)\n    @name = name\n    @engine = engine\n  end\n\n  def observe\n    # Read facts from blackboard\n    @engine.facts.select { |f| relevant?(f) }\n  end\n\n  def decide\n    # Apply agent's expertise\n    # Return action or nil\n  end\n\n  def act\n    # Write facts to blackboard\n    # Send messages to other agents\n  end\n\n  def run\n    observations = observe\n    action = decide(observations)\n    act(action) if action\n  end\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#example-trading-system","title":"Example: Trading System","text":"<pre><code>class MarketDataAgent &lt; Agent\n  def run\n    # Fetch market data\n    data = fetch_market_data()\n\n    # Post to blackboard\n    @engine.add_fact(:market_data, {\n      symbol: data[:symbol],\n      price: data[:price],\n      volume: data[:volume],\n      timestamp: Time.now\n    })\n  end\nend\n\nclass TradingAgent &lt; Agent\n  def run\n    # Observe market data\n    market_facts = @engine.facts.select { |f| f.type == :market_data }\n\n    market_facts.each do |fact|\n      # Apply trading strategy\n      if buy_signal?(fact)\n        @engine.add_fact(:order, {\n          symbol: fact[:symbol],\n          type: \"buy\",\n          quantity: calculate_quantity(fact),\n          price: fact[:price]\n        })\n\n        @engine.send_message(:execution, \"New buy order\", priority: 50)\n      end\n    end\n  end\n\n  def buy_signal?(fact)\n    # Agent's expertise\n    fact[:price] &lt; moving_average(fact[:symbol]) * 0.95\n  end\nend\n\nclass ExecutionAgent &lt; Agent\n  def run\n    # Check for execution messages\n    while (msg = @engine.pop_message(:execution))\n      # Find pending orders\n      orders = @engine.facts.select { |f|\n        f.type == :order &amp;&amp; !f[:executed]\n      }\n\n      orders.each do |order|\n        execute_order(order)\n\n        # Update fact\n        @engine.update_fact(order.id, { executed: true })\n\n        # Notify\n        @engine.send_message(:notifications, \"Order executed\", priority: 10)\n      end\n    end\n  end\nend\n\n# Run agents in loop\nengine = KBS::Blackboard::Engine.new(db_path: 'trading.db')\n\nmarket_agent = MarketDataAgent.new(\"Market\", engine)\ntrading_agent = TradingAgent.new(\"Trading\", engine)\nexecution_agent = ExecutionAgent.new(\"Execution\", engine)\n\nloop do\n  market_agent.run      # Fetch data \u2192 blackboard\n  trading_agent.run     # Analyze \u2192 create orders\n  execution_agent.run   # Execute orders\n  sleep 1\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#transactions","title":"Transactions","text":"<p>Blackboard supports ACID transactions (SQLite backend):</p> <pre><code># Transaction succeeds\nengine.transaction do\n  engine.add_fact(:account, { id: 1, balance: 1000 })\n  engine.add_fact(:account, { id: 2, balance: 500 })\nend\n# Both facts committed\n\n# Transaction fails\nbegin\n  engine.transaction do\n    engine.add_fact(:account, { id: 3, balance: 100 })\n    raise \"Error!\"\n    engine.add_fact(:account, { id: 4, balance: 200 })  # Never reached\n  end\nrescue =&gt; e\n  puts \"Transaction rolled back\"\nend\n# No facts committed\n</code></pre>"},{"location":"guides/blackboard-memory/#observers","title":"Observers","text":"<p>Monitor blackboard changes in real-time:</p> <pre><code>class FactObserver\n  def update(operation, fact)\n    case operation\n    when :add\n      puts \"Fact added: #{fact.type} - #{fact.attributes}\"\n    when :remove\n      puts \"Fact removed: #{fact.type} - #{fact.attributes}\"\n    when :update\n      puts \"Fact updated: #{fact.type} - #{fact.attributes}\"\n    end\n  end\nend\n\nobserver = FactObserver.new\nengine.memory.add_observer(observer)\n\nengine.add_fact(:sensor, { temp: 28 })\n# Output: Fact added: sensor - {:temp=&gt;28}\n</code></pre>"},{"location":"guides/blackboard-memory/#performance-tuning","title":"Performance Tuning","text":""},{"location":"guides/blackboard-memory/#sqlite-optimization","title":"SQLite Optimization","text":"<pre><code>engine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',\n  journal_mode: 'WAL',       # Write-Ahead Logging\n  synchronous: 'NORMAL',     # Balance durability/speed\n  cache_size: -64000,        # 64MB cache\n  busy_timeout: 5000         # Wait 5s for locks\n)\n</code></pre>"},{"location":"guides/blackboard-memory/#redis-for-speed","title":"Redis for Speed","text":"<pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n\n# 10-100x faster than SQLite\n# Perfect for high-frequency updates\n</code></pre>"},{"location":"guides/blackboard-memory/#hybrid-for-production","title":"Hybrid for Production","text":"<pre><code>require 'kbs/blackboard/persistence/hybrid_store'\n\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n\n# Fast access (Redis) + durable audit (SQLite)\n</code></pre>"},{"location":"guides/blackboard-memory/#best-practices","title":"Best Practices","text":""},{"location":"guides/blackboard-memory/#1-use-uuids-for-fact-references","title":"1. Use UUIDs for Fact References","text":"<pre><code># Good: Store fact UUID\norder_id = engine.add_fact(:order, { ... }).id\nengine.add_fact(:payment, { order_id: order_id })\n\n# Bad: Use attribute as reference\nengine.add_fact(:order, { id: 1 })\nengine.add_fact(:payment, { order_id: 1 })  # Fragile\n</code></pre>"},{"location":"guides/blackboard-memory/#2-namespace-facts-by-agent","title":"2. Namespace Facts by Agent","text":"<pre><code># Good: Clear ownership\nengine.add_fact(:market_agent_data, { ... })\nengine.add_fact(:trading_agent_signal, { ... })\n\n# Bad: Generic names\nengine.add_fact(:data, { ... })\nengine.add_fact(:signal, { ... })\n</code></pre>"},{"location":"guides/blackboard-memory/#3-use-messages-for-coordination","title":"3. Use Messages for Coordination","text":"<pre><code># Good: Explicit coordination\nengine.send_message(:execution_queue, \"Process order #123\", priority: 50)\n\n# Bad: Polling facts\nloop do\n  orders = engine.facts.select { |f| f.type == :pending_order }\n  # Inefficient\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#4-clean-up-old-facts","title":"4. Clean Up Old Facts","text":"<pre><code># Remove stale data\nKBS::Rule.new(\"cleanup_old_facts\", priority: 1) do |r|\n  r.conditions = [\n    KBS::Condition.new(:market_data, {\n      timestamp: :time?\n    }, predicate: lambda { |f|\n      (Time.now - f[:timestamp]) &gt; 3600  # 1 hour old\n    })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.remove_fact(facts[0])\n  end\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#5-use-transactions-for-multi-fact-updates","title":"5. Use Transactions for Multi-Fact Updates","text":"<pre><code># Good: Atomic updates\nengine.transaction do\n  engine.update_fact(account1_id, { balance: new_balance1 })\n  engine.update_fact(account2_id, { balance: new_balance2 })\nend\n\n# Bad: Separate updates (not atomic)\nengine.update_fact(account1_id, { balance: new_balance1 })\nengine.update_fact(account2_id, { balance: new_balance2 })\n</code></pre>"},{"location":"guides/blackboard-memory/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/blackboard-memory/#leader-election","title":"Leader Election","text":"<pre><code># Agent attempts to become leader\nKBS::Rule.new(\"become_leader\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:agent, { name: :name? }),\n    KBS::Condition.new(:leader, {}, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.add_fact(:leader, { name: bindings[:name?] })\n    puts \"#{bindings[:name?]} is now leader\"\n  end\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#distributed-locking","title":"Distributed Locking","text":"<pre><code># Acquire lock\ndef acquire_lock(resource_id)\n  engine.transaction do\n    lock = engine.facts.find { |f|\n      f.type == :lock &amp;&amp; f[:resource_id] == resource_id\n    }\n\n    if lock.nil?\n      engine.add_fact(:lock, {\n        resource_id: resource_id,\n        owner: @agent_id,\n        acquired_at: Time.now\n      })\n      true\n    else\n      false\n    end\n  end\nend\n\n# Release lock\ndef release_lock(resource_id)\n  lock = engine.facts.find { |f|\n    f.type == :lock &amp;&amp;\n    f[:resource_id] == resource_id &amp;&amp;\n    f[:owner] == @agent_id\n  }\n\n  engine.remove_fact(lock) if lock\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#event-sourcing","title":"Event Sourcing","text":"<pre><code># Store events as facts\nengine.add_fact(:event, {\n  type: \"order_created\",\n  aggregate_id: \"order-123\",\n  data: { item: \"Widget\", quantity: 5 },\n  timestamp: Time.now\n})\n\n# Reconstruct state from events\ndef rebuild_order(order_id)\n  events = engine.facts\n    .select { |f| f.type == :event &amp;&amp; f[:aggregate_id] == order_id }\n    .sort_by { |f| f[:timestamp] }\n\n  state = {}\n  events.each do |event|\n    apply_event(state, event)\n  end\n  state\nend\n</code></pre>"},{"location":"guides/blackboard-memory/#next-steps","title":"Next Steps","text":"<ul> <li>Persistence - Storage backend options</li> <li>Architecture - Blackboard implementation details</li> <li>Multi-Agent Example - Complete multi-agent system</li> <li>API Reference - Complete blackboard API</li> </ul> <p>The blackboard pattern enables emergent intelligence through agent collaboration. Each agent contributes expertise to solve problems no single agent could solve alone.</p>"},{"location":"guides/dsl/","title":"DSL Reference Guide","text":"<p>Complete reference for the KBS Domain-Specific Language for defining knowledge bases and rules.</p>"},{"location":"guides/dsl/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Knowledge Base</li> <li>Rule Definition</li> <li>Condition Syntax</li> <li>Pattern Helpers</li> <li>Variable Binding</li> <li>Negation</li> <li>Actions</li> <li>Working with Facts</li> <li>Introspection</li> </ul>"},{"location":"guides/dsl/#quick-start","title":"Quick Start","text":"<p>The KBS DSL provides a natural, English-like syntax for defining knowledge-based systems:</p> <pre><code>require 'kbs'\n\nkb = KBS.knowledge_base do\n  # Define a rule\n  rule \"high_temperature_alert\" do\n    desc \"Alert when temperature exceeds threshold\"\n    priority 10\n\n    on :temperature, value: greater_than(80), location: :loc?\n\n    perform do |bindings|\n      puts \"High temperature at #{bindings[:loc?]}\"\n    end\n  end\n\n  # Add facts\n  fact :temperature, value: 85, location: \"server_room\"\n\n  # Execute rules\n  run\nend\n</code></pre>"},{"location":"guides/dsl/#knowledge-base","title":"Knowledge Base","text":""},{"location":"guides/dsl/#creating-a-knowledge-base","title":"Creating a Knowledge Base","text":""},{"location":"guides/dsl/#kbsknowledge_baseblock","title":"<code>KBS.knowledge_base(&amp;block)</code>","text":"<p>Creates a new knowledge base and evaluates the block in its context.</p> <p>Returns: <code>KBS::DSL::KnowledgeBase</code> instance</p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  # Define rules and add facts here\nend\n\n# Access the underlying engine\nkb.engine  # =&gt; KBS::Engine\n\n# Access defined rules\nkb.rules   # =&gt; Hash of rule_name =&gt; KBS::Rule\n</code></pre></p>"},{"location":"guides/dsl/#knowledge-base-methods","title":"Knowledge Base Methods","text":""},{"location":"guides/dsl/#rulename-block-defrulename-block","title":"<code>rule(name, &amp;block)</code> / <code>defrule(name, &amp;block)</code>","text":"<p>Defines a new rule.</p> <p>Parameters: - <code>name</code> (String or Symbol) - Rule name - <code>&amp;block</code> - Block containing rule definition</p> <p>Returns: <code>KBS::DSL::RuleBuilder</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  rule \"example_rule\" do\n    # Rule definition here\n  end\n\n  # Alias\n  defrule \"another_rule\" do\n    # Rule definition here\n  end\nend\n</code></pre></p>"},{"location":"guides/dsl/#facttype-attributes-asserttype-attributes","title":"<code>fact(type, attributes = {})</code> / <code>assert(type, attributes = {})</code>","text":"<p>Adds a fact to working memory.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type - <code>attributes</code> (Hash) - Fact attributes</p> <p>Returns: <code>KBS::Fact</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85, location: \"server_room\"\n\n  # Alias\n  assert :sensor, id: 1, status: \"active\"\nend\n</code></pre></p>"},{"location":"guides/dsl/#retractfact","title":"<code>retract(fact)</code>","text":"<p>Removes a fact from working memory.</p> <p>Parameters: - <code>fact</code> (KBS::Fact) - Fact to remove</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  temp_fact = fact :temperature, value: 85\n\n  # Later...\n  retract temp_fact\nend\n</code></pre></p>"},{"location":"guides/dsl/#run","title":"<code>run()</code>","text":"<p>Executes all activated rules.</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  rule \"my_rule\" do\n    on :temperature, value: greater_than(80)\n    perform { puts \"High temperature!\" }\n  end\n\n  fact :temperature, value: 85\n\n  run  # Fires \"my_rule\"\nend\n</code></pre></p>"},{"location":"guides/dsl/#reset","title":"<code>reset()</code>","text":"<p>Clears all facts from working memory.</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85\n  fact :humidity, value: 60\n\n  reset  # All facts removed\n\n  puts facts.size  # =&gt; 0\nend\n</code></pre></p>"},{"location":"guides/dsl/#facts","title":"<code>facts()</code>","text":"<p>Returns all facts in working memory.</p> <p>Returns: <code>Array&lt;KBS::Fact&gt;</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85\n  fact :humidity, value: 60\n\n  puts facts.size  # =&gt; 2\n\n  facts.each do |f|\n    puts \"#{f.type}: #{f.attributes}\"\n  end\nend\n</code></pre></p>"},{"location":"guides/dsl/#querytype-pattern","title":"<code>query(type, pattern = {})</code>","text":"<p>Queries facts by type and attributes.</p> <p>Parameters: - <code>type</code> (Symbol) - Fact type to match - <code>pattern</code> (Hash) - Attribute key-value pairs to match</p> <p>Returns: <code>Array&lt;KBS::Fact&gt;</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85, location: \"server_room\"\n  fact :temperature, value: 75, location: \"lobby\"\n  fact :humidity, value: 60, location: \"server_room\"\n\n  # Find all temperature facts\n  temps = query(:temperature)\n  puts temps.size  # =&gt; 2\n\n  # Find temperature facts in server_room\n  server_temps = query(:temperature, location: \"server_room\")\n  puts server_temps.size  # =&gt; 1\n  puts server_temps.first[:value]  # =&gt; 85\nend\n</code></pre></p>"},{"location":"guides/dsl/#print_facts","title":"<code>print_facts()</code>","text":"<p>Displays all facts in working memory.</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85\n  fact :humidity, value: 60\n\n  print_facts\nend\n\n# Output:\n# Working Memory Contents:\n# ----------------------------------------\n# 1. temperature(value: 85)\n# 2. humidity(value: 60)\n# ----------------------------------------\n</code></pre></p>"},{"location":"guides/dsl/#print_rules","title":"<code>print_rules()</code>","text":"<p>Displays all defined rules with their conditions.</p> <p>Returns: <code>nil</code></p> <p>Example: <pre><code>kb = KBS.knowledge_base do\n  rule \"high_temp\" do\n    desc \"Alert on high temperature\"\n    priority 10\n    on :temperature, value: greater_than(80)\n    perform { puts \"High temp!\" }\n  end\n\n  print_rules\nend\n\n# Output:\n# Knowledge Base Rules:\n# ----------------------------------------\n# Rule: high_temp\n#   Description: Alert on high temperature\n#   Priority: 10\n#   Conditions: 1\n#     1. temperature({:value=&gt;#&lt;Proc:...&gt;})\n# ----------------------------------------\n</code></pre></p>"},{"location":"guides/dsl/#rule-definition","title":"Rule Definition","text":"<p>Rules are defined using the <code>rule</code> method with a block containing:</p> <ol> <li>Metadata: Description and priority</li> <li>Conditions: Patterns to match facts</li> <li>Action: Code to execute when all conditions match</li> </ol>"},{"location":"guides/dsl/#rule-structure","title":"Rule Structure","text":"<pre><code>rule \"rule_name\" do\n  desc \"Optional description\"\n  priority 10  # Optional, default: 0\n\n  # Conditions (one or more)\n  on :fact_type, attribute: value, other: :variable?\n  on :another_type, field: predicate\n\n  # Action\n  perform do |bindings|\n    # Code to execute\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#rule-metadata","title":"Rule Metadata","text":""},{"location":"guides/dsl/#descdescription","title":"<code>desc(description)</code>","text":"<p>Sets the rule description (for documentation and debugging).</p> <p>Parameters: - <code>description</code> (String) - Human-readable description</p> <p>Returns: <code>self</code> (chainable)</p> <p>Example: <pre><code>rule \"temperature_alert\" do\n  desc \"Alerts when server room temperature exceeds safe threshold\"\n\n  on :temperature, location: \"server_room\", value: greater_than(80)\n  perform { puts \"High temperature alert!\" }\nend\n</code></pre></p>"},{"location":"guides/dsl/#prioritylevel","title":"<code>priority(level)</code>","text":"<p>Sets the rule priority (higher priority rules fire first).</p> <p>Parameters: - <code>level</code> (Integer) - Priority level (default: 0)</p> <p>Returns: <code>self</code> (chainable)</p> <p>Note: Priority only affects execution order in <code>KBS::Blackboard::Engine</code>, not <code>KBS::Engine</code>.</p> <p>Example: <pre><code>rule \"critical_shutdown\" do\n  priority 1000  # Highest priority\n  on :temperature, value: greater_than(120)\n  perform { shutdown_system! }\nend\n\nrule \"log_reading\" do\n  priority 1  # Low priority\n  on :temperature, value: :temp?\n  perform { |b| log(b[:temp?]) }\nend\n</code></pre></p>"},{"location":"guides/dsl/#condition-syntax","title":"Condition Syntax","text":"<p>Conditions specify patterns that must match facts in working memory.</p>"},{"location":"guides/dsl/#condition-keywords","title":"Condition Keywords","text":"<p>All of these are aliases - use whichever reads best for your domain:</p> <ul> <li><code>on(type, pattern = {}, &amp;block)</code> - Primary keyword</li> <li><code>given(type, pattern = {})</code> - Alias for <code>on</code></li> <li><code>matches(type, pattern = {})</code> - Alias for <code>on</code></li> <li><code>fact(type, pattern = {})</code> - Alias for <code>on</code></li> <li><code>exists(type, pattern = {})</code> - Alias for <code>on</code></li> </ul> <p>Parameters: - <code>type</code> (Symbol) - Fact type to match - <code>pattern</code> (Hash) - Attribute constraints (key-value pairs) - <code>&amp;block</code> (optional) - Block-style pattern definition</p> <p>Returns: <code>self</code> (chainable)</p>"},{"location":"guides/dsl/#basic-condition-examples","title":"Basic Condition Examples","text":"<pre><code># Match any temperature fact\non :temperature\n\n# Match temperature with specific value\non :temperature, value: 85\n\n# Match temperature with multiple attributes\non :temperature, value: 85, location: \"server_room\"\n\n# Using aliases\ngiven :sensor, status: \"active\"\nmatches :order, status: \"pending\"\nfact :inventory, quantity: 0\nexists :alert, level: \"critical\"\n</code></pre>"},{"location":"guides/dsl/#literal-matching","title":"Literal Matching","text":"<p>Match exact attribute values:</p> <pre><code>on :temperature, location: \"server_room\"  # location must equal \"server_room\"\non :order, status: \"pending\", total: 100  # Both must match exactly\n</code></pre>"},{"location":"guides/dsl/#variable-binding","title":"Variable Binding","text":"<p>Capture attribute values in variables (symbols starting with <code>?</code>):</p> <pre><code>on :temperature, value: :temp?, location: :loc?\n\n# In action:\nperform do |bindings|\n  puts \"Temperature: #{bindings[:temp?]}\"\n  puts \"Location: #{bindings[:loc?]}\"\nend\n</code></pre> <p>Join Test: Same variable in multiple conditions creates a join:</p> <pre><code>on :order, product_id: :pid?, quantity: :qty?\non :inventory, product_id: :pid?, available: :avail?\n\n# These conditions only match when product_id is the same in both facts\n</code></pre>"},{"location":"guides/dsl/#predicate-matching","title":"Predicate Matching","text":"<p>Use lambdas or helper methods for complex conditions:</p> <pre><code># Lambda predicate\non :temperature, value: -&gt;(v) { v &gt; 80 &amp;&amp; v &lt; 100 }\n\n# Helper method (see Pattern Helpers section)\non :temperature, value: greater_than(80)\non :order, total: between(100, 1000)\non :status, code: one_of(\"pending\", \"processing\", \"completed\")\n</code></pre>"},{"location":"guides/dsl/#block-style-patterns","title":"Block-Style Patterns","text":"<p>Define patterns using a block with method-missing magic:</p> <pre><code>on :temperature do\n  value &gt; 80        # Creates lambda: -&gt;(v) { v &gt; 80 }\n  location :loc?    # Binds variable\n  sensor_id 42      # Literal match\nend\n\n# Equivalent to:\non :temperature,\n   value: -&gt;(v) { v &gt; 80 },\n   location: :loc?,\n   sensor_id: 42\n</code></pre> <p>Available operators in blocks: - <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> - Comparison operators - <code>==</code> - Equality (same as literal value) - <code>!=</code> - Inequality - <code>between(min, max)</code> - Range check - <code>in(collection)</code> - Membership check - <code>matches(pattern)</code> - Regex match - <code>any(*values)</code> - Match any of the values - <code>all(*conditions)</code> - All conditions must be true</p> <p>Example: <pre><code>on :order do\n  total &gt; 1000\n  status in [\"pending\", \"processing\"]\n  customer_email matches(/@example\\.com$/)\n  priority any(1, 2, 3)\nend\n</code></pre></p>"},{"location":"guides/dsl/#pattern-helpers","title":"Pattern Helpers","text":"<p>Helper methods available in rule conditions (from <code>ConditionHelpers</code> module).</p>"},{"location":"guides/dsl/#comparison-helpers","title":"Comparison Helpers","text":""},{"location":"guides/dsl/#greater_thanvalue","title":"<code>greater_than(value)</code>","text":"<p>Matches values greater than the specified value.</p> <p>Example: <pre><code>on :temperature, value: greater_than(80)\n# Equivalent to: value: -&gt;(v) { v &gt; 80 }\n</code></pre></p>"},{"location":"guides/dsl/#less_thanvalue","title":"<code>less_than(value)</code>","text":"<p>Matches values less than the specified value.</p> <p>Example: <pre><code>on :inventory, quantity: less_than(10)\n# Equivalent to: quantity: -&gt;(q) { q &lt; 10 }\n</code></pre></p>"},{"location":"guides/dsl/#equalsvalue","title":"<code>equals(value)</code>","text":"<p>Explicitly matches an exact value (same as literal).</p> <p>Example: <pre><code>on :sensor, status: equals(\"active\")\n# Equivalent to: status: \"active\"\n</code></pre></p>"},{"location":"guides/dsl/#not_equalvalue","title":"<code>not_equal(value)</code>","text":"<p>Matches values not equal to the specified value.</p> <p>Example: <pre><code>on :order, status: not_equal(\"cancelled\")\n# Equivalent to: status: -&gt;(s) { s != \"cancelled\" }\n</code></pre></p>"},{"location":"guides/dsl/#range-helpers","title":"Range Helpers","text":""},{"location":"guides/dsl/#betweenmin-max-rangemin-max","title":"<code>between(min, max)</code> / <code>range(min, max)</code>","text":"<p>Matches values in an inclusive range.</p> <p>Example: <pre><code>on :temperature, value: between(70, 90)\n# Equivalent to: value: -&gt;(v) { v &gt;= 70 &amp;&amp; v &lt;= 90 }\n\n# Also works with Range objects:\non :temperature, value: range(70..90)\n</code></pre></p>"},{"location":"guides/dsl/#collection-helpers","title":"Collection Helpers","text":""},{"location":"guides/dsl/#one_ofvalues","title":"<code>one_of(*values)</code>","text":"<p>Matches if value is one of the specified values.</p> <p>Example: <pre><code>on :order, status: one_of(\"pending\", \"processing\", \"completed\")\n# Equivalent to: status: -&gt;(s) { [\"pending\", \"processing\", \"completed\"].include?(s) }\n</code></pre></p>"},{"location":"guides/dsl/#anyvalues","title":"<code>any(*values)</code>","text":"<ul> <li>With arguments: Same as <code>one_of</code></li> <li>Without arguments: Matches any value (always true)</li> </ul> <p>Example: <pre><code># Match one of several values\non :priority, level: any(1, 2, 3)\n\n# Match any value (always true)\non :metadata, extra_data: any\n</code></pre></p>"},{"location":"guides/dsl/#string-helpers","title":"String Helpers","text":""},{"location":"guides/dsl/#matchespattern","title":"<code>matches(pattern)</code>","text":"<p>Matches strings against a regular expression.</p> <p>Example: <pre><code>on :email, address: matches(/@example\\.com$/)\n# Equivalent to: address: -&gt;(a) { a.match?(/@example\\.com$/) }\n\non :sensor, name: matches(/^temp_\\d+$/)\n</code></pre></p>"},{"location":"guides/dsl/#custom-predicates","title":"Custom Predicates","text":""},{"location":"guides/dsl/#satisfiesblock","title":"<code>satisfies(&amp;block)</code>","text":"<p>Creates a custom predicate from a block.</p> <p>Example: <pre><code>on :order, total: satisfies { |t| t &gt; 100 &amp;&amp; t % 10 == 0 }\n# Equivalent to: total: -&gt;(t) { t &gt; 100 &amp;&amp; t % 10 == 0 }\n</code></pre></p>"},{"location":"guides/dsl/#variable-binding_1","title":"Variable Binding","text":"<p>Variables allow you to: 1. Capture attribute values for use in actions 2. Create join tests between conditions</p>"},{"location":"guides/dsl/#variable-syntax","title":"Variable Syntax","text":"<p>Variables are symbols starting with <code>?</code>:</p> <pre><code>:temp?      # Variable named \"temp\"\n:location?  # Variable named \"location\"\n:pid?       # Variable named \"pid\"\n</code></pre>"},{"location":"guides/dsl/#capturing-values","title":"Capturing Values","text":"<pre><code>rule \"temperature_report\" do\n  on :temperature, value: :temp?, location: :loc?, timestamp: :time?\n\n  perform do |bindings|\n    puts \"Temperature at #{bindings[:loc?]}: #{bindings[:temp?]}\u00b0F\"\n    puts \"Recorded: #{bindings[:time?]}\"\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#join-tests","title":"Join Tests","text":"<p>Variables with the same name in different conditions create a join test:</p> <pre><code>rule \"check_inventory\" do\n  on :order, product_id: :pid?, quantity: :qty?\n  on :inventory, product_id: :pid?, available: :avail?\n\n  perform do |bindings|\n    if bindings[:avail?] &lt; bindings[:qty?]\n      puts \"Insufficient inventory for product #{bindings[:pid?]}\"\n    end\n  end\nend\n\n# This rule only fires when:\n# 1. An order fact exists\n# 2. An inventory fact exists\n# 3. Both facts have the SAME product_id\n</code></pre>"},{"location":"guides/dsl/#multiple-bindings","title":"Multiple Bindings","text":"<pre><code>rule \"sensor_temperature_correlation\" do\n  on :sensor, id: :sensor_id?, location: :loc?, status: \"active\"\n  on :temperature, sensor_id: :sensor_id?, value: :temp?\n  on :reading, sensor_id: :sensor_id?, timestamp: :time?\n\n  perform do |bindings|\n    # All three facts share the same sensor_id\n    puts \"Sensor #{bindings[:sensor_id?]} at #{bindings[:loc?]}\"\n    puts \"Reading: #{bindings[:temp?]}\u00b0F at #{bindings[:time?]}\"\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#negation","title":"Negation","text":"<p>Negation matches when a pattern is absent from working memory.</p>"},{"location":"guides/dsl/#negation-keywords","title":"Negation Keywords","text":"<p>All of these are aliases:</p> <ul> <li><code>without(type, pattern = {})</code> - Primary negation keyword</li> <li><code>absent(type, pattern = {})</code> - Alias</li> <li><code>missing(type, pattern = {})</code> - Alias</li> <li><code>lacks(type, pattern = {})</code> - Alias</li> </ul>"},{"location":"guides/dsl/#direct-negation","title":"Direct Negation","text":"<pre><code># Fire when there is NO alert fact\nrule \"all_clear\" do\n  on :system, status: \"running\"\n  without :alert\n  perform { puts \"All systems normal\" }\nend\n\n# Fire when there is NO critical alert\nrule \"no_critical_alerts\" do\n  without :alert, level: \"critical\"\n  perform { puts \"No critical alerts\" }\nend\n\n# Using aliases\nabsent :error\nmissing :problem, severity: \"high\"\nlacks :maintenance_flag\n</code></pre>"},{"location":"guides/dsl/#chained-negation","title":"Chained Negation","text":"<p>Use <code>without</code> (without arguments) followed by <code>on</code>:</p> <pre><code>rule \"example\" do\n  on :order, status: \"pending\"\n  without.on :inventory, quantity: 0\n  perform { puts \"Order can be fulfilled\" }\nend\n</code></pre>"},{"location":"guides/dsl/#negation-with-variables","title":"Negation with Variables","text":"<p>Variables in negated conditions create \"there is no fact with this value\" tests:</p> <pre><code>rule \"no_matching_inventory\" do\n  on :order, product_id: :pid?\n  without :inventory, product_id: :pid?\n\n  perform do |bindings|\n    puts \"No inventory for product #{bindings[:pid?]}\"\n  end\nend\n\n# Fires when:\n# 1. An order exists with product_id=X\n# 2. NO inventory fact exists with product_id=X\n</code></pre>"},{"location":"guides/dsl/#negation-examples","title":"Negation Examples","text":"<pre><code># Guard condition - only process if no errors\nrule \"process_order\" do\n  on :order, status: \"pending\"\n  without :error\n  perform { process_order }\nend\n\n# Detect missing required fact\nrule \"missing_configuration\" do\n  on :system, initialized: true\n  without :config, loaded: true\n  perform { puts \"WARNING: Configuration not loaded\" }\nend\n\n# Timeout detection\nrule \"sensor_timeout\" do\n  on :sensor, id: :sensor_id?, expected: true\n  without :reading, sensor_id: :sensor_id?\n  perform { |b| puts \"Sensor #{b[:sensor_id?]} timeout\" }\nend\n</code></pre>"},{"location":"guides/dsl/#actions","title":"Actions","text":"<p>Actions define what happens when all conditions match.</p>"},{"location":"guides/dsl/#action-keywords","title":"Action Keywords","text":"<p>All of these are aliases:</p> <ul> <li><code>perform(&amp;block)</code> - Primary action keyword</li> <li><code>action(&amp;block)</code> - Alias</li> <li><code>execute(&amp;block)</code> - Alias</li> <li><code>then(&amp;block)</code> - Alias</li> </ul>"},{"location":"guides/dsl/#action-block","title":"Action Block","text":"<p>Actions receive a <code>bindings</code> hash containing all variable bindings:</p> <pre><code>rule \"example\" do\n  on :temperature, value: :temp?, location: :loc?\n\n  perform do |bindings|\n    temp = bindings[:temp?]\n    location = bindings[:loc?]\n    puts \"Temperature at #{location}: #{temp}\u00b0F\"\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#action-capabilities","title":"Action Capabilities","text":"<p>Actions can:</p> <ol> <li> <p>Read bindings: <pre><code>perform do |bindings|\n  value = bindings[:temp?]\nend\n</code></pre></p> </li> <li> <p>Access the knowledge base (via closure): <pre><code>kb = KBS.knowledge_base do\n  rule \"add_fact_from_action\" do\n    on :trigger, event: \"start\"\n    perform do\n      fact :process, status: \"running\"  # Add new fact\n    end\n  end\nend\n</code></pre></p> </li> <li> <p>Call external methods: <pre><code>perform do |bindings|\n  send_email_alert(bindings[:temp?])\n  log_to_database(bindings)\n  trigger_alarm if bindings[:level?] == \"critical\"\nend\n</code></pre></p> </li> <li> <p>Add/remove facts: <pre><code>perform do |bindings|\n  # Add derived fact\n  fact :alert, level: \"high\", source: bindings[:sensor_id?]\n\n  # Remove triggering fact\n  old_fact = query(:trigger, event: \"start\").first\n  retract old_fact if old_fact\nend\n</code></pre></p> </li> </ol>"},{"location":"guides/dsl/#action-examples","title":"Action Examples","text":"<pre><code># Simple logging\nrule \"log_temperature\" do\n  on :temperature, value: :temp?\n  perform { |b| puts \"Temperature: #{b[:temp?]}\" }\nend\n\n# State machine transition\nrule \"pending_to_processing\" do\n  on :order, id: :order_id?, status: \"pending\"\n  on :worker, status: \"available\", id: :worker_id?\n\n  perform do |bindings|\n    # Update order status\n    order = query(:order, id: bindings[:order_id?]).first\n    retract order\n    fact :order, id: bindings[:order_id?],\n                 status: \"processing\",\n                 worker_id: bindings[:worker_id?]\n\n    # Update worker status\n    worker = query(:worker, id: bindings[:worker_id?]).first\n    retract worker\n    fact :worker, id: bindings[:worker_id?], status: \"busy\"\n  end\nend\n\n# Aggregation\nrule \"daily_summary\" do\n  on :trigger, event: \"end_of_day\"\n\n  perform do\n    temps = query(:temperature).map { |f| f[:value] }\n    avg = temps.sum / temps.size.to_f\n\n    fact :daily_summary,\n         date: Date.today,\n         avg_temp: avg,\n         max_temp: temps.max,\n         min_temp: temps.min\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#working-with-facts","title":"Working with Facts","text":""},{"location":"guides/dsl/#adding-facts","title":"Adding Facts","text":"<pre><code>kb = KBS.knowledge_base do\n  # During initialization\n  fact :temperature, value: 85, location: \"server_room\"\n  fact :sensor, id: 1, status: \"active\"\n\n  # Or from action blocks\n  rule \"add_derived_fact\" do\n    on :temperature, value: greater_than(80)\n    perform do\n      fact :alert, level: \"high\", timestamp: Time.now\n    end\n  end\nend\n\n# After creation\nkb.fact :temperature, value: 90\nkb.assert :humidity, value: 60  # Alias\n</code></pre>"},{"location":"guides/dsl/#removing-facts","title":"Removing Facts","text":"<pre><code>kb = KBS.knowledge_base do\n  temp = fact :temperature, value: 85\n\n  # Remove specific fact\n  retract temp\n\n  # Remove from action\n  rule \"cleanup\" do\n    on :temperature, timestamp: less_than(Time.now - 3600)\n    perform do\n      old_facts = query(:temperature)\n                   .select { |f| f[:timestamp] &lt; Time.now - 3600 }\n      old_facts.each { |f| retract f }\n    end\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#querying-facts","title":"Querying Facts","text":"<pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85, location: \"server_room\"\n  fact :temperature, value: 75, location: \"lobby\"\n  fact :humidity, value: 60, location: \"server_room\"\n\n  # Get all facts\n  all = facts\n\n  # Query by type\n  temps = query(:temperature)\n\n  # Query by type and attributes\n  server_room_temps = query(:temperature, location: \"server_room\")\n\n  # Use query results in actions\n  rule \"check_average\" do\n    on :trigger, event: \"calculate_average\"\n\n    perform do\n      temps = query(:temperature).map { |f| f[:value] }\n      avg = temps.sum / temps.size.to_f\n      puts \"Average temperature: #{avg.round(1)}\u00b0F\"\n    end\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#introspection","title":"Introspection","text":""},{"location":"guides/dsl/#inspecting-facts","title":"Inspecting Facts","text":"<pre><code>kb = KBS.knowledge_base do\n  fact :temperature, value: 85\n  fact :humidity, value: 60\n\n  print_facts\nend\n\n# Output:\n# Working Memory Contents:\n# ----------------------------------------\n# 1. temperature(value: 85)\n# 2. humidity(value: 60)\n# ----------------------------------------\n</code></pre>"},{"location":"guides/dsl/#inspecting-rules","title":"Inspecting Rules","text":"<pre><code>kb = KBS.knowledge_base do\n  rule \"high_temp\" do\n    desc \"Alert on high temperature\"\n    priority 10\n    on :temperature, value: greater_than(80)\n    perform { puts \"High!\" }\n  end\n\n  print_rules\nend\n\n# Output:\n# Knowledge Base Rules:\n# ----------------------------------------\n# Rule: high_temp\n#   Description: Alert on high temperature\n#   Priority: 10\n#   Conditions: 1\n#     1. temperature({:value=&gt;#&lt;Proc:...&gt;})\n# ----------------------------------------\n</code></pre>"},{"location":"guides/dsl/#programmatic-access","title":"Programmatic Access","text":"<pre><code>kb = KBS.knowledge_base do\n  rule \"example\" do\n    on :temperature, value: :temp?\n    perform { |b| puts b[:temp?] }\n  end\nend\n\n# Access rules\nkb.rules  # =&gt; Hash { \"example\" =&gt; KBS::Rule }\nkb.rules[\"example\"]  # =&gt; KBS::Rule instance\n\n# Access engine\nkb.engine  # =&gt; KBS::Engine\nkb.engine.working_memory  # =&gt; KBS::WorkingMemory\nkb.engine.rules  # =&gt; Array&lt;KBS::Rule&gt;\n</code></pre>"},{"location":"guides/dsl/#complete-examples","title":"Complete Examples","text":""},{"location":"guides/dsl/#temperature-monitoring","title":"Temperature Monitoring","text":"<pre><code>require 'kbs'\n\nkb = KBS.knowledge_base do\n  # Rules\n  rule \"high_temperature_alert\" do\n    desc \"Alert when temperature exceeds safe threshold\"\n    priority 10\n\n    on :sensor, id: :sensor_id?, status: \"active\"\n    on :temperature, sensor_id: :sensor_id?, value: greater_than(80)\n    without :alert, sensor_id: :sensor_id?  # No existing alert\n\n    perform do |bindings|\n      puts \"\u26a0\ufe0f  HIGH TEMPERATURE ALERT\"\n      puts \"Sensor: #{bindings[:sensor_id?]}\"\n      puts \"Temperature: #{bindings[:value?]}\u00b0F\"\n\n      # Create alert fact\n      fact :alert,\n           sensor_id: bindings[:sensor_id?],\n           level: \"high\",\n           timestamp: Time.now\n    end\n  end\n\n  rule \"temperature_normal\" do\n    desc \"Clear alert when temperature returns to normal\"\n    priority 5\n\n    on :temperature, sensor_id: :sensor_id?, value: less_than(75)\n    on :alert, sensor_id: :sensor_id?\n\n    perform do |bindings|\n      puts \"\u2713 Temperature normal for sensor #{bindings[:sensor_id?]}\"\n\n      # Remove alert\n      alerts = query(:alert, sensor_id: bindings[:sensor_id?])\n      alerts.each { |a| retract a }\n    end\n  end\n\n  # Initial facts\n  fact :sensor, id: 1, status: \"active\", location: \"server_room\"\n  fact :sensor, id: 2, status: \"active\", location: \"lobby\"\n\n  # Simulate readings\n  fact :temperature, sensor_id: 1, value: 85  # Will trigger alert\n  fact :temperature, sensor_id: 2, value: 72  # Normal\n\n  run\n\n  print_facts\nend\n</code></pre>"},{"location":"guides/dsl/#order-processing-workflow","title":"Order Processing Workflow","text":"<pre><code>kb = KBS.knowledge_base do\n  rule \"validate_order\" do\n    priority 100\n\n    on :order, id: :order_id?, status: \"new\", product_id: :pid?, quantity: :qty?\n    on :inventory, product_id: :pid?, quantity: :available?\n\n    perform do |bindings|\n      if bindings[:available?] &gt;= bindings[:qty?]\n        order = query(:order, id: bindings[:order_id?]).first\n        retract order\n        fact :order,\n             id: bindings[:order_id?],\n             status: \"validated\",\n             product_id: bindings[:pid?],\n             quantity: bindings[:qty?]\n      else\n        fact :alert,\n             type: \"insufficient_inventory\",\n             order_id: bindings[:order_id?]\n      end\n    end\n  end\n\n  rule \"fulfill_order\" do\n    priority 50\n\n    on :order, id: :order_id?, status: \"validated\",\n               product_id: :pid?, quantity: :qty?\n    on :inventory, product_id: :pid?, quantity: :available?\n\n    perform do |bindings|\n      # Deduct inventory\n      inventory = query(:inventory, product_id: bindings[:pid?]).first\n      retract inventory\n      fact :inventory,\n           product_id: bindings[:pid?],\n           quantity: bindings[:available?] - bindings[:qty?]\n\n      # Update order status\n      order = query(:order, id: bindings[:order_id?]).first\n      retract order\n      fact :order,\n           id: bindings[:order_id?],\n           status: \"fulfilled\",\n           product_id: bindings[:pid?],\n           quantity: bindings[:qty?]\n\n      puts \"\u2713 Order #{bindings[:order_id?]} fulfilled\"\n    end\n  end\n\n  # Initial state\n  fact :inventory, product_id: \"ABC\", quantity: 100\n  fact :inventory, product_id: \"XYZ\", quantity: 50\n\n  fact :order, id: 1, status: \"new\", product_id: \"ABC\", quantity: 10\n  fact :order, id: 2, status: \"new\", product_id: \"XYZ\", quantity: 60  # Insufficient!\n\n  run\n  print_facts\nend\n</code></pre>"},{"location":"guides/dsl/#best-practices","title":"Best Practices","text":""},{"location":"guides/dsl/#1-use-descriptive-names","title":"1. Use Descriptive Names","text":"<pre><code># Good\nrule \"high_temperature_alert\" do\n  desc \"Alert when server room temperature exceeds 80\u00b0F\"\n  # ...\nend\n\n# Bad\nrule \"rule1\" do\n  # ...\nend\n</code></pre>"},{"location":"guides/dsl/#2-add-descriptions","title":"2. Add Descriptions","text":"<pre><code>rule \"complex_calculation\" do\n  desc \"Calculates portfolio value using current market prices and holdings\"\n  # ... complex logic ...\nend\n</code></pre>"},{"location":"guides/dsl/#3-order-conditions-by-selectivity","title":"3. Order Conditions by Selectivity","text":"<pre><code># Good - Most selective first\nrule \"specific_sensor_alert\" do\n  on :sensor, id: 42, status: \"active\"  # Very selective\n  on :temperature, sensor_id: 42, value: greater_than(80)\n  perform { puts \"Alert!\" }\nend\n\n# Less efficient - Unselective first\nrule \"specific_sensor_alert\" do\n  on :temperature, value: greater_than(80)  # Matches many facts\n  on :sensor, id: 42, status: \"active\"\n  perform { puts \"Alert!\" }\nend\n</code></pre>"},{"location":"guides/dsl/#4-use-pattern-helpers","title":"4. Use Pattern Helpers","text":"<pre><code># Good - Readable\non :temperature, value: between(70, 90)\non :order, status: one_of(\"pending\", \"processing\")\n\n# Less readable\non :temperature, value: -&gt;(v) { v &gt;= 70 &amp;&amp; v &lt;= 90 }\non :order, status: -&gt;(s) { [\"pending\", \"processing\"].include?(s) }\n</code></pre>"},{"location":"guides/dsl/#5-keep-actions-simple","title":"5. Keep Actions Simple","text":"<pre><code># Good - Simple, focused action\nrule \"log_temperature\" do\n  on :temperature, value: :temp?\n  perform { |b| logger.info(\"Temperature: #{b[:temp?]}\") }\nend\n\n# Avoid - Complex logic in action\nrule \"complex_action\" do\n  on :temperature, value: :temp?\n  perform do |b|\n    # 100 lines of complex logic...\n    # Better to extract to methods\n  end\nend\n</code></pre>"},{"location":"guides/dsl/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide - First tutorial</li> <li>Writing Rules Guide - Best practices for rules</li> <li>Pattern Matching Guide - Advanced pattern matching</li> <li>Variable Binding Guide - Join tests and bindings</li> <li>Negation Guide - Negation semantics</li> <li>Rules API - Programmatic rule creation</li> </ul>"},{"location":"guides/facts/","title":"Working with Facts","text":"<p>Facts are the fundamental units of knowledge in KBS. This guide covers the complete lifecycle of facts: creating, querying, updating, and removing them.</p>"},{"location":"guides/facts/#what-is-a-fact","title":"What is a Fact?","text":"<p>A fact represents an observation or piece of knowledge about your domain. Facts have:</p> <ul> <li>Type - A symbol categorizing the fact (e.g., <code>:stock</code>, <code>:sensor</code>, <code>:alert</code>)</li> <li>Attributes - Key-value pairs describing the fact (e.g., <code>{ symbol: \"AAPL\", price: 150 }</code>)</li> <li>Identity - Unique instance in working memory</li> </ul> <p>Example Facts:</p> <pre><code># Sensor reading\ntype: :sensor\nattributes: { id: \"bedroom\", temp: 28, humidity: 65 }\n\n# Stock quote\ntype: :stock\nattributes: { symbol: \"AAPL\", price: 150.50, volume: 1000000 }\n\n# Alert\ntype: :alert\nattributes: { sensor_id: \"bedroom\", message: \"High temperature\" }\n</code></pre>"},{"location":"guides/facts/#fact-types","title":"Fact Types","text":"<p>KBS provides two fact implementations:</p>"},{"location":"guides/facts/#1-transient-facts-kbsfact","title":"1. Transient Facts (<code>KBS::Fact</code>)","text":"<p>In-memory facts that disappear when your program exits.</p> <pre><code>engine = KBS::Engine.new\n\n# Add transient fact\nfact = engine.add_fact(:stock, { symbol: \"AAPL\", price: 150 })\n\n# Facts lost on restart\n</code></pre> <p>Use for: - Short-lived applications - Prototyping - Testing - Pure computation (no persistence needed)</p>"},{"location":"guides/facts/#2-persistent-facts-kbsblackboardfact","title":"2. Persistent Facts (<code>KBS::Blackboard::Fact</code>)","text":"<p>Database-backed facts with UUIDs that survive restarts.</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\n# Add persistent fact (saved to database)\nfact = engine.add_fact(:stock, { symbol: \"AAPL\", price: 150 })\nputs fact.id  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Facts reload on next run\nengine.close\n\n# Next run\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nputs engine.facts.size  # =&gt; 1 (fact persisted)\n</code></pre> <p>Use for: - Long-running systems - Systems requiring restart - Audit trails - Multi-agent collaboration</p> <p>Both types share the same interface, so code works identically:</p> <pre><code>fact.type           # =&gt; :stock\nfact[:symbol]       # =&gt; \"AAPL\"\nfact[:price]        # =&gt; 150\nfact.attributes     # =&gt; { symbol: \"AAPL\", price: 150 }\n</code></pre>"},{"location":"guides/facts/#creating-facts","title":"Creating Facts","text":""},{"location":"guides/facts/#basic-creation","title":"Basic Creation","text":"<pre><code># Method 1: Via engine (recommended)\nfact = engine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\n\n# Method 2: Direct instantiation\nfact = KBS::Fact.new(:sensor, { id: \"bedroom\", temp: 28 })\nengine.add_fact(fact)\n</code></pre> <p><code>add_fact</code> automatically: - Stores fact in working memory - Triggers pattern matching in RETE network - Notifies observers - Persists to database (if using Blackboard::Engine)</p>"},{"location":"guides/facts/#with-type-conversion","title":"With Type Conversion","text":"<p>Attributes are stored as-is:</p> <pre><code>engine.add_fact(:reading, {\n  value: 42,              # Integer\n  timestamp: Time.now,    # Time object\n  active: true,           # Boolean\n  metadata: { foo: 1 }    # Hash\n})\n</code></pre>"},{"location":"guides/facts/#bulk-creation","title":"Bulk Creation","text":"<pre><code>facts = [\n  [:stock, { symbol: \"AAPL\", price: 150 }],\n  [:stock, { symbol: \"GOOGL\", price: 2800 }],\n  [:stock, { symbol: \"MSFT\", price: 300 }]\n]\n\nfacts.each do |type, attrs|\n  engine.add_fact(type, attrs)\nend\n</code></pre>"},{"location":"guides/facts/#from-external-data","title":"From External Data","text":"<pre><code>require 'json'\n\n# Load from JSON\njson_data = File.read('sensors.json')\nsensor_data = JSON.parse(json_data, symbolize_names: true)\n\nsensor_data.each do |reading|\n  engine.add_fact(:sensor, {\n    id: reading[:sensor_id],\n    temp: reading[:temperature],\n    humidity: reading[:humidity]\n  })\nend\n</code></pre> <pre><code>require 'csv'\n\n# Load from CSV\nCSV.foreach('stocks.csv', headers: true) do |row|\n  engine.add_fact(:stock, {\n    symbol: row['symbol'],\n    price: row['price'].to_f,\n    volume: row['volume'].to_i\n  })\nend\n</code></pre>"},{"location":"guides/facts/#accessing-fact-attributes","title":"Accessing Fact Attributes","text":""},{"location":"guides/facts/#array-style-access","title":"Array-Style Access","text":"<pre><code>fact = engine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\n\n# Read attributes\nfact[:id]     # =&gt; \"bedroom\"\nfact[:temp]   # =&gt; 28\nfact[:missing] # =&gt; nil\n</code></pre>"},{"location":"guides/facts/#attributes-hash","title":"Attributes Hash","text":"<pre><code>fact.attributes\n# =&gt; { id: \"bedroom\", temp: 28 }\n\n# Iterate attributes\nfact.attributes.each do |key, value|\n  puts \"#{key}: #{value}\"\nend\n</code></pre>"},{"location":"guides/facts/#type-access","title":"Type Access","text":"<pre><code>fact.type  # =&gt; :sensor\n</code></pre>"},{"location":"guides/facts/#identity-persistent-facts-only","title":"Identity (Persistent Facts Only)","text":"<pre><code># Blackboard facts have UUIDs\nfact.id  # =&gt; \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Transient facts use object_id\nfact.object_id  # =&gt; 70123456789000\n</code></pre>"},{"location":"guides/facts/#querying-facts","title":"Querying Facts","text":""},{"location":"guides/facts/#get-all-facts","title":"Get All Facts","text":"<pre><code>all_facts = engine.facts\n# =&gt; [#&lt;Fact type=:sensor&gt;, #&lt;Fact type=:stock&gt;, ...]\n</code></pre>"},{"location":"guides/facts/#filter-by-type","title":"Filter by Type","text":"<pre><code># Get all sensor facts\nsensors = engine.facts.select { |f| f.type == :sensor }\n\n# Get all stock facts\nstocks = engine.facts.select { |f| f.type == :stock }\n</code></pre>"},{"location":"guides/facts/#filter-by-attribute","title":"Filter by Attribute","text":"<pre><code># Find facts with specific attribute value\nhigh_temps = engine.facts.select { |f|\n  f.type == :sensor &amp;&amp; f[:temp] &amp;&amp; f[:temp] &gt; 30\n}\n\n# Find by multiple criteria\naapl_stocks = engine.facts.select { |f|\n  f.type == :stock &amp;&amp; f[:symbol] == \"AAPL\"\n}\n</code></pre>"},{"location":"guides/facts/#find-single-fact","title":"Find Single Fact","text":"<pre><code># Find first matching fact\nfact = engine.facts.find { |f|\n  f.type == :sensor &amp;&amp; f[:id] == \"bedroom\"\n}\n\n# Or return nil if not found\nfact = engine.facts.find { |f|\n  f.type == :alert &amp;&amp; f[:severity] == \"critical\"\n}\n</code></pre>"},{"location":"guides/facts/#complex-queries","title":"Complex Queries","text":"<pre><code># Count facts\nsensor_count = engine.facts.count { |f| f.type == :sensor }\n\n# Group by type\nfacts_by_type = engine.facts.group_by(&amp;:type)\n# =&gt; { sensor: [...], stock: [...], alert: [...] }\n\n# Map attributes\nsymbols = engine.facts\n  .select { |f| f.type == :stock }\n  .map { |f| f[:symbol] }\n  .uniq\n# =&gt; [\"AAPL\", \"GOOGL\", \"MSFT\"]\n</code></pre>"},{"location":"guides/facts/#query-helper-method","title":"Query Helper Method","text":"<p>Create reusable query methods:</p> <pre><code>class QueryHelper\n  def initialize(engine)\n    @engine = engine\n  end\n\n  def facts_of_type(type)\n    @engine.facts.select { |f| f.type == type }\n  end\n\n  def facts_where(type, &amp;block)\n    facts_of_type(type).select(&amp;block)\n  end\n\n  def fact_where(type, &amp;block)\n    facts_of_type(type).find(&amp;block)\n  end\nend\n\n# Usage\nhelper = QueryHelper.new(engine)\n\n# Get all high-temp sensors\nhigh_temps = helper.facts_where(:sensor) { |f| f[:temp] &gt; 30 }\n\n# Get specific sensor\nbedroom = helper.fact_where(:sensor) { |f| f[:id] == \"bedroom\" }\n</code></pre>"},{"location":"guides/facts/#updating-facts","title":"Updating Facts","text":"<p>Facts are immutable in KBS. To \"update\" a fact, remove the old one and add a new one.</p>"},{"location":"guides/facts/#update-pattern","title":"Update Pattern","text":"<pre><code># Find existing fact\nold_fact = engine.facts.find { |f|\n  f.type == :sensor &amp;&amp; f[:id] == \"bedroom\"\n}\n\nif old_fact\n  # Remove old fact\n  engine.remove_fact(old_fact)\n\n  # Add updated fact\n  engine.add_fact(:sensor, {\n    id: \"bedroom\",\n    temp: 30,  # Updated temperature\n    humidity: 65\n  })\n\n  # Re-run matching\n  engine.run\nend\n</code></pre>"},{"location":"guides/facts/#update-helper","title":"Update Helper","text":"<pre><code>def update_fact(engine, type, matcher, new_attrs)\n  old_fact = engine.facts.find { |f|\n    f.type == type &amp;&amp; matcher.call(f)\n  }\n\n  if old_fact\n    engine.remove_fact(old_fact)\n    engine.add_fact(type, new_attrs)\n  end\nend\n\n# Usage\nupdate_fact(engine, :sensor, -&gt;(f) { f[:id] == \"bedroom\" },\n  { id: \"bedroom\", temp: 30, humidity: 65 }\n)\n</code></pre>"},{"location":"guides/facts/#blackboard-update-persistent-facts","title":"Blackboard Update (Persistent Facts)","text":"<p>Blackboard facts support in-place updates:</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\nfact = engine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\n\n# Update attributes (saves to database)\nfact.update({ temp: 30 })\n\n# Or update via engine\nengine.update_fact(fact.id, { temp: 32 })\n</code></pre>"},{"location":"guides/facts/#removing-facts","title":"Removing Facts","text":""},{"location":"guides/facts/#remove-single-fact","title":"Remove Single Fact","text":"<pre><code># Find and remove\nfact = engine.facts.find { |f| f.type == :alert }\nengine.remove_fact(fact) if fact\n\n# Re-run to propagate changes\nengine.run\n</code></pre>"},{"location":"guides/facts/#remove-multiple-facts","title":"Remove Multiple Facts","text":"<pre><code># Remove all alerts\nalerts = engine.facts.select { |f| f.type == :alert }\nalerts.each { |fact| engine.remove_fact(fact) }\nengine.run\n</code></pre>"},{"location":"guides/facts/#remove-by-criteria","title":"Remove by Criteria","text":"<pre><code># Remove all stale sensor readings (older than 5 minutes)\nstale = engine.facts.select { |f|\n  f.type == :sensor &amp;&amp;\n  f[:timestamp] &amp;&amp;\n  (Time.now - f[:timestamp]) &gt; 300\n}\n\nstale.each { |fact| engine.remove_fact(fact) }\nengine.run\n</code></pre>"},{"location":"guides/facts/#clear-all-facts","title":"Clear All Facts","text":"<pre><code># Clear working memory\nengine.facts.dup.each { |f| engine.remove_fact(f) }\nengine.run\n</code></pre> <p>Note: Use <code>.dup</code> to avoid modifying array while iterating.</p>"},{"location":"guides/facts/#fact-lifecycle","title":"Fact Lifecycle","text":""},{"location":"guides/facts/#lifecycle-stages","title":"Lifecycle Stages","text":"<pre><code>1. Creation\n   \u251c\u2500&gt; engine.add_fact(:type, { ... })\n   \u2514\u2500&gt; Fact instantiated\n\n2. Storage\n   \u251c\u2500&gt; Added to WorkingMemory\n   \u2514\u2500&gt; Persisted (if Blackboard::Engine)\n\n3. Matching\n   \u251c\u2500&gt; Alpha network activation\n   \u251c\u2500&gt; Join network propagation\n   \u2514\u2500&gt; Production node tokens created\n\n4. Rule Firing\n   \u251c\u2500&gt; engine.run()\n   \u2514\u2500&gt; Actions execute with fact\n\n5. Update (Optional)\n   \u251c\u2500&gt; engine.remove_fact(old_fact)\n   \u251c\u2500&gt; engine.add_fact(:type, new_attrs)\n   \u2514\u2500&gt; Matching re-triggered\n\n6. Removal\n   \u251c\u2500&gt; engine.remove_fact(fact)\n   \u251c\u2500&gt; Removed from WorkingMemory\n   \u251c\u2500&gt; Deleted from database (if persistent)\n   \u2514\u2500&gt; Tokens invalidated\n</code></pre>"},{"location":"guides/facts/#observing-fact-changes","title":"Observing Fact Changes","text":"<p>Working memory uses the Observer pattern:</p> <pre><code>class FactObserver\n  def update(operation, fact)\n    case operation\n    when :add\n      puts \"Added: #{fact.type} - #{fact.attributes}\"\n    when :remove\n      puts \"Removed: #{fact.type} - #{fact.attributes}\"\n    end\n  end\nend\n\nobserver = FactObserver.new\nengine.working_memory.add_observer(observer)\n\nengine.add_fact(:sensor, { id: \"bedroom\", temp: 28 })\n# Output: Added: sensor - {:id=&gt;\"bedroom\", :temp=&gt;28}\n</code></pre>"},{"location":"guides/facts/#best-practices","title":"Best Practices","text":""},{"location":"guides/facts/#1-use-consistent-fact-types","title":"1. Use Consistent Fact Types","text":"<pre><code># Good: Consistent naming\n:sensor_reading\n:stock_quote\n:user_alert\n\n# Bad: Inconsistent\n:sensor\n:Stock\n:UserAlert\n</code></pre>"},{"location":"guides/facts/#2-keep-attributes-flat","title":"2. Keep Attributes Flat","text":"<pre><code># Good: Flat structure\nengine.add_fact(:sensor, {\n  sensor_id: \"bedroom\",\n  temp: 28,\n  humidity: 65\n})\n\n# Bad: Nested (harder to match)\nengine.add_fact(:sensor, {\n  id: \"bedroom\",\n  readings: { temp: 28, humidity: 65 }\n})\n</code></pre>"},{"location":"guides/facts/#3-include-timestamps","title":"3. Include Timestamps","text":"<pre><code># Good: Temporal reasoning enabled\nengine.add_fact(:reading, {\n  sensor_id: \"bedroom\",\n  value: 28,\n  timestamp: Time.now\n})\n</code></pre>"},{"location":"guides/facts/#4-validate-before-adding","title":"4. Validate Before Adding","text":"<pre><code>def add_sensor_reading(engine, id, temp)\n  # Validate\n  raise ArgumentError, \"Invalid temp\" unless temp.is_a?(Numeric)\n  raise ArgumentError, \"Temp out of range\" unless temp.between?(-50, 100)\n\n  # Add fact\n  engine.add_fact(:sensor, {\n    id: id,\n    temp: temp,\n    timestamp: Time.now\n  })\nend\n</code></pre>"},{"location":"guides/facts/#5-use-symbols-for-type","title":"5. Use Symbols for Type","text":"<pre><code># Good\nengine.add_fact(:sensor, { ... })\n\n# Bad\nengine.add_fact(\"sensor\", { ... })  # Strings not idiomatic\n</code></pre>"},{"location":"guides/facts/#6-namespace-fact-types","title":"6. Namespace Fact Types","text":"<pre><code># Good: Clear namespacing for large systems\n:trading_order\n:trading_execution\n:trading_alert\n\n:sensor_temp\n:sensor_humidity\n:sensor_pressure\n</code></pre>"},{"location":"guides/facts/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/facts/#fact-factory","title":"Fact Factory","text":"<pre><code>class SensorFactFactory\n  def self.create_reading(id, temp, humidity)\n    {\n      type: :sensor,\n      attributes: {\n        id: id,\n        temp: temp,\n        humidity: humidity,\n        timestamp: Time.now\n      }\n    }\n  end\nend\n\n# Usage\nreading = SensorFactFactory.create_reading(\"bedroom\", 28, 65)\nengine.add_fact(reading[:type], reading[:attributes])\n</code></pre>"},{"location":"guides/facts/#fact-builder","title":"Fact Builder","text":"<pre><code>class FactBuilder\n  def initialize(type)\n    @type = type\n    @attributes = {}\n  end\n\n  def with(key, value)\n    @attributes[key] = value\n    self\n  end\n\n  def build\n    [@type, @attributes]\n  end\nend\n\n# Usage\ntype, attrs = FactBuilder.new(:stock)\n  .with(:symbol, \"AAPL\")\n  .with(:price, 150)\n  .with(:volume, 1000000)\n  .build\n\nengine.add_fact(type, attrs)\n</code></pre>"},{"location":"guides/facts/#fact-repository","title":"Fact Repository","text":"<pre><code>class FactRepository\n  def initialize(engine)\n    @engine = engine\n  end\n\n  def add(type, attributes)\n    @engine.add_fact(type, attributes.merge(created_at: Time.now))\n  end\n\n  def find_by_id(type, id)\n    @engine.facts.find { |f| f.type == type &amp;&amp; f[:id] == id }\n  end\n\n  def where(type, &amp;block)\n    @engine.facts.select { |f| f.type == type &amp;&amp; block.call(f) }\n  end\n\n  def remove_where(type, &amp;block)\n    facts = where(type, &amp;block)\n    facts.each { |f| @engine.remove_fact(f) }\n    @engine.run\n  end\nend\n\n# Usage\nrepo = FactRepository.new(engine)\nrepo.add(:sensor, { id: \"bedroom\", temp: 28 })\n\nbedroom = repo.find_by_id(:sensor, \"bedroom\")\nhigh_temps = repo.where(:sensor) { |f| f[:temp] &gt; 30 }\nrepo.remove_where(:alert) { |f| f[:stale] }\n</code></pre>"},{"location":"guides/facts/#next-steps","title":"Next Steps","text":"<ul> <li>Pattern Matching - How facts match conditions</li> <li>Writing Rules - Using facts in rule conditions</li> <li>Blackboard Memory - Persistent fact storage</li> <li>Persistence Guide - SQLite, Redis, and hybrid storage</li> <li>API Reference - Complete Fact API documentation</li> </ul> <p>Facts are immutable knowledge. When facts change, replace them to trigger re-evaluation.</p>"},{"location":"guides/getting-started/","title":"Getting Started","text":"<p>Build your first knowledge-based system in 10 minutes. This hands-on tutorial teaches the fundamentals by creating a temperature monitoring system that alerts when sensors exceed thresholds.</p>"},{"location":"guides/getting-started/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Creating rules and facts</li> <li>Variable binding across conditions</li> <li>Using negation to prevent duplicate alerts</li> <li>Persisting facts with blackboard memory</li> <li>Controlling rule execution with priorities</li> </ul>"},{"location":"guides/getting-started/#installation","title":"Installation","text":"<p>Add KBS to your Gemfile:</p> <pre><code>gem 'kbs'\n</code></pre> <p>Or install directly:</p> <pre><code>gem install kbs\n</code></pre>"},{"location":"guides/getting-started/#your-first-rule","title":"Your First Rule","text":"<p>Let's create a simple rule that fires when temperature exceeds a threshold.</p>"},{"location":"guides/getting-started/#step-1-create-the-engine","title":"Step 1: Create the Engine","text":"<pre><code>require 'kbs'\n\n# Create the inference engine\nengine = KBS::Engine.new\n</code></pre> <p>The engine manages rules, facts, and executes the pattern matching algorithm.</p>"},{"location":"guides/getting-started/#step-2-define-a-rule","title":"Step 2: Define a Rule","text":"<pre><code># Define a rule for high temperature alerts\nhigh_temp_rule = KBS::Rule.new(\"high_temperature_alert\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { id: :sensor_id?, temp: :temp? }),\n    KBS::Condition.new(:threshold, { id: :sensor_id?, max: :max? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:temp?] &gt; bindings[:max?]\n      puts \"\ud83d\udea8 ALERT: Sensor #{bindings[:sensor_id?]} at #{bindings[:temp?]}\u00b0C\"\n    end\n  end\nend\n\nengine.add_rule(high_temp_rule)\n</code></pre> <p>What this rule does:</p> <ul> <li>Condition 1: Match any <code>:sensor</code> fact, binding its <code>id</code> to <code>:sensor_id?</code> and <code>temp</code> to <code>:temp?</code></li> <li>Condition 2: Match a <code>:threshold</code> fact with the same <code>id</code>, binding <code>max</code> to <code>:max?</code></li> <li>Action: When both conditions match, compare temperature against threshold</li> </ul> <p>Variable binding (<code>:sensor_id?</code>) ensures we only compare sensors with their own thresholds.</p>"},{"location":"guides/getting-started/#step-3-add-facts","title":"Step 3: Add Facts","text":"<pre><code># Add sensor reading\nengine.add_fact(:sensor, id: \"bedroom\", temp: 28)\n\n# Add threshold\nengine.add_fact(:threshold, id: \"bedroom\", max: 25)\n</code></pre> <p>Facts are observations about the world. The engine automatically matches them against rule conditions.</p>"},{"location":"guides/getting-started/#step-4-run-the-engine","title":"Step 4: Run the Engine","text":"<pre><code>engine.run\n</code></pre> <p>Output: <pre><code>\ud83d\udea8 ALERT: Sensor bedroom at 28\u00b0C\n</code></pre></p> <p>The rule fired because the bedroom temperature (28\u00b0C) exceeds its threshold (25\u00b0C).</p>"},{"location":"guides/getting-started/#understanding-variable-binding","title":"Understanding Variable Binding","text":"<p>Variable binding connects facts across conditions. Here's how it works:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:sensor, { id: :sensor_id?, temp: :temp? }),\n  KBS::Condition.new(:threshold, { id: :sensor_id?, max: :max? })\n]\n</code></pre> <p>Binding Process:</p> <ol> <li>Engine finds a <code>:sensor</code> fact: <code>{ id: \"bedroom\", temp: 28 }</code></li> <li>Binds <code>:sensor_id?</code> \u2192 <code>\"bedroom\"</code>, <code>:temp?</code> \u2192 <code>28</code></li> <li>Searches for <code>:threshold</code> fact where <code>id</code> also equals <code>\"bedroom\"</code></li> <li>Finds <code>{ id: \"bedroom\", max: 25 }</code></li> <li>Binds <code>:max?</code> \u2192 <code>25</code></li> <li>Both conditions satisfied \u2192 rule fires with bindings: <code>{ :sensor_id? =&gt; \"bedroom\", :temp? =&gt; 28, :max? =&gt; 25 }</code></li> </ol> <p>Without variable binding, the rule would incorrectly match bedroom sensors with kitchen thresholds.</p>"},{"location":"guides/getting-started/#preventing-duplicate-alerts-with-negation","title":"Preventing Duplicate Alerts with Negation","text":"<p>Let's prevent the same alert from firing repeatedly:</p> <pre><code>smart_alert_rule = KBS::Rule.new(\"smart_temperature_alert\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { id: :sensor_id?, temp: :temp? }),\n    KBS::Condition.new(:threshold, { id: :sensor_id?, max: :max? }),\n    # Only fire if no alert already exists for this sensor\n    KBS::Condition.new(:alert, { sensor_id: :sensor_id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:temp?] &gt; bindings[:max?]\n      puts \"\ud83d\udea8 ALERT: Sensor #{bindings[:sensor_id?]} at #{bindings[:temp?]}\u00b0C\"\n      # Record that we sent this alert\n      engine.add_fact(:alert, sensor_id: bindings[:sensor_id?])\n    end\n  end\nend\n</code></pre> <p>Negated condition (<code>negated: true</code>): Rule fires only when NO <code>:alert</code> fact exists for this sensor.</p> <p>Flow:</p> <ol> <li>First execution: No <code>:alert</code> fact \u2192 rule fires, creates <code>:alert</code> fact</li> <li>Second execution: <code>:alert</code> fact exists \u2192 rule doesn't fire (negation blocks it)</li> </ol>"},{"location":"guides/getting-started/#persisting-facts-with-blackboard-memory","title":"Persisting Facts with Blackboard Memory","text":"<p>So far, facts disappear when your program exits. Use blackboard memory for persistence:</p> <pre><code>require 'kbs'\n\n# Create engine with SQLite persistence\nengine = KBS::Blackboard::Engine.new(db_path: 'sensors.db')\n\n# Add rules (same as before)\nengine.add_rule(smart_alert_rule)\n\n# Add facts - these are saved to database\nengine.add_fact(:sensor, id: \"bedroom\", temp: 28)\nengine.add_fact(:threshold, id: \"bedroom\", max: 25)\n\nengine.run\n\n# Facts survive program restart\nengine.close\n</code></pre> <p>Next time you run:</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'sensors.db')\n# Facts automatically loaded from database\nputs engine.facts.size  # =&gt; 2 (sensor + threshold)\n</code></pre> <p>Blackboard provides: - Persistence: Facts saved to SQLite/Redis - Audit Trail: Complete history of changes - Transactions: ACID guarantees for multi-fact updates</p> <p>Learn more: Blackboard Memory Guide</p>"},{"location":"guides/getting-started/#controlling-execution-with-priorities","title":"Controlling Execution with Priorities","text":"<p>When multiple rules match, control firing order with priorities:</p> <pre><code>critical_rule = KBS::Rule.new(\"critical_alert\", priority: 100) do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { temp: :temp? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:temp?] &gt; 50\n      puts \"\ud83d\udd25 CRITICAL: Immediate shutdown required!\"\n      exit(1)\n    end\n  end\nend\n\nnormal_rule = KBS::Rule.new(\"normal_alert\", priority: 10) do |r|\n  # ... (less urgent alerts)\nend\n\nengine.add_rule(critical_rule)\nengine.add_rule(normal_rule)\n</code></pre> <p>Priority: Higher numbers fire first. Default is <code>0</code>.</p> <p>Execution order: 1. <code>critical_alert</code> (priority 100) - checks for emergency shutdown 2. <code>normal_alert</code> (priority 10) - handles routine alerts</p>"},{"location":"guides/getting-started/#complete-working-example","title":"Complete Working Example","text":"<p>Here's a complete temperature monitoring system:</p> <pre><code>require 'kbs'\n\nclass TemperatureMonitor\n  def initialize\n    @engine = KBS::Blackboard::Engine.new(db_path: 'sensors.db')\n    setup_rules\n  end\n\n  def setup_rules\n    # Rule 1: Send alert when temp exceeds threshold\n    alert_rule = KBS::Rule.new(\"temperature_alert\", priority: 50) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n        KBS::Condition.new(:threshold, { id: :id?, max: :max? }),\n        KBS::Condition.new(:alert, { sensor_id: :id? }, negated: true)\n      ]\n\n      r.action = lambda do |facts, bindings|\n        if bindings[:temp?] &gt; bindings[:max?]\n          send_alert(bindings[:id?], bindings[:temp?], bindings[:max?])\n          @engine.add_fact(:alert, sensor_id: bindings[:id?])\n        end\n      end\n    end\n\n    # Rule 2: Clear alert when temp drops below threshold\n    clear_rule = KBS::Rule.new(\"clear_alert\", priority: 40) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n        KBS::Condition.new(:threshold, { id: :id?, max: :max? }),\n        KBS::Condition.new(:alert, { sensor_id: :id? })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        if bindings[:temp?] &lt;= bindings[:max?]\n          clear_alert(bindings[:id?])\n          # Remove the alert fact\n          alert_fact = facts.find { |f| f.type == :alert &amp;&amp; f[:sensor_id] == bindings[:id?] }\n          @engine.remove_fact(alert_fact) if alert_fact\n        end\n      end\n    end\n\n    # Rule 3: Emergency shutdown for extreme temps\n    emergency_rule = KBS::Rule.new(\"emergency_shutdown\", priority: 100) do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor, { temp: :temp? })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        if bindings[:temp?] &gt; 60\n          emergency_shutdown(bindings[:temp?])\n        end\n      end\n    end\n\n    @engine.add_rule(alert_rule)\n    @engine.add_rule(clear_rule)\n    @engine.add_rule(emergency_rule)\n  end\n\n  def add_sensor(id, max_temp)\n    @engine.add_fact(:threshold, id: id, max: max_temp)\n  end\n\n  def update_reading(id, temp)\n    # Remove old reading\n    old = @engine.facts.find { |f| f.type == :sensor &amp;&amp; f[:id] == id }\n    @engine.remove_fact(old) if old\n\n    # Add new reading\n    @engine.add_fact(:sensor, id: id, temp: temp)\n    @engine.run\n  end\n\n  def send_alert(sensor_id, temp, threshold)\n    puts \"\ud83d\udea8 ALERT: #{sensor_id} at #{temp}\u00b0C (threshold: #{threshold}\u00b0C)\"\n  end\n\n  def clear_alert(sensor_id)\n    puts \"\u2705 CLEAR: #{sensor_id} back to normal\"\n  end\n\n  def emergency_shutdown(temp)\n    puts \"\ud83d\udd25 EMERGENCY SHUTDOWN: Temperature #{temp}\u00b0C!\"\n    exit(1)\n  end\n\n  def close\n    @engine.close\n  end\nend\n\n# Usage\nmonitor = TemperatureMonitor.new\n\n# Register sensors with thresholds\nmonitor.add_sensor(\"bedroom\", 25)\nmonitor.add_sensor(\"server_room\", 30)\n\n# Simulate sensor readings\nmonitor.update_reading(\"bedroom\", 28)        # =&gt; \ud83d\udea8 ALERT\nmonitor.update_reading(\"server_room\", 45)    # =&gt; \ud83d\udea8 ALERT\nmonitor.update_reading(\"bedroom\", 22)        # =&gt; \u2705 CLEAR\nmonitor.update_reading(\"server_room\", 65)    # =&gt; \ud83d\udd25 EMERGENCY SHUTDOWN\n\nmonitor.close\n</code></pre>"},{"location":"guides/getting-started/#key-concepts-learned","title":"Key Concepts Learned","text":"<p>\u2705 Rules - Define patterns and actions \u2705 Facts - Observations stored in working memory \u2705 Conditions - Patterns that match facts \u2705 Variable Binding - Connect facts across conditions using <code>:variable?</code> \u2705 Negation - Match when patterns are absent \u2705 Priorities - Control rule firing order \u2705 Persistence - Save facts to database with blackboard memory</p>"},{"location":"guides/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/getting-started/#rule-not-firing","title":"Rule Not Firing","text":"<p>Problem: Added facts but rule doesn't fire</p> <p>Checklist: 1. Did you call <code>engine.run</code>? 2. Do variable bindings match? (<code>:sensor_id?</code> must appear in both conditions) 3. Check negated conditions - is there a blocking fact? 4. Verify fact types match condition types exactly (<code>:sensor</code> vs <code>:sensors</code>)</p>"},{"location":"guides/getting-started/#performance-issues","title":"Performance Issues","text":"<p>Problem: Slow when adding many facts</p> <p>Solutions: - Order conditions from most selective to least selective - Use Redis store for high-frequency updates: <code>KBS::Blackboard::Engine.new(store: KBS::Blackboard::Persistence::RedisStore.new)</code> - Minimize negated conditions</p>"},{"location":"guides/getting-started/#facts-not-persisting","title":"Facts Not Persisting","text":"<p>Problem: Facts disappear after restart</p> <p>Check: - Using <code>KBS::Blackboard::Engine</code> (not <code>KBS::Engine</code>)? - Provided <code>db_path</code> parameter? - Called <code>engine.close</code> before exit?</p>"},{"location":"guides/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore:</p> <ul> <li>Writing Rules - Advanced rule patterns and techniques</li> <li>Pattern Matching - Deep dive into condition syntax</li> <li>Blackboard Memory - Multi-agent collaboration</li> <li>Stock Trading Example - Real-world application</li> <li>API Reference - Complete method documentation</li> </ul> <p>Questions? Open an issue at github.com/madbomber/kbs</p>"},{"location":"guides/negation/","title":"Negation","text":"<p>Negated conditions match when a pattern is absent from working memory. This guide explains negation semantics, use cases, performance implications, and common pitfalls.</p>"},{"location":"guides/negation/#negation-basics","title":"Negation Basics","text":""},{"location":"guides/negation/#syntax","title":"Syntax","text":"<pre><code>KBS::Condition.new(:alert, { sensor_id: :id? }, negated: true)\n</code></pre> <p>Semantics: Condition satisfied when NO fact matches the pattern.</p>"},{"location":"guides/negation/#simple-example","title":"Simple Example","text":"<pre><code>KBS::Rule.new(\"send_first_alert\") do |r|\n  r.conditions = [\n    # Positive: High temperature detected\n    KBS::Condition.new(:high_temp, { sensor_id: :id? }),\n\n    # Negative: No alert sent yet\n    KBS::Condition.new(:alert_sent, { sensor_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    send_alert(bindings[:id?])\n    engine.add_fact(:alert_sent, { sensor_id: bindings[:id?] })\n  end\nend\n</code></pre> <p>Behavior: - First run: <code>:high_temp</code> exists, <code>:alert_sent</code> doesn't \u2192 rule fires - Second run: Both <code>:high_temp</code> and <code>:alert_sent</code> exist \u2192 rule doesn't fire</p>"},{"location":"guides/negation/#negation-semantics","title":"Negation Semantics","text":""},{"location":"guides/negation/#open-world-assumption","title":"Open World Assumption","text":"<p>Negation means \"no matching fact exists\", not \"fact is explicitly false\":</p> <pre><code># Negated condition\nKBS::Condition.new(:error, { id: :id? }, negated: true)\n\n# Matches when:\n# - No :error fact exists with that id\n# - Working memory is empty\n# - :error facts exist but with different ids\n\n# Does NOT match when:\n# - Any :error fact with matching id exists\n</code></pre>"},{"location":"guides/negation/#variable-binding-in-negation","title":"Variable Binding in Negation","text":"<p>Variables in negated conditions still create join constraints:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n  KBS::Condition.new(:alert, { sensor_id: :id? }, negated: true)\n]\n\n# For each sensor fact:\n#   Check if NO alert exists with sensor_id == sensor's id\n#   If no such alert: rule fires\n</code></pre>"},{"location":"guides/negation/#negation-node-behavior","title":"Negation Node Behavior","text":"<pre><code>1. Token arrives with bindings { :id? =&gt; \"bedroom\" }\n2. Check alpha memory for :alert facts\n3. Filter for matches where sensor_id == \"bedroom\"\n4. If count == 0: propagate token (condition satisfied)\n5. If count &gt; 0: block token (condition not satisfied)\n</code></pre>"},{"location":"guides/negation/#use-cases","title":"Use Cases","text":""},{"location":"guides/negation/#1-guard-conditions","title":"1. Guard Conditions","text":"<p>Prevent duplicate actions:</p> <pre><code>KBS::Rule.new(\"process_order\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:order, { id: :id?, status: \"pending\" }),\n    KBS::Condition.new(:processing, { order_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Only process if not already processing\n    engine.add_fact(:processing, { order_id: bindings[:id?] })\n    process_order(bindings[:id?])\n  end\nend\n</code></pre>"},{"location":"guides/negation/#2-missing-information-detection","title":"2. Missing Information Detection","text":"<p>Alert when expected data is absent:</p> <pre><code>KBS::Rule.new(\"missing_threshold\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { id: :id? }),\n    KBS::Condition.new(:threshold, { sensor_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    alert(\"Sensor #{bindings[:id?]} has no threshold configured!\")\n  end\nend\n</code></pre>"},{"location":"guides/negation/#3-state-transitions","title":"3. State Transitions","text":"<p>Ensure prerequisites before transitioning:</p> <pre><code>KBS::Rule.new(\"activate_account\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:user, { id: :id?, email_verified: true }),\n    KBS::Condition.new(:account_active, { user_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.add_fact(:account_active, { user_id: bindings[:id?] })\n  end\nend\n</code></pre>"},{"location":"guides/negation/#4-timeout-detection","title":"4. Timeout Detection","text":"<p>Fire when response hasn't arrived:</p> <pre><code>KBS::Rule.new(\"timeout_alert\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:request, {\n      id: :req_id?,\n      created_at: :created?\n    }, predicate: lambda { |f|\n      (Time.now - f[:created_at]) &gt; 300  # 5 minutes\n    }),\n\n    KBS::Condition.new(:response, { request_id: :req_id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    alert(\"Request #{bindings[:req_id?]} timed out!\")\n  end\nend\n</code></pre>"},{"location":"guides/negation/#5-mutual-exclusion","title":"5. Mutual Exclusion","text":"<p>Ensure only one option selected:</p> <pre><code>KBS::Rule.new(\"select_default\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:user, { id: :id? }),\n    KBS::Condition.new(:preference, { user_id: :id?, theme: :theme? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # No preference set \u2192 use default\n    engine.add_fact(:preference, { user_id: bindings[:id?], theme: \"light\" })\n  end\nend\n</code></pre>"},{"location":"guides/negation/#multiple-negations","title":"Multiple Negations","text":""},{"location":"guides/negation/#conjunction-and","title":"Conjunction (AND)","text":"<p>All negations must be satisfied:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {}, negated: true),\n  KBS::Condition.new(:c, {}, negated: true)\n]\n\n# Fires when: a exists AND b doesn't exist AND c doesn't exist\n</code></pre>"},{"location":"guides/negation/#complex-negation","title":"Complex Negation","text":"<pre><code>KBS::Rule.new(\"unique_error\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:error, { type: :type? }),\n    KBS::Condition.new(:error_handled, { type: :type? }, negated: true),\n    KBS::Condition.new(:error_ignored, { type: :type? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Error exists but neither handled nor ignored\n    handle_new_error(bindings[:type?])\n  end\nend\n</code></pre>"},{"location":"guides/negation/#performance-implications","title":"Performance Implications","text":""},{"location":"guides/negation/#negation-is-expensive","title":"Negation is Expensive","text":"<p>Reason: Must check alpha memory on every token arrival.</p> <pre><code># Expensive: Large alpha memory to search\nKBS::Condition.new(:log_entry, {}, negated: true)\n# Must check all log_entry facts for each token\n\n# Better: Specific pattern\nKBS::Condition.new(:error_log, { severity: \"critical\" }, negated: true)\n# Smaller alpha memory, fewer checks\n</code></pre>"},{"location":"guides/negation/#negation-node-overhead","title":"Negation Node Overhead","text":"<pre><code>class NegationNode\n  def left_activate(token)\n    # For EVERY token:\n    matching_facts = @alpha_memory.items.select { |fact|\n      perform_join_tests(token, fact)\n    }\n\n    if matching_facts.empty?\n      propagate(token)  # No matches = condition satisfied\n    else\n      block(token)      # Matches exist = condition not satisfied\n      track_inhibitors(token, matching_facts)\n    end\n  end\nend\n</code></pre> <p>Cost: O(A \u00d7 T) where A = alpha memory size, T = join test cost</p>"},{"location":"guides/negation/#optimization-strategies","title":"Optimization Strategies","text":"<p>1. Order negations last:</p> <pre><code># Good: Positive conditions first\nr.conditions = [\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {}),\n  KBS::Condition.new(:c, {}, negated: true)  # Last\n]\n\n# Bad: Negation first\nr.conditions = [\n  KBS::Condition.new(:c, {}, negated: true),  # First\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {})\n]\n</code></pre> <p>2. Minimize negations:</p> <pre><code># Bad: Multiple negations\nr.conditions = [\n  KBS::Condition.new(:foo, {}, negated: true),\n  KBS::Condition.new(:bar, {}, negated: true),\n  KBS::Condition.new(:baz, {}, negated: true)\n]\n\n# Better: Single positive condition\n# Add fact when conditions met:\nunless foo_exists? || bar_exists? || baz_exists?\n  engine.add_fact(:conditions_clear, {})\nend\n\nr.conditions = [\n  KBS::Condition.new(:conditions_clear, {})\n]\n</code></pre> <p>3. Use specific patterns:</p> <pre><code># Expensive\nKBS::Condition.new(:event, {}, negated: true)\n\n# Cheaper\nKBS::Condition.new(:event, { type: \"error\", severity: \"critical\" }, negated: true)\n</code></pre>"},{"location":"guides/negation/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guides/negation/#1-forgetting-variable-binding","title":"1. Forgetting Variable Binding","text":"<pre><code># Bad: Variables don't connect\nr.conditions = [\n  KBS::Condition.new(:sensor, { id: :id1? }),\n  KBS::Condition.new(:alert, { id: :id2? }, negated: true)  # Different variable!\n]\n\n# Good: Consistent variables\nr.conditions = [\n  KBS::Condition.new(:sensor, { id: :id? }),\n  KBS::Condition.new(:alert, { sensor_id: :id? }, negated: true)  # Same :id?\n]\n</code></pre>"},{"location":"guides/negation/#2-infinite-loops","title":"2. Infinite Loops","text":"<pre><code># Bad: Rule fires forever\nKBS::Rule.new(\"infinite_loop\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:start, {}),\n    KBS::Condition.new(:done, {}, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # Never adds :done fact!\n    do_something()\n  end\nend\n\n# Good: Add termination fact\nKBS::Rule.new(\"runs_once\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:start, {}),\n    KBS::Condition.new(:done, {}, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    do_something()\n    engine.add_fact(:done, {})  # Prevents re-firing\n  end\nend\n</code></pre>"},{"location":"guides/negation/#3-negation-of-missing-attributes","title":"3. Negation of Missing Attributes","text":"<pre><code># Doesn't work as expected\nKBS::Condition.new(:sensor, { error: nil }, negated: true)\n\n# Better: Check for absence of error fact\nKBS::Condition.new(:sensor, { id: :id? }),\nKBS::Condition.new(:sensor_error, { sensor_id: :id? }, negated: true)\n</code></pre>"},{"location":"guides/negation/#4-over-using-negation","title":"4. Over-Using Negation","text":"<pre><code># Bad: Many negations\nKBS::Rule.new(\"many_negations\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:a, {}, negated: true),\n    KBS::Condition.new(:b, {}, negated: true),\n    KBS::Condition.new(:c, {}, negated: true),\n    KBS::Condition.new(:d, {}, negated: true)\n  ]\n  # Expensive! Checks 4 alpha memories per token\nend\n\n# Good: Refactor to positive logic\n# Add a single fact representing \"all clear\" state\n</code></pre>"},{"location":"guides/negation/#negation-patterns","title":"Negation Patterns","text":""},{"location":"guides/negation/#default-values","title":"Default Values","text":"<pre><code># If no preference, use default\nKBS::Rule.new(\"set_default_theme\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:user, { id: :id? }),\n    KBS::Condition.new(:theme_preference, { user_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.add_fact(:theme_preference, { user_id: bindings[:id?], theme: \"dark\" })\n  end\nend\n</code></pre>"},{"location":"guides/negation/#cleanup-rules","title":"Cleanup Rules","text":"<pre><code># Remove orphaned records\nKBS::Rule.new(\"cleanup_orphaned_comments\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:comment, { post_id: :pid? }),\n    KBS::Condition.new(:post, { id: :pid? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    comment = facts[0]\n    engine.remove_fact(comment)\n  end\nend\n</code></pre>"},{"location":"guides/negation/#prerequisite-checking","title":"Prerequisite Checking","text":"<pre><code># Ensure all prerequisites met\nKBS::Rule.new(\"deploy_application\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:deploy_requested, {}),\n    KBS::Condition.new(:tests_passed, {}),\n    KBS::Condition.new(:build_succeeded, {}),\n    KBS::Condition.new(:deployment_blocked, {}, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    deploy()\n  end\nend\n</code></pre>"},{"location":"guides/negation/#debugging-negations","title":"Debugging Negations","text":""},{"location":"guides/negation/#trace-negation-checks","title":"Trace Negation Checks","text":"<pre><code>class DebugNegationNode &lt; KBS::NegationNode\n  def left_activate(token)\n    matches = @alpha_memory.items.select { |f| perform_join_tests(token, f) }\n    puts \"Negation check:\"\n    puts \"  Pattern: #{@alpha_memory.pattern}\"\n    puts \"  Token: #{token.inspect}\"\n    puts \"  Matching facts: #{matches.size}\"\n    puts \"  Result: #{matches.empty? ? 'PASS' : 'BLOCK'}\"\n    super\n  end\nend\n</code></pre>"},{"location":"guides/negation/#count-inhibitors","title":"Count Inhibitors","text":"<pre><code># Check how many facts are blocking tokens\nengine.production_nodes.each do |name, node|\n  # Find negation nodes in network\n  # Count tokens blocked by each\nend\n</code></pre>"},{"location":"guides/negation/#validate-negation-logic","title":"Validate Negation Logic","text":"<pre><code># Test: Rule should fire when condition absent\nengine.add_fact(:trigger, {})\nengine.run\nassert rule_fired, \"Should fire when negated condition absent\"\n\n# Test: Rule should NOT fire when condition present\nengine.add_fact(:blocker, {})\nengine.run\nrefute rule_fired, \"Should not fire when negated condition present\"\n</code></pre>"},{"location":"guides/negation/#alternatives-to-negation","title":"Alternatives to Negation","text":"<p>Sometimes positive logic is clearer and faster:</p>"},{"location":"guides/negation/#pattern-explicit-state","title":"Pattern: Explicit State","text":"<pre><code># Instead of:\nKBS::Condition.new(:processing, { id: :id? }, negated: true)\n\n# Use explicit state:\nKBS::Condition.new(:status, { id: :id?, value: \"idle\" })\n</code></pre>"},{"location":"guides/negation/#pattern-status-flags","title":"Pattern: Status Flags","text":"<pre><code># Instead of:\nKBS::Condition.new(:error, {}, negated: true)\n\n# Use status flag:\nKBS::Condition.new(:system_status, { healthy: true })\n</code></pre>"},{"location":"guides/negation/#pattern-computed-facts","title":"Pattern: Computed Facts","text":"<pre><code># Instead of checking absence in rule:\nKBS::Condition.new(:response, { req_id: :id? }, negated: true)\n\n# Add a fact when timeout occurs:\nKBS::Rule.new(\"detect_timeout\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:request, {\n      id: :id?,\n      created_at: :time?\n    }, predicate: lambda { |f| (Time.now - f[:created_at]) &gt; 300 })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.add_fact(:timeout, { request_id: bindings[:id?] })\n  end\nend\n\n# Then use positive check:\nKBS::Condition.new(:timeout, { request_id: :id? })\n</code></pre>"},{"location":"guides/negation/#next-steps","title":"Next Steps","text":"<ul> <li>Pattern Matching - How negation fits with pattern matching</li> <li>Variable Binding - Variables in negated conditions</li> <li>Network Structure - Negation node implementation</li> <li>Performance Guide - Optimizing negation performance</li> </ul> <p>Negation is powerful but expensive. Use sparingly and order last for best performance.</p>"},{"location":"guides/pattern-matching/","title":"Pattern Matching","text":"<p>Deep dive into KBS pattern matching semantics. Learn how the RETE algorithm matches facts against condition patterns efficiently.</p>"},{"location":"guides/pattern-matching/#matching-fundamentals","title":"Matching Fundamentals","text":"<p>Pattern matching determines whether a fact satisfies a condition. A match occurs when:</p> <ol> <li>Type matches - Fact type equals condition type</li> <li>Attributes match - All pattern constraints satisfied</li> <li>Predicate passes - Custom predicate (if present) returns truthy</li> </ol> <pre><code># Condition pattern\nKBS::Condition.new(:sensor, {\n  id: \"bedroom\",\n  temp: :temp?\n})\n\n# Matching fact\nfact = { type: :sensor, id: \"bedroom\", temp: 28 }\n# \u2713 Type: :sensor == :sensor\n# \u2713 Attribute id: \"bedroom\" == \"bedroom\"\n# \u2713 Attribute temp: :temp? binds to 28\n# MATCH!\n\n# Non-matching fact\nfact = { type: :sensor, id: \"kitchen\", temp: 28 }\n# \u2713 Type: :sensor == :sensor\n# \u2717 Attribute id: \"kitchen\" != \"bedroom\"\n# NO MATCH\n</code></pre>"},{"location":"guides/pattern-matching/#type-matching","title":"Type Matching","text":"<p>Facts match only when types are identical:</p> <pre><code># Condition\nKBS::Condition.new(:stock, {})\n\n# Matches\nengine.add_fact(:stock, { symbol: \"AAPL\" })  # \u2713\n\n# Does not match\nengine.add_fact(:stocks, { symbol: \"AAPL\" })  # \u2717 (:stocks != :stock)\nengine.add_fact(\"stock\", { symbol: \"AAPL\" })  # \u2717 (String != Symbol)\n</code></pre> <p>Type comparison uses <code>==</code>, so symbols and strings never match.</p>"},{"location":"guides/pattern-matching/#literal-value-matching","title":"Literal Value Matching","text":""},{"location":"guides/pattern-matching/#exact-equality","title":"Exact Equality","text":"<pre><code># Match exact value\nKBS::Condition.new(:sensor, { id: \"bedroom\" })\n\n# Matches\n{ type: :sensor, id: \"bedroom\" }  # \u2713\n\n# Does not match\n{ type: :sensor, id: \"kitchen\" }   # \u2717\n{ type: :sensor, id: :bedroom }     # \u2717 (Symbol != String)\n</code></pre>"},{"location":"guides/pattern-matching/#multiple-literals","title":"Multiple Literals","text":"<pre><code># All must match\nKBS::Condition.new(:stock, {\n  symbol: \"AAPL\",\n  exchange: \"NASDAQ\"\n})\n\n# Matches\n{ type: :stock, symbol: \"AAPL\", exchange: \"NASDAQ\" }  # \u2713\n\n# Does not match\n{ type: :stock, symbol: \"AAPL\", exchange: \"NYSE\" }    # \u2717\n{ type: :stock, symbol: \"GOOGL\", exchange: \"NASDAQ\" } # \u2717\n</code></pre>"},{"location":"guides/pattern-matching/#nil-values","title":"Nil Values","text":"<pre><code># Match nil explicitly\nKBS::Condition.new(:sensor, { error: nil })\n\n# Matches\n{ type: :sensor, error: nil }  # \u2713\n\n# Does not match\n{ type: :sensor }  # \u2717 (missing key != nil)\n{ type: :sensor, error: false }  # \u2717 (false != nil)\n</code></pre>"},{"location":"guides/pattern-matching/#variable-binding","title":"Variable Binding","text":""},{"location":"guides/pattern-matching/#basic-binding","title":"Basic Binding","text":"<p>Variables start with <code>?</code> and bind to fact attribute values:</p> <pre><code># Condition with variable\nKBS::Condition.new(:sensor, { temp: :t? })\n\n# Matching fact\nfact = { type: :sensor, temp: 28 }\n\n# After matching:\nbindings = { :t? =&gt; 28 }\n</code></pre>"},{"location":"guides/pattern-matching/#multiple-bindings","title":"Multiple Bindings","text":"<pre><code>KBS::Condition.new(:stock, {\n  symbol: :sym?,\n  price: :p?,\n  volume: :v?\n})\n\n# Fact\n{ type: :stock, symbol: \"AAPL\", price: 150, volume: 1000 }\n\n# Bindings\n{\n  :sym? =&gt; \"AAPL\",\n  :p? =&gt; 150,\n  :v? =&gt; 1000\n}\n</code></pre>"},{"location":"guides/pattern-matching/#mixed-literals-and-variables","title":"Mixed Literals and Variables","text":"<pre><code>KBS::Condition.new(:sensor, {\n  id: \"bedroom\",     # Literal (must equal \"bedroom\")\n  temp: :temp?       # Variable (binds to any value)\n})\n\n# Matches only bedroom sensor, binds temp\n{ type: :sensor, id: \"bedroom\", temp: 28 }  # \u2713 binds :temp? =&gt; 28\n{ type: :sensor, id: \"kitchen\", temp: 28 }  # \u2717 id doesn't match\n</code></pre>"},{"location":"guides/pattern-matching/#cross-condition-binding","title":"Cross-Condition Binding","text":"<p>Variables create join constraints across conditions:</p> <pre><code>r.conditions = [\n  # Condition 1: Binds :sym?\n  KBS::Condition.new(:stock, { symbol: :sym?, price: :price? }),\n\n  # Condition 2: Tests :sym? (must be same value)\n  KBS::Condition.new(:watchlist, { symbol: :sym? })\n]\n\n# Facts\nstock1 = { type: :stock, symbol: \"AAPL\", price: 150 }\nstock2 = { type: :stock, symbol: \"GOOGL\", price: 2800 }\nwatchlist = { type: :watchlist, symbol: \"AAPL\" }\n\n# Matches\n# stock1 + watchlist: \u2713 (:sym? = \"AAPL\" in both)\n\n# Does not match\n# stock2 + watchlist: \u2717 (:sym? = \"GOOGL\" in stock, \"AAPL\" in watchlist)\n</code></pre>"},{"location":"guides/pattern-matching/#binding-semantics","title":"Binding Semantics","text":"<ol> <li>First occurrence binds - Variable's first use establishes the value</li> <li>Subsequent uses test - Later uses check equality</li> <li>Scope is per-rule - Variables don't cross rules</li> </ol> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, { x: :v? }),  # Binds :v?\n  KBS::Condition.new(:b, { y: :v? }),  # Tests :v? (must equal)\n  KBS::Condition.new(:c, { z: :v? })   # Tests :v? (must equal)\n]\n\n# All three facts must have same value for x, y, z\n</code></pre>"},{"location":"guides/pattern-matching/#empty-patterns","title":"Empty Patterns","text":""},{"location":"guides/pattern-matching/#match-any","title":"Match Any","text":"<p>Empty pattern <code>{}</code> matches all facts of that type:</p> <pre><code># Matches ALL sensor facts\nKBS::Condition.new(:sensor, {})\n\n# Matches these\n{ type: :sensor, id: \"bedroom\", temp: 28 }\n{ type: :sensor, id: \"kitchen\", temp: 22 }\n{ type: :sensor, foo: \"bar\", baz: 123 }\n</code></pre>"},{"location":"guides/pattern-matching/#selectivity-warning","title":"Selectivity Warning","text":"<p>Empty patterns have minimal selectivity:</p> <pre><code># Bad: Very unselective (matches thousands)\nr.conditions = [\n  KBS::Condition.new(:log_entry, {}),     # Matches 10,000 facts\n  KBS::Condition.new(:error, { id: 1 })   # Matches 1 fact\n]\n# Creates 10,000 partial matches!\n\n# Good: Specific first\nr.conditions = [\n  KBS::Condition.new(:error, { id: 1 }),    # Matches 1 fact\n  KBS::Condition.new(:log_entry, {})        # Joins with 10,000\n]\n# Creates 1 partial match\n</code></pre>"},{"location":"guides/pattern-matching/#custom-predicates","title":"Custom Predicates","text":"<p>Predicates add complex matching beyond equality:</p>"},{"location":"guides/pattern-matching/#basic-predicate","title":"Basic Predicate","text":"<pre><code>KBS::Condition.new(:stock, { price: :price? },\n  predicate: lambda { |fact|\n    fact[:price] &gt; 100\n  }\n)\n\n# Matches\n{ type: :stock, price: 150 }  # \u2713 (150 &gt; 100)\n\n# Does not match\n{ type: :stock, price: 50 }   # \u2717 (50 &lt;= 100)\n</code></pre>"},{"location":"guides/pattern-matching/#predicate-execution-order","title":"Predicate Execution Order","text":"<ol> <li>Type check</li> <li>Attribute equality checks</li> <li>Variable binding</li> <li>Predicate evaluation (last)</li> </ol> <pre><code>KBS::Condition.new(:sensor, { id: \"bedroom\", temp: :temp? },\n  predicate: lambda { |fact|\n    fact[:temp].between?(20, 30)\n  }\n)\n\n# Evaluation order:\n# 1. type == :sensor? \u2713\n# 2. id == \"bedroom\"? \u2713\n# 3. temp exists? \u2713 \u2192 bind :temp?\n# 4. predicate(fact)? \u2713\n# MATCH!\n</code></pre>"},{"location":"guides/pattern-matching/#predicate-limitations","title":"Predicate Limitations","text":"<p>Predicates disable network sharing:</p> <pre><code># Rule 1\nKBS::Condition.new(:stock, {},\n  predicate: lambda { |f| f[:price] &gt; 100 }\n)\n\n# Rule 2 (different predicate)\nKBS::Condition.new(:stock, {},\n  predicate: lambda { |f| f[:price] &lt; 50 }\n)\n\n# These create SEPARATE alpha memories\n# Cannot share pattern matching computation\n</code></pre> <p>Use pattern matching when possible:</p> <pre><code># Bad: Predicate for simple equality\nKBS::Condition.new(:stock, {},\n  predicate: lambda { |f| f[:symbol] == \"AAPL\" }\n)\n\n# Good: Pattern matching\nKBS::Condition.new(:stock, { symbol: \"AAPL\" })\n</code></pre>"},{"location":"guides/pattern-matching/#matching-strategies","title":"Matching Strategies","text":""},{"location":"guides/pattern-matching/#conjunctive-matching-and","title":"Conjunctive Matching (AND)","text":"<p>All conditions must match:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {}),\n  KBS::Condition.new(:c, {})\n]\n\n# Rule fires when:\n# a_fact exists AND b_fact exists AND c_fact exists\n</code></pre>"},{"location":"guides/pattern-matching/#disjunctive-matching-or","title":"Disjunctive Matching (OR)","text":"<p>Use multiple rules:</p> <pre><code># Fire when A OR B\nrule1 = KBS::Rule.new(\"fire_on_a\") do |r|\n  r.conditions = [KBS::Condition.new(:a, {})]\n  r.action = lambda { |f, b| common_action }\nend\n\nrule2 = KBS::Rule.new(\"fire_on_b\") do |r|\n  r.conditions = [KBS::Condition.new(:b, {})]\n  r.action = lambda { |f, b| common_action }\nend\n</code></pre> <p>Or use predicates:</p> <pre><code>KBS::Condition.new(:event, {},\n  predicate: lambda { |f|\n    f[:type] == \"a\" || f[:type] == \"b\"\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#negation-not","title":"Negation (NOT)","text":"<p>Match when pattern is absent:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, {}),\n  KBS::Condition.new(:b, {}, negated: true)  # NOT B\n]\n\n# Fires when: a_fact exists AND no b_fact exists\n</code></pre> <p>See Negation Guide for details.</p>"},{"location":"guides/pattern-matching/#pattern-matching-examples","title":"Pattern Matching Examples","text":""},{"location":"guides/pattern-matching/#range-checks","title":"Range Checks","text":"<pre><code># Temperature in range 20-30\nKBS::Condition.new(:sensor, { temp: :temp? },\n  predicate: lambda { |f|\n    f[:temp].between?(20, 30)\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#string-matching","title":"String Matching","text":"<pre><code># Symbol starts with \"TECH\"\nKBS::Condition.new(:stock, { symbol: :sym? },\n  predicate: lambda { |f|\n    f[:symbol].start_with?(\"TECH\")\n  }\n)\n\n# Regex match\nKBS::Condition.new(:log, { message: :msg? },\n  predicate: lambda { |f|\n    f[:message] =~ /ERROR|FATAL/\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#collection-membership","title":"Collection Membership","text":"<pre><code># Status is one of pending, processing, approved\nKBS::Condition.new(:order, { status: :status? },\n  predicate: lambda { |f|\n    %w[pending processing approved].include?(f[:status])\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#temporal-conditions","title":"Temporal Conditions","text":"<pre><code># Reading older than 5 minutes\nKBS::Condition.new(:sensor, { timestamp: :time? },\n  predicate: lambda { |f|\n    (Time.now - f[:timestamp]) &gt; 300\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#computed-values","title":"Computed Values","text":"<pre><code># Price changed more than 10%\nKBS::Condition.new(:stock, {\n  symbol: :sym?,\n  current_price: :curr?,\n  previous_price: :prev?\n}, predicate: lambda { |f|\n  change = ((f[:current_price] - f[:previous_price]).abs / f[:previous_price].to_f)\n  change &gt; 0.10\n})\n</code></pre>"},{"location":"guides/pattern-matching/#nested-attribute-access","title":"Nested Attribute Access","text":"<pre><code># Access nested hash\nKBS::Condition.new(:event, { data: :data? },\n  predicate: lambda { |f|\n    f[:data].is_a?(Hash) &amp;&amp;\n    f[:data][:severity] == \"critical\"\n  }\n)\n</code></pre>"},{"location":"guides/pattern-matching/#performance-implications","title":"Performance Implications","text":""},{"location":"guides/pattern-matching/#alpha-network","title":"Alpha Network","text":"<p>Facts are tested against patterns in alpha memory:</p> <pre><code># Pattern\n{ type: :stock, symbol: \"AAPL\" }\n\n# 10,000 facts tested\n# Only matching facts stored in alpha memory\n# O(N) where N = total facts\n</code></pre>"},{"location":"guides/pattern-matching/#join-network","title":"Join Network","text":"<p>Partial matches combine in beta network:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, {}),  # 100 matches\n  KBS::Condition.new(:b, {})   # 200 matches\n]\n\n# Worst case: 100 \u00d7 200 = 20,000 join tests\n# Actual: Usually much fewer (variable bindings reduce combinations)\n</code></pre>"},{"location":"guides/pattern-matching/#optimization-strategies","title":"Optimization Strategies","text":"<p>1. Specific patterns first:</p> <pre><code># Good\nr.conditions = [\n  KBS::Condition.new(:critical, {}),  # 1 match\n  KBS::Condition.new(:sensor, {})     # 1000 matches\n]\n# Beta memory size: 1\n\n# Bad\nr.conditions = [\n  KBS::Condition.new(:sensor, {}),     # 1000 matches\n  KBS::Condition.new(:critical, {})    # 1 match\n]\n# Beta memory size: 1000\n</code></pre> <p>2. Use literals over predicates:</p> <pre><code># Good: O(1) hash lookup\nKBS::Condition.new(:stock, { exchange: \"NASDAQ\" })\n\n# Bad: O(N) linear scan\nKBS::Condition.new(:stock, {},\n  predicate: lambda { |f| f[:exchange] == \"NASDAQ\" }\n)\n</code></pre> <p>3. Minimize empty patterns:</p> <pre><code># Expensive\nKBS::Condition.new(:log_entry, {})  # Matches everything\n\n# Better\nKBS::Condition.new(:log_entry, { level: \"ERROR\" })  # More selective\n</code></pre>"},{"location":"guides/pattern-matching/#debugging-patterns","title":"Debugging Patterns","text":""},{"location":"guides/pattern-matching/#trace-matching","title":"Trace Matching","text":"<pre><code>class DebugCondition &lt; KBS::Condition\n  def matches?(fact)\n    result = super\n    puts \"#{pattern} vs #{fact.attributes}: #{result}\"\n    result\n  end\nend\n\n# Use for debugging\nr.conditions = [\n  DebugCondition.new(:sensor, { id: \"bedroom\" })\n]\n</code></pre>"},{"location":"guides/pattern-matching/#inspect-alpha-memories","title":"Inspect Alpha Memories","text":"<pre><code>engine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern: #{pattern}\"\n  puts \"  Matches: #{memory.items.size}\"\n  memory.items.each do |fact|\n    puts \"    #{fact.attributes}\"\n  end\nend\n</code></pre>"},{"location":"guides/pattern-matching/#test-patterns-in-isolation","title":"Test Patterns in Isolation","text":"<pre><code>condition = KBS::Condition.new(:sensor, { temp: :t? },\n  predicate: lambda { |f| f[:temp] &gt; 30 }\n)\n\nfact = KBS::Fact.new(:sensor, { temp: 35 })\n\n# Manually test\ncondition.matches?(fact)  # =&gt; true\n</code></pre>"},{"location":"guides/pattern-matching/#next-steps","title":"Next Steps","text":"<ul> <li>Variable Binding - Join tests and binding extraction</li> <li>Negation - Negated condition behavior</li> <li>RETE Algorithm - How matching works internally</li> <li>Performance Guide - Optimization techniques</li> </ul> <p>Pattern matching is the heart of the RETE algorithm. Efficient patterns = fast rule systems.</p>"},{"location":"guides/persistence/","title":"Persistence Options","text":"<p>KBS offers multiple storage backends for persistent facts. This guide helps you choose and configure the right storage for your use case.</p>"},{"location":"guides/persistence/#storage-backends","title":"Storage Backends","text":""},{"location":"guides/persistence/#1-no-persistence-default","title":"1. No Persistence (Default)","text":"<p>Transient in-memory facts using <code>KBS::Engine</code>:</p> <pre><code>engine = KBS::Engine.new\n\n# Facts exist only in memory\nengine.add_fact(:sensor, { temp: 28 })\n\n# Lost on exit\n</code></pre> <p>When to use: - Prototyping - Short-lived processes - Pure computation (no state retention needed) - Testing</p> <p>Pros: - \u2705 Fastest (no I/O) - \u2705 Zero configuration - \u2705 Simple</p> <p>Cons: - \u274c No persistence - \u274c Lost on crash - \u274c No audit trail</p>"},{"location":"guides/persistence/#2-sqlite-default-persistent","title":"2. SQLite (Default Persistent)","text":"<p>Embedded database using <code>KBS::Blackboard::Engine</code>:</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n\nengine.add_fact(:sensor, { temp: 28 })\nengine.close\n\n# Next run\nengine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\nputs engine.facts.size  # =&gt; 1 (persisted)\n</code></pre> <p>When to use: - Single-process applications - Moderate fact volumes (&lt; 1M facts) - ACID transaction requirements - Complete audit trails - No external dependencies</p> <p>Pros: - \u2705 Embedded (no server) - \u2705 ACID guarantees - \u2705 Durable - \u2705 Full audit trail - \u2705 SQL queries available</p> <p>Cons: - \u274c Slower than Redis - \u274c Single writer - \u274c Not distributed</p> <p>Configuration:</p> <pre><code>engine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',          # Database file path\n  journal_mode: 'WAL'        # WAL mode for better concurrency\n)\n</code></pre>"},{"location":"guides/persistence/#3-redis-high-performance","title":"3. Redis (High Performance)","text":"<p>In-memory data structure store:</p> <pre><code>require 'kbs/blackboard/persistence/redis_store'\n\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>When to use: - High-frequency updates (&gt; 1000 writes/sec) - Real-time systems (trading, IoT) - Distributed systems (multiple engines) - Large fact volumes - Speed is critical</p> <p>Pros: - \u2705 100x faster than SQLite - \u2705 Distributed (multiple engines share data) - \u2705 Perfect for real-time - \u2705 Scalable</p> <p>Cons: - \u274c Requires Redis server - \u274c Volatile by default (enable RDB/AOF for persistence) - \u274c No ACID across keys - \u274c Less audit trail</p> <p>Configuration:</p> <pre><code>store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  namespace: 'kbs',              # Key prefix\n  ttl: 86400                     # Expire facts after 24h (optional)\n)\n</code></pre> <p>Redis Persistence Options:</p> <pre><code># In redis.conf:\n\n# RDB: Point-in-time snapshots\nsave 900 1      # Save after 900s if 1 key changed\nsave 300 10     # Save after 300s if 10 keys changed\n\n# AOF: Append-only file (durability)\nappendonly yes\nappendfsync everysec  # Sync to disk every second\n</code></pre>"},{"location":"guides/persistence/#4-hybrid-best-of-both","title":"4. Hybrid (Best of Both)","text":"<p>Combines Redis (speed) with SQLite (durability):</p> <pre><code>require 'kbs/blackboard/persistence/hybrid_store'\n\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\n\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>How it works: - Facts: Stored in Redis (fast access) - Audit log: Written to SQLite (durable history) - Messages: Redis sorted sets (fast priority queue)</p> <p>When to use: - Production systems requiring both speed and auditing - Regulatory compliance (need audit trail) - High-frequency updates with history requirements - Distributed systems needing accountability</p> <p>Pros: - \u2705 Fast fact access (Redis) - \u2705 Durable audit trail (SQLite) - \u2705 Best of both worlds - \u2705 Can reconstruct from audit log</p> <p>Cons: - \u274c Requires both Redis and SQLite - \u274c More complex setup - \u274c Slightly slower writes (dual write)</p> <p>Configuration:</p> <pre><code>store = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db',\n  audit_facts: true,        # Log fact changes to SQLite\n  audit_rules: true         # Log rule firings to SQLite\n)\n</code></pre>"},{"location":"guides/persistence/#choosing-a-backend","title":"Choosing a Backend","text":""},{"location":"guides/persistence/#decision-tree","title":"Decision Tree","text":"<pre><code>Need persistence?\n\u251c\u2500 No \u2192 KBS::Engine (default)\n\u2514\u2500 Yes\n   \u2502\n   \u251c\u2500 Need speed &gt; 1000 ops/sec?\n   \u2502  \u251c\u2500 Yes\n   \u2502  \u2502  \u251c\u2500 Need audit trail?\n   \u2502  \u2502  \u2502  \u251c\u2500 Yes \u2192 Hybrid Store\n   \u2502  \u2502  \u2502  \u2514\u2500 No \u2192 Redis Store\n   \u2502  \u2502  \u2514\u2500 No \u2192 Redis Store\n   \u2502  \u2502\n   \u2502  \u2514\u2500 No\n   \u2502     \u251c\u2500 Need distributed access?\n   \u2502     \u2502  \u2514\u2500 Yes \u2192 Redis Store\n   \u2502     \u2514\u2500 No \u2192 SQLite Store\n   \u2502\n   \u2514\u2500 Single machine, moderate load?\n      \u2514\u2500 SQLite Store\n</code></pre>"},{"location":"guides/persistence/#by-use-case","title":"By Use Case","text":"<p>IoT / Real-Time Sensors: <pre><code># High frequency, need speed\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\n</code></pre></p> <p>Trading Systems: <pre><code># Speed + audit trail for compliance\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'trading_audit.db'\n)\n</code></pre></p> <p>Expert Systems: <pre><code># Moderate load, need durability\nengine = KBS::Blackboard::Engine.new(db_path: 'expert.db')\n</code></pre></p> <p>Development / Testing: <pre><code># No persistence needed\nengine = KBS::Engine.new\n</code></pre></p>"},{"location":"guides/persistence/#migration-between-backends","title":"Migration Between Backends","text":""},{"location":"guides/persistence/#sqlite-redis","title":"SQLite \u2192 Redis","text":"<pre><code># 1. Load from SQLite\nsqlite_engine = KBS::Blackboard::Engine.new(db_path: 'old.db')\nfacts = sqlite_engine.facts\n\n# 2. Save to Redis\nredis_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nredis_engine = KBS::Blackboard::Engine.new(store: redis_store)\n\nfacts.each do |fact|\n  redis_engine.add_fact(fact.type, fact.attributes)\nend\n</code></pre>"},{"location":"guides/persistence/#redis-sqlite","title":"Redis \u2192 SQLite","text":"<pre><code># 1. Load from Redis\nredis_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nredis_engine = KBS::Blackboard::Engine.new(store: redis_store)\nfacts = redis_engine.facts\n\n# 2. Save to SQLite\nsqlite_engine = KBS::Blackboard::Engine.new(db_path: 'new.db')\n\nfacts.each do |fact|\n  sqlite_engine.add_fact(fact.type, fact.attributes)\nend\n\nsqlite_engine.close\n</code></pre>"},{"location":"guides/persistence/#performance-comparison","title":"Performance Comparison","text":""},{"location":"guides/persistence/#write-performance","title":"Write Performance","text":"<pre><code>require 'benchmark'\n\n# SQLite\nsqlite_engine = KBS::Blackboard::Engine.new(db_path: 'perf.db')\nBenchmark.bm do |x|\n  x.report(\"SQLite writes:\") do\n    10_000.times { |i| sqlite_engine.add_fact(:test, { value: i }) }\n  end\nend\n# ~5,000 ops/sec\n\n# Redis\nredis_store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nredis_engine = KBS::Blackboard::Engine.new(store: redis_store)\nBenchmark.bm do |x|\n  x.report(\"Redis writes:\") do\n    10_000.times { |i| redis_engine.add_fact(:test, { value: i }) }\n  end\nend\n# ~50,000 ops/sec (10x faster)\n</code></pre>"},{"location":"guides/persistence/#read-performance","title":"Read Performance","text":"<pre><code># SQLite\nBenchmark.bm do |x|\n  x.report(\"SQLite reads:\") do\n    10_000.times { sqlite_engine.facts }\n  end\nend\n# ~10,000 ops/sec\n\n# Redis\nBenchmark.bm do |x|\n  x.report(\"Redis reads:\") do\n    10_000.times { redis_engine.facts }\n  end\nend\n# ~100,000 ops/sec (10x faster)\n</code></pre>"},{"location":"guides/persistence/#custom-persistence","title":"Custom Persistence","text":"<p>Implement your own backend by subclassing <code>KBS::Blackboard::Persistence::Store</code>:</p> <pre><code>class PostgresStore &lt; KBS::Blackboard::Persistence::Store\n  def save_fact(fact)\n    # Insert into PostgreSQL\n  end\n\n  def load_facts(type = nil)\n    # Query from PostgreSQL\n  end\n\n  def delete_fact(id)\n    # Delete from PostgreSQL\n  end\n\n  def save_message(topic, message, priority)\n    # Store message\n  end\n\n  def pop_message(topic)\n    # Retrieve highest priority message\n  end\n\n  def log_fact_change(operation, fact)\n    # Audit logging\n  end\n\n  def fact_history(fact_id)\n    # Get change history\n  end\nend\n\n# Use custom store\nstore = PostgresStore.new(connection_string: \"...\")\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>See Custom Persistence for details.</p>"},{"location":"guides/persistence/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"guides/persistence/#sqlite","title":"SQLite","text":"<pre><code># Enable WAL mode for better concurrency\nengine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',\n  journal_mode: 'WAL',\n  synchronous: 'NORMAL',  # Trade some durability for speed\n  cache_size: -64000      # 64MB cache\n)\n</code></pre>"},{"location":"guides/persistence/#redis","title":"Redis","text":"<pre><code># Connection pooling for high concurrency\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  pool_size: 10,          # Connection pool size\n  pool_timeout: 5         # Timeout in seconds\n)\n</code></pre>"},{"location":"guides/persistence/#hybrid","title":"Hybrid","text":"<pre><code># Balance between speed and durability\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db',\n  batch_audit_writes: true,   # Batch SQLite writes\n  audit_batch_size: 100       # Flush every 100 changes\n)\n</code></pre>"},{"location":"guides/persistence/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/persistence/#sqlite-database-locked","title":"SQLite Database Locked","text":"<pre><code># Increase busy timeout\nengine = KBS::Blackboard::Engine.new(\n  db_path: 'kb.db',\n  busy_timeout: 5000  # Wait up to 5 seconds\n)\n</code></pre>"},{"location":"guides/persistence/#redis-connection-issues","title":"Redis Connection Issues","text":"<pre><code># Enable retry logic\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  reconnect_attempts: 3,\n  reconnect_delay: 1.0\n)\n</code></pre>"},{"location":"guides/persistence/#hybrid-sync-issues","title":"Hybrid Sync Issues","text":"<pre><code># Force synchronous audit writes\nstore = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db',\n  sync_audit_writes: true  # Don't batch, write immediately\n)\n</code></pre>"},{"location":"guides/persistence/#next-steps","title":"Next Steps","text":"<ul> <li>Blackboard Memory - Using persistent blackboard</li> <li>Custom Persistence - Implementing custom stores</li> <li>Performance Guide - Optimizing storage performance</li> <li>API Reference - Complete blackboard API</li> </ul> <p>Choose your backend based on speed, durability, and distribution requirements.</p>"},{"location":"guides/variable-binding/","title":"Variable Binding","text":"<p>Variables connect facts across conditions, enabling join constraints in the RETE network. This guide explains how binding works, join tests, and optimization strategies.</p>"},{"location":"guides/variable-binding/#variable-syntax","title":"Variable Syntax","text":"<p>Variables start with <code>?</code> and are symbols:</p> <pre><code>:temp?      # Variable named \"temp\"\n:sensor_id? # Variable named \"sensor_id\"\n:x?         # Variable named \"x\"\n</code></pre> <p>Naming conventions: - Use lowercase with underscores - Be descriptive - Match domain terminology</p>"},{"location":"guides/variable-binding/#basic-binding","title":"Basic Binding","text":""},{"location":"guides/variable-binding/#single-variable","title":"Single Variable","text":"<pre><code>KBS::Condition.new(:sensor, { temp: :t? })\n\n# Matches fact:\n{ type: :sensor, temp: 28 }\n\n# Creates binding:\n{ :t? =&gt; 28 }\n</code></pre>"},{"location":"guides/variable-binding/#multiple-variables","title":"Multiple Variables","text":"<pre><code>KBS::Condition.new(:stock, {\n  symbol: :sym?,\n  price: :price?,\n  volume: :vol?\n})\n\n# Matches:\n{ type: :stock, symbol: \"AAPL\", price: 150, volume: 1000 }\n\n# Bindings:\n{\n  :sym? =&gt; \"AAPL\",\n  :price? =&gt; 150,\n  :vol? =&gt; 1000\n}\n</code></pre>"},{"location":"guides/variable-binding/#cross-condition-binding","title":"Cross-Condition Binding","text":""},{"location":"guides/variable-binding/#join-constraints","title":"Join Constraints","text":"<p>Variables with the same name create equality constraints:</p> <pre><code>r.conditions = [\n  # Condition 1: Binds :id? to sensor's id\n  KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n\n  # Condition 2: Must match same :id?\n  KBS::Condition.new(:threshold, { sensor_id: :id?, max: :max? })\n]\n</code></pre> <p>Join test: <pre><code>sensor[:id] == threshold[:sensor_id]\n</code></pre></p>"},{"location":"guides/variable-binding/#multiple-joins","title":"Multiple Joins","text":"<pre><code>r.conditions = [\n  KBS::Condition.new(:a, { x: :v1?, y: :v2? }),\n  KBS::Condition.new(:b, { p: :v1?, q: :v3? }),\n  KBS::Condition.new(:c, { m: :v2?, n: :v3? })\n]\n\n# Join tests:\n# a[:x] == b[:p]  (via :v1?)\n# a[:y] == c[:m]  (via :v2?)\n# b[:q] == c[:n]  (via :v3?)\n</code></pre>"},{"location":"guides/variable-binding/#visual-example","title":"Visual Example","text":"<pre><code>Condition 1: stock(symbol: :sym?, price: :p?)\nCondition 2: watchlist(symbol: :sym?)\nCondition 3: alert_config(symbol: :sym?, threshold: :t?)\n\nVariable :sym? creates two joins:\n\u251c\u2500 stock[:symbol] == watchlist[:symbol]\n\u2514\u2500 stock[:symbol] == alert_config[:symbol]\n</code></pre>"},{"location":"guides/variable-binding/#binding-lifecycle","title":"Binding Lifecycle","text":""},{"location":"guides/variable-binding/#1-first-occurrence-bind","title":"1. First Occurrence: Bind","text":"<pre><code># First condition with :sym?\nKBS::Condition.new(:stock, { symbol: :sym? })\n\n# Fact matches\n{ type: :stock, symbol: \"AAPL\" }\n\n# Binding created:\n{ :sym? =&gt; \"AAPL\" }\n</code></pre>"},{"location":"guides/variable-binding/#2-subsequent-occurrences-test","title":"2. Subsequent Occurrences: Test","text":"<pre><code># Second condition with :sym?\nKBS::Condition.new(:watchlist, { symbol: :sym? })\n\n# Checks if symbol == \"AAPL\" (from previous binding)\n# Matches:\n{ type: :watchlist, symbol: \"AAPL\" }  # \u2713\n\n# Does not match:\n{ type: :watchlist, symbol: \"GOOGL\" }  # \u2717\n</code></pre>"},{"location":"guides/variable-binding/#3-action-access","title":"3. Action: Access","text":"<pre><code>r.action = lambda do |facts, bindings|\n  # Access bound variables\n  symbol = bindings[:sym?]\n  price = bindings[:p?]\n\n  puts \"#{symbol} at $#{price}\"\nend\n</code></pre>"},{"location":"guides/variable-binding/#join-tests","title":"Join Tests","text":""},{"location":"guides/variable-binding/#what-is-a-join-test","title":"What is a Join Test?","text":"<p>A join test verifies that variable values match across facts:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, { x: :v? }),\n  KBS::Condition.new(:b, { y: :v? })\n]\n\n# Join test structure:\n{\n  token_field_index: 0,     # Index of fact in token (first condition)\n  token_field: :x,          # Attribute name in first fact\n  fact_field: :y,           # Attribute name in new fact\n  operation: :eq            # Equality test\n}\n</code></pre>"},{"location":"guides/variable-binding/#join-test-execution","title":"Join Test Execution","text":"<pre><code>def perform_join_test(token, new_fact, test)\n  # Get value from token (previous facts)\n  token_fact = token.facts[test[:token_field_index]]\n  token_value = token_fact[test[:token_field]]\n\n  # Get value from new fact\n  fact_value = new_fact[test[:fact_field]]\n\n  # Test equality\n  token_value == fact_value\nend\n</code></pre>"},{"location":"guides/variable-binding/#example-execution","title":"Example Execution","text":"<pre><code># Rule\nr.conditions = [\n  KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n  KBS::Condition.new(:threshold, { sensor_id: :id?, max: :max? })\n]\n\n# Facts\nsensor = { type: :sensor, id: \"bedroom\", temp: 28 }\nthreshold = { type: :threshold, sensor_id: \"bedroom\", max: 25 }\n\n# Join execution:\n# 1. sensor matches \u2192 token created\ntoken = Token.new(parent: root, fact: sensor)\n# Bindings: { :id? =&gt; \"bedroom\", :temp? =&gt; 28 }\n\n# 2. threshold tested against token\ntest = {\n  token_field_index: 0,       # sensor is first fact\n  token_field: :id,           # sensor's id attribute\n  fact_field: :sensor_id,     # threshold's sensor_id attribute\n  operation: :eq\n}\n\n# 3. Perform join\ntoken_value = sensor[:id]              # \"bedroom\"\nfact_value = threshold[:sensor_id]     # \"bedroom\"\nresult = token_value == fact_value     # true\n# \u2713 Join succeeds \u2192 new token created\n</code></pre>"},{"location":"guides/variable-binding/#binding-strategies","title":"Binding Strategies","text":""},{"location":"guides/variable-binding/#pattern-1-primary-key-join","title":"Pattern 1: Primary Key Join","text":"<p>Connect facts via identifier:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:order, {\n    id: :order_id?,\n    status: \"pending\"\n  }),\n\n  KBS::Condition.new(:payment, {\n    order_id: :order_id?,\n    verified: true\n  })\n]\n\n# Matches orders with verified payments\n</code></pre>"},{"location":"guides/variable-binding/#pattern-2-multi-attribute-join","title":"Pattern 2: Multi-Attribute Join","text":"<p>Join on multiple fields:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:trade, {\n    symbol: :sym?,\n    date: :date?,\n    volume: :vol?\n  }),\n\n  KBS::Condition.new(:settlement, {\n    symbol: :sym?,\n    trade_date: :date?\n  })\n]\n\n# Joins on both symbol AND date\n</code></pre>"},{"location":"guides/variable-binding/#pattern-3-transitive-binding","title":"Pattern 3: Transitive Binding","text":"<p>Chain bindings across three+ conditions:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:a, { id: :x? }),\n  KBS::Condition.new(:b, { a_id: :x?, id: :y? }),\n  KBS::Condition.new(:c, { b_id: :y? })\n]\n\n# a[:id] == b[:a_id]\n# b[:id] == c[:b_id]\n# Creates chain: a \u2192 b \u2192 c\n</code></pre>"},{"location":"guides/variable-binding/#pattern-4-fan-out-join","title":"Pattern 4: Fan-Out Join","text":"<p>One fact joins with multiple:</p> <pre><code>r.conditions = [\n  KBS::Condition.new(:sensor, { id: :id?, temp: :t? }),\n  KBS::Condition.new(:threshold, { sensor_id: :id? }),\n  KBS::Condition.new(:alert_config, { sensor_id: :id? }),\n  KBS::Condition.new(:location, { sensor_id: :id? })\n]\n\n# All join on :id?\n</code></pre>"},{"location":"guides/variable-binding/#performance-implications","title":"Performance Implications","text":""},{"location":"guides/variable-binding/#join-cardinality","title":"Join Cardinality","text":"<pre><code># Condition 1: 100 sensor facts\nKBS::Condition.new(:sensor, { temp: :t? })\n\n# Condition 2: 200 threshold facts\nKBS::Condition.new(:threshold, { max: :m? })\n\n# Without variable binding:\n# Potential matches: 100 \u00d7 200 = 20,000\n\n# With variable binding:\nKBS::Condition.new(:sensor, { id: :id?, temp: :t? })\nKBS::Condition.new(:threshold, { sensor_id: :id?, max: :m? })\n\n# Actual matches: ~100 (1:1 relationship)\n</code></pre> <p>Variable bindings dramatically reduce join size.</p>"},{"location":"guides/variable-binding/#beta-memory-size","title":"Beta Memory Size","text":"<pre><code># Bad: No shared variables\nr.conditions = [\n  KBS::Condition.new(:a, {}),  # 1000 facts\n  KBS::Condition.new(:b, {}),  # 1000 facts\n  KBS::Condition.new(:c, {})   # 1000 facts\n]\n# Beta memory: 1000 \u00d7 1000 \u00d7 1000 = 1,000,000,000 tokens!\n\n# Good: Shared variables\nr.conditions = [\n  KBS::Condition.new(:a, { id: :id? }),\n  KBS::Condition.new(:b, { a_id: :id? }),\n  KBS::Condition.new(:c, { a_id: :id? })\n]\n# Beta memory: ~1000 tokens (assuming 1:1:1 relationship)\n</code></pre>"},{"location":"guides/variable-binding/#optimization-tips","title":"Optimization Tips","text":"<p>1. Use specific bindings:</p> <pre><code># Good: Binds sensor to specific readings\nKBS::Condition.new(:sensor, { id: :id? })\nKBS::Condition.new(:reading, { sensor_id: :id? })\n\n# Bad: No binding (cross product)\nKBS::Condition.new(:sensor, {})\nKBS::Condition.new(:reading, {})\n</code></pre> <p>2. Order by selectivity:</p> <pre><code># Good: Specific first\nr.conditions = [\n  KBS::Condition.new(:critical_alert, { id: :id? }),  # 1 fact\n  KBS::Condition.new(:sensor, { id: :id? })          # 1000 facts\n]\n# Beta memory: 1 token\n\n# Bad: General first\nr.conditions = [\n  KBS::Condition.new(:sensor, { id: :id? }),          # 1000 facts\n  KBS::Condition.new(:critical_alert, { id: :id? })   # 1 fact\n]\n# Beta memory: 1000 tokens\n</code></pre> <p>3. Minimize cross products:</p> <pre><code># Bad: No shared variables between first two conditions\nr.conditions = [\n  KBS::Condition.new(:a, { x: :v1? }),\n  KBS::Condition.new(:b, { y: :v2? }),  # No :v1?!\n  KBS::Condition.new(:c, { p: :v1?, q: :v2? })\n]\n# Creates a \u00d7 b cross product\n\n# Good: Progressive joining\nr.conditions = [\n  KBS::Condition.new(:a, { x: :v1? }),\n  KBS::Condition.new(:c, { p: :v1?, q: :v2? }),\n  KBS::Condition.new(:b, { y: :v2? })\n]\n# Each condition reduces search space\n</code></pre>"},{"location":"guides/variable-binding/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/variable-binding/#one-to-many-relationship","title":"One-to-Many Relationship","text":"<pre><code># One customer, many orders\nr.conditions = [\n  KBS::Condition.new(:customer, {\n    id: :cust_id?,\n    status: \"active\"\n  }),\n\n  KBS::Condition.new(:order, {\n    customer_id: :cust_id?,\n    status: \"pending\"\n  })\n]\n\n# Fires once per pending order for active customers\n</code></pre>"},{"location":"guides/variable-binding/#many-to-many-relationship","title":"Many-to-Many Relationship","text":"<pre><code># Students enrolled in courses\nr.conditions = [\n  KBS::Condition.new(:student, { id: :student_id? }),\n  KBS::Condition.new(:enrollment, {\n    student_id: :student_id?,\n    course_id: :course_id?\n  }),\n  KBS::Condition.new(:course, { id: :course_id? })\n]\n\n# Fires for each student-course pair\n</code></pre>"},{"location":"guides/variable-binding/#hierarchical-join","title":"Hierarchical Join","text":"<pre><code># Parent \u2192 Child \u2192 Grandchild\nr.conditions = [\n  KBS::Condition.new(:category, { id: :cat_id? }),\n  KBS::Condition.new(:product, {\n    category_id: :cat_id?,\n    id: :prod_id?\n  }),\n  KBS::Condition.new(:review, {\n    product_id: :prod_id?,\n    rating: :rating?\n  })\n]\n</code></pre>"},{"location":"guides/variable-binding/#debugging-bindings","title":"Debugging Bindings","text":""},{"location":"guides/variable-binding/#print-bindings","title":"Print Bindings","text":"<pre><code>r.action = lambda do |facts, bindings|\n  puts \"Bindings: #{bindings.inspect}\"\n  puts \"Facts:\"\n  facts.each_with_index do |fact, i|\n    puts \"  #{i}: #{fact.type} #{fact.attributes}\"\n  end\nend\n</code></pre>"},{"location":"guides/variable-binding/#trace-join-tests","title":"Trace Join Tests","text":"<pre><code>class DebugJoinNode &lt; KBS::JoinNode\n  def perform_join_tests(token, fact)\n    result = super\n    puts \"Join test: #{@tests.inspect}\"\n    puts \"  Token: #{token.inspect}\"\n    puts \"  Fact: #{fact.inspect}\"\n    puts \"  Result: #{result}\"\n    result\n  end\nend\n</code></pre>"},{"location":"guides/variable-binding/#validate-bindings","title":"Validate Bindings","text":"<pre><code>r.action = lambda do |facts, bindings|\n  # Ensure expected bindings exist\n  required = [:sensor_id?, :temp?, :max?]\n  missing = required - bindings.keys\n\n  if missing.any?\n    raise \"Missing bindings: #{missing}\"\n  end\n\n  # Proceed with action\n  # ...\nend\n</code></pre>"},{"location":"guides/variable-binding/#next-steps","title":"Next Steps","text":"<ul> <li>Pattern Matching - How facts match conditions</li> <li>Negation - Negated conditions and binding</li> <li>Network Structure - How joins compile into networks</li> <li>Performance Guide - Optimizing join performance</li> </ul> <p>Variable binding is the glue that connects facts. Master bindings, master rule performance.</p>"},{"location":"guides/writing-rules/","title":"Writing Rules","text":"<p>Master the art of authoring production rules. This guide covers best practices, patterns, and strategies for writing effective, maintainable, and performant rules in KBS.</p>"},{"location":"guides/writing-rules/#rule-anatomy","title":"Rule Anatomy","text":"<p>Every rule consists of three parts:</p> <pre><code>KBS::Rule.new(\"rule_name\", priority: 0) do |r|\n  # 1. CONDITIONS - Pattern matching\n  r.conditions = [...]\n\n  # 2. ACTION - What to do when conditions match\n  r.action = lambda do |facts, bindings|\n    # Execute logic\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#1-rule-name","title":"1. Rule Name","text":"<p>Choose descriptive, actionable names:</p> <pre><code># Good: Clear intent\n\"send_high_temperature_alert\"\n\"cancel_duplicate_orders\"\n\"escalate_critical_issues\"\n\n# Bad: Vague or cryptic\n\"rule1\"\n\"process\"\n\"check_stuff\"\n</code></pre> <p>Naming Conventions: - Use snake_case - Start with verb (action-oriented) - Be specific about what the rule does - Include domain context</p>"},{"location":"guides/writing-rules/#2-priority","title":"2. Priority","text":"<p>Control execution order when multiple rules match:</p> <pre><code>KBS::Rule.new(\"critical_safety_check\", priority: 100)  # Fires first\nKBS::Rule.new(\"normal_processing\", priority: 50)\nKBS::Rule.new(\"cleanup_task\", priority: 10)            # Fires last\n</code></pre> <p>Priority Guidelines: - 100+ - Safety checks, emergency shutdowns - 50-99 - Business logic, processing - 1-49 - Monitoring, logging, cleanup - 0 - Default priority (no preference)</p>"},{"location":"guides/writing-rules/#3-conditions","title":"3. Conditions","text":"<p>Patterns that must match for the rule to fire. Order matters for performance.</p> <pre><code>r.conditions = [\n  # Most selective first (fewest matches)\n  KBS::Condition.new(:critical_alert, { severity: \"critical\" }),\n\n  # Less selective last (more matches)\n  KBS::Condition.new(:sensor, { id: :sensor_id? })\n]\n</code></pre>"},{"location":"guides/writing-rules/#4-action","title":"4. Action","text":"<p>Code executed when all conditions match:</p> <pre><code>r.action = lambda do |facts, bindings|\n  # Access matched facts\n  alert = facts[0]\n  sensor = facts[1]\n\n  # Access variable bindings\n  sensor_id = bindings[:sensor_id?]\n\n  # Perform action\n  notify_operator(sensor_id, alert[:message])\nend\n</code></pre>"},{"location":"guides/writing-rules/#condition-ordering","title":"Condition Ordering","text":"<p>Golden Rule: Order conditions from most selective to least selective.</p>"},{"location":"guides/writing-rules/#why-order-matters","title":"Why Order Matters","text":"<pre><code># Bad: General condition first\nr.conditions = [\n  KBS::Condition.new(:sensor, {}),           # 1000 matches\n  KBS::Condition.new(:critical_alert, {})    # 1 match\n]\n# Creates 1000 partial matches, wastes memory\n\n# Good: Specific condition first\nr.conditions = [\n  KBS::Condition.new(:critical_alert, {}),   # 1 match\n  KBS::Condition.new(:sensor, {})            # Joins with 1000\n]\n# Creates 1 partial match, efficient joins\n</code></pre>"},{"location":"guides/writing-rules/#selectivity-examples","title":"Selectivity Examples","text":"<pre><code># Most selective (few facts)\nKBS::Condition.new(:emergency, { level: \"critical\" })\nKBS::Condition.new(:user, { role: \"admin\" })\n\n# Moderate selectivity\nKBS::Condition.new(:order, { status: \"pending\" })\nKBS::Condition.new(:stock, { exchange: \"NYSE\" })\n\n# Least selective (many facts)\nKBS::Condition.new(:sensor, {})\nKBS::Condition.new(:log_entry, {})\n</code></pre>"},{"location":"guides/writing-rules/#measuring-selectivity","title":"Measuring Selectivity","text":"<pre><code>def measure_selectivity(engine, type, pattern)\n  engine.facts.count { |f|\n    f.type == type &amp;&amp;\n    pattern.all? { |k, v| f[k] == v }\n  }\nend\n\n# Compare\nputs measure_selectivity(engine, :critical_alert, {})  # =&gt; 1\nputs measure_selectivity(engine, :sensor, {})          # =&gt; 1000\n\n# Order: critical_alert first, sensor second\n</code></pre>"},{"location":"guides/writing-rules/#action-design","title":"Action Design","text":""},{"location":"guides/writing-rules/#single-responsibility","title":"Single Responsibility","text":"<p>One action, one purpose:</p> <pre><code># Good: Focused action\nr.action = lambda do |facts, bindings|\n  send_email_alert(bindings[:email?], bindings[:message?])\nend\n\n# Bad: Multiple responsibilities\nr.action = lambda do |facts, bindings|\n  send_email_alert(bindings[:email?])\n  update_database(bindings[:id?])\n  call_external_api(bindings[:data?])\n  write_log_file(bindings[:msg?])\nend\n</code></pre> <p>Split complex actions into multiple rules:</p> <pre><code># Rule 1: Detect condition\nKBS::Rule.new(\"detect_high_temp\", priority: 50) do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { temp: :temp? }, predicate: -&gt;(f) { f[:temp] &gt; 30 })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.add_fact(:high_temp_detected, { temp: bindings[:temp?] })\n  end\nend\n\n# Rule 2: Send alert\nKBS::Rule.new(\"send_temp_alert\", priority: 40) do |r|\n  r.conditions = [\n    KBS::Condition.new(:high_temp_detected, { temp: :temp? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    send_email(\"High temp: #{bindings[:temp?]}\")\n  end\nend\n\n# Rule 3: Log event\nKBS::Rule.new(\"log_temp_event\", priority: 30) do |r|\n  r.conditions = [\n    KBS::Condition.new(:high_temp_detected, { temp: :temp? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    logger.info(\"Temperature spike: #{bindings[:temp?]}\")\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#avoid-side-effects","title":"Avoid Side Effects","text":"<p>Actions should be deterministic and idempotent when possible:</p> <pre><code># Good: Idempotent (safe to run multiple times)\nr.action = lambda do |facts, bindings|\n  # Remove old alert if exists\n  old = engine.facts.find { |f| f.type == :alert &amp;&amp; f[:id] == bindings[:id?] }\n  engine.remove_fact(old) if old\n\n  # Add new alert\n  engine.add_fact(:alert, { id: bindings[:id?], message: \"Alert!\" })\nend\n\n# Bad: Non-idempotent (creates duplicates)\nr.action = lambda do |facts, bindings|\n  # Always adds, even if alert already exists\n  engine.add_fact(:alert, { id: bindings[:id?], message: \"Alert!\" })\nend\n</code></pre>"},{"location":"guides/writing-rules/#error-handling","title":"Error Handling","text":"<p>Protect against failures:</p> <pre><code>r.action = lambda do |facts, bindings|\n  begin\n    send_email(bindings[:email?], bindings[:message?])\n  rescue Net::SMTPError =&gt; e\n    logger.error(\"Failed to send email: #{e.message}\")\n    # Add failure fact for retry logic\n    engine.add_fact(:email_failure, {\n      email: bindings[:email?],\n      error: e.message,\n      timestamp: Time.now\n    })\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#variable-binding-strategies","title":"Variable Binding Strategies","text":""},{"location":"guides/writing-rules/#consistent-naming","title":"Consistent Naming","text":"<p>Use descriptive, consistent variable names:</p> <pre><code># Good: Clear intent\n:sensor_id?\n:temperature_celsius?\n:alert_threshold?\n:user_email?\n\n# Bad: Cryptic\n:s?\n:t?\n:x?\n</code></pre>"},{"location":"guides/writing-rules/#join-patterns","title":"Join Patterns","text":"<p>Connect facts through shared variables:</p> <pre><code># Pattern: Join sensor reading with threshold\nr.conditions = [\n  KBS::Condition.new(:sensor, {\n    id: :sensor_id?,\n    temp: :current_temp?\n  }),\n\n  KBS::Condition.new(:threshold, {\n    sensor_id: :sensor_id?,  # Same variable = join constraint\n    max_temp: :max_temp?\n  })\n]\n\n# Only matches when sensor_id is same in both facts\n</code></pre>"},{"location":"guides/writing-rules/#computed-bindings","title":"Computed Bindings","text":"<p>Derive values in actions:</p> <pre><code>r.action = lambda do |facts, bindings|\n  current = bindings[:current_temp?]\n  max = bindings[:max_temp?]\n\n  # Compute derived values\n  diff = current - max\n  percentage_over = ((current / max.to_f) - 1) * 100\n\n  puts \"#{diff}\u00b0C over threshold (#{percentage_over.round(1)}%)\"\nend\n</code></pre>"},{"location":"guides/writing-rules/#rule-composition-patterns","title":"Rule Composition Patterns","text":""},{"location":"guides/writing-rules/#state-machine","title":"State Machine","text":"<p>Model state transitions:</p> <pre><code># Transition: pending \u2192 processing\nKBS::Rule.new(\"start_processing\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:order, {\n      id: :order_id?,\n      status: \"pending\"\n    })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    old_order = facts[0]\n    engine.remove_fact(old_order)\n    engine.add_fact(:order, {\n      id: bindings[:order_id?],\n      status: \"processing\",\n      started_at: Time.now\n    })\n  end\nend\n\n# Transition: processing \u2192 completed\nKBS::Rule.new(\"complete_processing\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:order, {\n      id: :order_id?,\n      status: \"processing\"\n    }),\n    KBS::Condition.new(:processing_done, {\n      order_id: :order_id?\n    })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    order = facts[0]\n    engine.remove_fact(order)\n    engine.remove_fact(facts[1])  # Remove trigger\n    engine.add_fact(:order, {\n      id: bindings[:order_id?],\n      status: \"completed\",\n      completed_at: Time.now\n    })\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#guard-conditions","title":"Guard Conditions","text":"<p>Prevent duplicate actions:</p> <pre><code>KBS::Rule.new(\"send_alert_once\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:high_temp, { sensor_id: :id? }),\n\n    # Guard: Only fire if alert not already sent\n    KBS::Condition.new(:alert_sent, { sensor_id: :id? }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    send_alert(bindings[:id?])\n\n    # Record that we sent this alert\n    engine.add_fact(:alert_sent, { sensor_id: bindings[:id?] })\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#cleanup-rules","title":"Cleanup Rules","text":"<p>Remove stale facts:</p> <pre><code>KBS::Rule.new(\"cleanup_stale_alerts\", priority: 1) do |r|\n  r.conditions = [\n    KBS::Condition.new(:alert, {\n      timestamp: :time?\n    }, predicate: lambda { |f|\n      (Time.now - f[:timestamp]) &gt; 3600  # 1 hour old\n    })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.remove_fact(facts[0])\n    logger.info(\"Removed stale alert\")\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#aggregation-rules","title":"Aggregation Rules","text":"<p>Compute over multiple facts:</p> <pre><code>KBS::Rule.new(\"compute_average_temp\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:compute_avg_requested, {})\n  ]\n\n  r.action = lambda do |facts, bindings|\n    temps = engine.facts\n      .select { |f| f.type == :sensor }\n      .map { |f| f[:temp] }\n      .compact\n\n    avg = temps.sum / temps.size.to_f\n\n    engine.add_fact(:average_temp, { value: avg })\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#temporal-rules","title":"Temporal Rules","text":"<p>React to time-based conditions:</p> <pre><code>KBS::Rule.new(\"detect_delayed_response\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:request, {\n      id: :req_id?,\n      created_at: :created?\n    }),\n\n    KBS::Condition.new(:response, {\n      request_id: :req_id?\n    }, negated: true),\n\n    KBS::Condition.new(:request, {},\n      predicate: lambda { |f|\n        (Time.now - f[:created_at]) &gt; 300  # 5 minutes\n      }\n    )\n  ]\n\n  r.action = lambda do |facts, bindings|\n    alert(\"Request #{bindings[:req_id?]} delayed!\")\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#priority-management","title":"Priority Management","text":""},{"location":"guides/writing-rules/#priority-levels","title":"Priority Levels","text":"<p>Establish consistent priority levels for your domain:</p> <pre><code># Define priority constants\nmodule Priority\n  CRITICAL = 100   # Emergency, safety\n  HIGH = 75        # Important business logic\n  NORMAL = 50      # Standard processing\n  LOW = 25         # Cleanup, logging\n  MONITORING = 10  # Metrics, diagnostics\nend\n\n# Use in rules\nKBS::Rule.new(\"emergency_shutdown\", priority: Priority::CRITICAL) do |r|\n  # ...\nend\n\nKBS::Rule.new(\"process_order\", priority: Priority::NORMAL) do |r|\n  # ...\nend\n</code></pre>"},{"location":"guides/writing-rules/#priority-inversion","title":"Priority Inversion","text":"<p>Avoid priority inversions where low-priority rules block high-priority rules:</p> <pre><code># Bad: Low priority rule creates fact needed by high priority rule\nKBS::Rule.new(\"compute_risk\", priority: 10) do |r|\n  r.conditions = [...]\n  r.action = lambda { |f, b| engine.add_fact(:risk_score, { ... }) }\nend\n\nKBS::Rule.new(\"emergency_check\", priority: 100) do |r|\n  r.conditions = [\n    KBS::Condition.new(:risk_score, { value: :risk? })  # Depends on low priority rule!\n  ]\n  r.action = lambda { |f, b| emergency_shutdown if b[:risk?] &gt; 90 }\nend\n\n# Fix: Make dependency higher priority\nKBS::Rule.new(\"compute_risk\", priority: 110) do |r|\n  # Now runs before emergency_check\nend\n</code></pre>"},{"location":"guides/writing-rules/#testing-strategies","title":"Testing Strategies","text":""},{"location":"guides/writing-rules/#unit-test-rules-in-isolation","title":"Unit Test Rules in Isolation","text":"<pre><code>require 'minitest/autorun'\nrequire 'kbs'\n\nclass TestTemperatureRules &lt; Minitest::Test\n  def setup\n    @engine = KBS::Engine.new\n\n    @rule = KBS::Rule.new(\"high_temp_alert\") do |r|\n      r.conditions = [\n        KBS::Condition.new(:sensor, { id: :id?, temp: :temp? }),\n        KBS::Condition.new(:threshold, { id: :id?, max: :max? })\n      ]\n\n      r.action = lambda do |facts, bindings|\n        @alert_fired = true if bindings[:temp?] &gt; bindings[:max?]\n      end\n    end\n\n    @engine.add_rule(@rule)\n    @alert_fired = false\n  end\n\n  def test_fires_when_temp_exceeds_threshold\n    @engine.add_fact(:sensor, { id: \"bedroom\", temp: 30 })\n    @engine.add_fact(:threshold, { id: \"bedroom\", max: 25 })\n    @engine.run\n\n    assert @alert_fired, \"Rule should fire when temp &gt; threshold\"\n  end\n\n  def test_does_not_fire_when_temp_below_threshold\n    @engine.add_fact(:sensor, { id: \"bedroom\", temp: 20 })\n    @engine.add_fact(:threshold, { id: \"bedroom\", max: 25 })\n    @engine.run\n\n    refute @alert_fired, \"Rule should not fire when temp &lt;= threshold\"\n  end\n\n  def test_only_fires_for_matching_sensor\n    @engine.add_fact(:sensor, { id: \"bedroom\", temp: 30 })\n    @engine.add_fact(:threshold, { id: \"kitchen\", max: 25 })\n    @engine.run\n\n    refute @alert_fired, \"Rule should not fire for different sensors\"\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#integration-tests","title":"Integration Tests","text":"<p>Test multiple rules working together:</p> <pre><code>def test_state_machine_workflow\n  # Add state transition rules\n  engine.add_rule(start_processing_rule)\n  engine.add_rule(complete_processing_rule)\n\n  # Add initial state\n  engine.add_fact(:order, { id: 1, status: \"pending\" })\n  engine.run\n\n  # Should not transition yet\n  assert_equal \"pending\", find_order(1)[:status]\n\n  # Trigger transition\n  engine.add_fact(:processing_done, { order_id: 1 })\n  engine.run\n\n  # Should transition to processing, then completed\n  assert_equal \"completed\", find_order(1)[:status]\nend\n</code></pre>"},{"location":"guides/writing-rules/#property-based-testing","title":"Property-Based Testing","text":"<p>Test rule invariants:</p> <pre><code>def test_no_duplicate_alerts\n  # Add facts\n  100.times do |i|\n    engine.add_fact(:high_temp, { sensor_id: i })\n  end\n\n  # Run engine multiple times\n  10.times { engine.run }\n\n  # Property: At most one alert per sensor\n  alert_counts = engine.facts\n    .select { |f| f.type == :alert_sent }\n    .group_by { |f| f[:sensor_id] }\n    .transform_values(&amp;:count)\n\n  alert_counts.each do |sensor_id, count|\n    assert_equal 1, count, \"Sensor #{sensor_id} has #{count} alerts, expected 1\"\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guides/writing-rules/#minimize-negations","title":"Minimize Negations","text":"<p>Negations are expensive:</p> <pre><code># Expensive: 3 negations\nr.conditions = [\n  KBS::Condition.new(:foo, {}, negated: true),\n  KBS::Condition.new(:bar, {}, negated: true),\n  KBS::Condition.new(:baz, {}, negated: true)\n]\n\n# Better: Combine into positive condition\nengine.add_fact(:conditions_met, {}) unless foo_exists? || bar_exists? || baz_exists?\n\nr.conditions = [\n  KBS::Condition.new(:conditions_met, {})\n]\n</code></pre>"},{"location":"guides/writing-rules/#avoid-predicates-for-simple-checks","title":"Avoid Predicates for Simple Checks","text":"<pre><code># Expensive: Predicate disables network sharing\nKBS::Condition.new(:stock, {},\n  predicate: lambda { |f| f[:symbol] == \"AAPL\" }\n)\n\n# Better: Use pattern matching\nKBS::Condition.new(:stock, { symbol: \"AAPL\" })\n</code></pre>"},{"location":"guides/writing-rules/#cache-computed-values","title":"Cache Computed Values","text":"<pre><code># Bad: Recomputes every time rule fires\nr.action = lambda do |facts, bindings|\n  avg = compute_expensive_average(engine.facts)\n  if avg &gt; threshold\n    alert(avg)\n  end\nend\n\n# Good: Cache as fact, recompute only when needed\nKBS::Rule.new(\"update_average\", priority: 100) do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { temp: :temp? })  # Triggers when sensor added\n  ]\n\n  r.action = lambda do |facts, bindings|\n    avg = compute_expensive_average(engine.facts)\n    engine.add_fact(:cached_average, { value: avg })\n  end\nend\n\nKBS::Rule.new(\"check_average\", priority: 50) do |r|\n  r.conditions = [\n    KBS::Condition.new(:cached_average, { value: :avg? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    alert(bindings[:avg?]) if bindings[:avg?] &gt; threshold\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guides/writing-rules/#1-infinite-loops","title":"1. Infinite Loops","text":"<pre><code># Bad: Rule fires itself indefinitely\nKBS::Rule.new(\"infinite_loop\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { temp: :temp? })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    # This triggers the rule again!\n    engine.add_fact(:sensor, { temp: bindings[:temp?] + 1 })\n  end\nend\n\n# Fix: Add termination condition\nKBS::Rule.new(\"limited_increment\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { temp: :temp? }),\n    KBS::Condition.new(:increment_done, {}, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    engine.add_fact(:sensor, { temp: bindings[:temp?] + 1 })\n    engine.add_fact(:increment_done, {})\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#2-variable-scope-confusion","title":"2. Variable Scope Confusion","text":"<pre><code># Bad: Closure captures wrong variable\nrules = []\n%w[sensor1 sensor2 sensor3].each do |sensor|\n  rules &lt;&lt; KBS::Rule.new(\"process_#{sensor}\") do |r|\n    r.conditions = [...]\n    r.action = lambda do |facts, bindings|\n      # All rules reference same 'sensor' variable (last value!)\n      puts sensor\n    end\n  end\nend\n\n# Fix: Force closure with parameter\n%w[sensor1 sensor2 sensor3].each do |sensor_name|\n  rules &lt;&lt; KBS::Rule.new(\"process_#{sensor_name}\") do |r|\n    captured_sensor = sensor_name  # Force capture\n    r.conditions = [...]\n    r.action = lambda do |facts, bindings|\n      puts captured_sensor  # Correct value\n    end\n  end\nend\n</code></pre>"},{"location":"guides/writing-rules/#3-forgetting-to-call-enginerun","title":"3. Forgetting to Call <code>engine.run</code>","text":"<pre><code># Bad: Facts added but never matched\nengine.add_fact(:sensor, { temp: 30 })\nengine.add_fact(:threshold, { max: 25 })\n# Rules never fire!\n\n# Good: Run after adding facts\nengine.add_fact(:sensor, { temp: 30 })\nengine.add_fact(:threshold, { max: 25 })\nengine.run  # Match and fire rules\n</code></pre>"},{"location":"guides/writing-rules/#next-steps","title":"Next Steps","text":"<ul> <li>Pattern Matching - Deep dive into condition matching</li> <li>Variable Binding - Join tests and binding extraction</li> <li>Negation - Negated condition behavior</li> <li>Performance Guide - Profiling and optimization</li> <li>Testing Guide - Comprehensive test strategies</li> </ul> <p>Well-designed rules are self-documenting. If a rule is hard to understand, it's probably doing too much.</p>"}]}