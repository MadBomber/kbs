{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#kbs-knowledge-based-systems-for-ruby","title":"KBS - Knowledge-Based Systems for Ruby","text":"<p>A Ruby implementation of the RETE algorithm for building intelligent, rule-based systems with persistent memory.</p> <p> </p>"},{"location":"#what-is-kbs","title":"What is KBS?","text":"<p>KBS (Knowledge-Based Systems) is a powerful Ruby gem that brings production rule systems to your applications. At its core is the RETE algorithm, a highly optimized pattern-matching engine originally developed for expert systems and now used in modern applications ranging from trading systems to IoT automation.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 RETE Algorithm: State-of-the-art pattern matching with unlinking optimization</li> <li>\ud83d\udcbe Persistent Blackboard Memory: SQLite, Redis, or hybrid storage for facts and audit trails</li> <li>\ud83c\udfaf Declarative DSL: Write rules in natural, readable Ruby syntax</li> <li>\ud83d\udd04 Incremental Matching: Process only changes, not entire fact sets</li> <li>\ud83d\udeab Negation Support: Express \"absence of pattern\" conditions naturally</li> <li>\ud83d\udcca Multi-Agent Systems: Build collaborative systems with message passing</li> <li>\ud83d\udd0d Full Auditability: Complete history of fact changes and rule firings</li> <li>\u26a1 High Performance: Handle millions of facts with sub-millisecond updates</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>require 'kbs'\n\n# Create a rule-based trading system\nengine = KBS::Engine.new\n\n# Define a rule using the DSL\nengine.add_rule(Rule.new(\"buy_signal\") do |r|\n  r.conditions = [\n    # Stock price is below threshold\n    Condition.new(:stock, { symbol: :?symbol, price: :?price }),\n    Condition.new(:threshold, { symbol: :?symbol, buy_below: :?threshold }),\n\n    # No pending order exists (negation)\n    Condition.new(:order, { symbol: :?symbol }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:?price] &lt; bindings[:?threshold]\n      puts \"BUY #{bindings[:?symbol]} at #{bindings[:?price]}\"\n    end\n  end\nend)\n\n# Add facts to working memory\nengine.add_fact(:stock, symbol: \"AAPL\", price: 145.50)\nengine.add_fact(:threshold, symbol: \"AAPL\", buy_below: 150.0)\n\n# Fire matching rules\nengine.run  # =&gt; BUY AAPL at 145.5\n</code></pre>"},{"location":"#why-rete","title":"Why RETE?","text":"<p>Traditional rule engines re-evaluate all rules against all facts on every change\u2014extremely inefficient. RETE solves this through:</p> <ol> <li>Network Compilation: Rules are compiled into a discrimination network that shares common patterns</li> <li>State Preservation: Partial matches are cached between cycles</li> <li>Incremental Updates: Only changed facts propagate through the network</li> <li>Unlinking Optimization (RETE): Empty nodes automatically disconnect to skip unnecessary work</li> </ol> <p>Result: Near-constant time per fact change, regardless of rule set size.</p>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#algorithmic-trading","title":"\ud83d\udcb9 Algorithmic Trading","text":"<p>Real-time market analysis, signal detection, and automated order execution with complex multi-condition rules.</p>"},{"location":"#industrial-automation","title":"\ud83c\udfed Industrial Automation","text":"<p>IoT sensor monitoring, predictive maintenance, and automated control systems with temporal reasoning.</p>"},{"location":"#expert-systems","title":"\ud83c\udfe5 Expert Systems","text":"<p>Medical diagnosis, troubleshooting assistants, and decision support systems with knowledge representation.</p>"},{"location":"#multi-agent-systems","title":"\ud83e\udd16 Multi-Agent Systems","text":"<p>Collaborative agents with shared blackboard memory for distributed problem-solving.</p>"},{"location":"#business-rules-engines","title":"\ud83d\udce7 Business Rules Engines","text":"<p>Policy enforcement, workflow automation, and compliance checking with auditable decision trails.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>KBS consists of several integrated components:</p> <ul> <li>RETE Engine: Core pattern matching and rule execution</li> <li>Working Memory: Transient in-memory fact storage</li> <li>Blackboard System: Persistent memory with SQLite/Redis backends</li> <li>DSL: Natural language rule definition syntax</li> <li>Message Queue: Priority-based inter-agent communication</li> <li>Audit Log: Complete history for compliance and debugging</li> </ul> <p>See Architecture Overview for details.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Installation - Add KBS to your project</li> <li>Quick Start - Build your first rule-based system in 5 minutes</li> <li>RETE Algorithm - Deep dive into how it works</li> <li>Writing Rules - Master the DSL and pattern matching</li> <li>Examples - Learn from real-world applications</li> </ol>"},{"location":"#performance","title":"Performance","text":"<p>KBS is built for production workloads:</p> <ul> <li>Fact Addition: O(N) where N = activated nodes (typically &lt;&lt; total nodes)</li> <li>Rule Firing: O(M) where M = matched tokens</li> <li>Memory Efficient: Network sharing reduces redundant storage</li> <li>Scalable: Tested with millions of facts, thousands of rules</li> </ul> <p>Benchmarks on M2 Max: - Add 100,000 facts: ~500ms - Match complex 5-condition rule: &lt;1ms per fact - Redis backend: 100x faster than SQLite for high-frequency updates</p>"},{"location":"#project-status","title":"Project Status","text":"<p>KBS is actively maintained:</p> <ul> <li>\u2705 Core RETE implementation complete</li> <li>\u2705 Persistent blackboard with multiple backends</li> <li>\u2705 Full DSL support with negation</li> <li>\u2705 Comprehensive test coverage</li> <li>\u2705 Real-world usage in trading systems</li> <li>\ud83d\udea7 Additional examples and guides in progress</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: madbomber/kbs</li> <li>RubyGems: kbs</li> <li>Issues: Report bugs or request features</li> <li>Discussions: Ask questions</li> </ul>"},{"location":"#license","title":"License","text":"<p>KBS is released under the MIT License.</p> <p>Copyright \u00a9 2024 Dewayne VanHoozer</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>The RETE algorithm was invented by Charles Forgy in 1979. This implementation draws inspiration from:</p> <ul> <li>Forgy, C. (1982). \"Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem\"</li> <li>Doorenbos, R. (1995). \"Production Matching for Large Learning Systems\" (RETE/UL)</li> <li>Modern production rule systems: Drools, Jess, CLIPS</li> </ul> <p>Ready to build intelligent systems? Start with the Quick Start Guide!</p>"},{"location":"DOCUMENTATION_STATUS/","title":"KBS Documentation Status","text":"<p>This document tracks the comprehensive documentation effort for the KBS gem.</p>"},{"location":"DOCUMENTATION_STATUS/#completed-documents","title":"\u2705 Completed Documents","text":""},{"location":"DOCUMENTATION_STATUS/#core-pages","title":"Core Pages","text":"<ul> <li> <code>index.md</code> - Main landing page with features, quick example, use cases</li> <li> <code>installation.md</code> - Installation guide with all backends</li> <li> <code>quick-start.md</code> - 5-minute getting started guide</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#architecture","title":"Architecture","text":"<ul> <li> <code>architecture/index.md</code> - Architecture overview with system layers</li> <li> <code>architecture/rete-algorithm.md</code> - COMPREHENSIVE deep dive into RETE (650+ lines)</li> <li> <code>architecture/blackboard.md</code> - COMPREHENSIVE blackboard pattern implementation</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#svg-graphics-created","title":"SVG Graphics Created","text":"<ul> <li> <code>assets/images/rete-network-layers.svg</code> - 3-layer RETE architecture</li> <li> <code>assets/images/fact-assertion-flow.svg</code> - Step-by-step fact propagation</li> <li> <code>assets/images/pattern-matching-trace.svg</code> - Complete negation example</li> <li> <code>assets/images/blackboard-architecture.svg</code> - Multi-agent blackboard system</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#supporting-files","title":"Supporting Files","text":"<ul> <li> <code>assets/css/custom.css</code> - Dark theme styling for SVGs and code</li> <li> <code>assets/js/mathjax.js</code> - Mathematical notation support</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#remaining-documents","title":"\ud83d\udccb Remaining Documents","text":""},{"location":"DOCUMENTATION_STATUS/#architecture_1","title":"Architecture","text":"<ul> <li> <code>architecture/network-structure.md</code> - Network compilation details, node types, optimization</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#guides-10-files","title":"Guides (10 files)","text":"<ul> <li> <code>guides/index.md</code> - Guides landing page</li> <li> <code>guides/getting-started.md</code> - Expanded tutorial</li> <li> <code>guides/writing-rules.md</code> - Rule authoring best practices</li> <li> <code>guides/dsl.md</code> - Complete DSL reference with all aliases</li> <li> <code>guides/facts.md</code> - Fact lifecycle, queries, updates</li> <li> <code>guides/pattern-matching.md</code> - Pattern syntax, predicates, operators</li> <li> <code>guides/variable-binding.md</code> - Variables, join tests, extraction</li> <li> <code>guides/negation.md</code> - Negation semantics, use cases, pitfalls</li> <li> <code>guides/blackboard-memory.md</code> - Persistence guide</li> <li> <code>guides/persistence.md</code> - Backend comparison, configuration</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#examples-3-files","title":"Examples (3 files)","text":"<ul> <li> <code>examples/index.md</code> - Examples landing page</li> <li> <code>examples/stock-trading.md</code> - Trading system walkthrough</li> <li> <code>examples/expert-systems.md</code> - Diagnostic expert system</li> <li> <code>examples/multi-agent.md</code> - Collaborative agents</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#advanced-4-files","title":"Advanced (4 files)","text":"<ul> <li> <code>advanced/index.md</code> - Advanced topics landing page</li> <li> <code>advanced/performance.md</code> - Profiling, optimization, benchmarks</li> <li> <code>advanced/custom-persistence.md</code> - Building custom stores</li> <li> <code>advanced/debugging.md</code> - Network inspection, tracing</li> <li> <code>advanced/testing.md</code> - Testing strategies for rules</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#api-reference-5-files","title":"API Reference (5 files)","text":"<ul> <li> <code>api/index.md</code> - API overview</li> <li> <code>api/rete-engine.md</code> - Engine class reference</li> <li> <code>api/facts.md</code> - Fact and Condition classes</li> <li> <code>api/rules.md</code> - Rule class reference</li> <li> <code>api/blackboard.md</code> - Blackboard::* classes</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#documentation-metrics","title":"\ud83d\udcca Documentation Metrics","text":"<ul> <li>Total Pages Planned: 35</li> <li>Pages Completed: 9 (26%)</li> <li>SVG Graphics Created: 4</li> <li>Total Lines Written: ~4,500+</li> <li>Estimated Remaining: ~6,000 lines</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#documentation-priorities","title":"\ud83c\udfaf Documentation Priorities","text":""},{"location":"DOCUMENTATION_STATUS/#high-priority-core-learning-path","title":"High Priority (Core Learning Path)","text":"<ol> <li><code>guides/writing-rules.md</code> - Essential for users</li> <li><code>guides/dsl.md</code> - Complete reference</li> <li><code>examples/stock-trading.md</code> - Real-world application</li> <li><code>architecture/network-structure.md</code> - Complete architecture coverage</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#medium-priority-advanced-users","title":"Medium Priority (Advanced Users)","text":"<ol> <li><code>advanced/performance.md</code> - Production optimization</li> <li><code>guides/pattern-matching.md</code> - Deep pattern knowledge</li> <li><code>examples/multi-agent.md</code> - Advanced architecture</li> <li><code>advanced/debugging.md</code> - Troubleshooting</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#lower-priority-reference","title":"Lower Priority (Reference)","text":"<ol> <li>API documentation files - Generated from code</li> <li>Remaining guides - Nice-to-have expansions</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#svg-graphics-roadmap","title":"\ud83c\udfa8 SVG Graphics Roadmap","text":""},{"location":"DOCUMENTATION_STATUS/#completed","title":"Completed","text":"<ul> <li>\u2705 RETE network layers diagram</li> <li>\u2705 Fact assertion flow diagram</li> <li>\u2705 Pattern matching trace (negation)</li> <li>\u2705 Blackboard architecture diagram</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#planned","title":"Planned","text":"<ul> <li> Network compilation process (for <code>network-structure.md</code>)</li> <li> Variable binding flow (for <code>guides/variable-binding.md</code>)</li> <li> Token tree structure (for <code>advanced/debugging.md</code>)</li> <li> Performance comparison chart (for <code>advanced/performance.md</code>)</li> <li> Multi-agent message flow (for <code>examples/multi-agent.md</code>)</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#content-guidelines","title":"\ud83d\udcdd Content Guidelines","text":""},{"location":"DOCUMENTATION_STATUS/#every-document-should-include","title":"Every Document Should Include:","text":"<ol> <li>Clear introduction - What this document covers</li> <li>Code examples - Real, runnable Ruby code</li> <li>Visual aids - SVG diagrams where helpful</li> <li>Cross-references - Links to related docs</li> <li>Implementation references - Line numbers for source code</li> <li>Best practices - Dos and don'ts</li> <li>Next steps - Where to go from here</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#svg-requirements","title":"SVG Requirements:","text":"<ul> <li>Dark theme with transparent background</li> <li>Consistent color palette:</li> <li>Purple <code>#bb86fc</code> - Core components/control</li> <li>Teal <code>#03dac6</code> - Data/storage</li> <li>Pink <code>#cf6679</code> - Agents/actions</li> <li>Gold <code>#ffd700</code> - Important/production</li> <li>Monospace fonts for code</li> <li>Clear arrows and flow indicators</li> <li>Legends where needed</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#next-session-tasks","title":"\ud83d\ude80 Next Session Tasks","text":"<p>Based on build warnings, create in this order:</p> <ol> <li>Stub all missing files (eliminate build warnings)</li> <li>Complete guides/ (highest user value)</li> <li>Complete examples/ (practical learning)</li> <li>Complete advanced/ (production users)</li> <li>Complete api/ (reference documentation)</li> </ol>"},{"location":"DOCUMENTATION_STATUS/#documentation-style","title":"\ud83d\udcda Documentation Style","text":"<ul> <li>Tone: Technical but accessible</li> <li>Code: Always include complete, runnable examples</li> <li>Length: Comprehensive where needed (RETE doc is 650+ lines and that's perfect)</li> <li>Format: Markdown with code blocks, SVGs, tables</li> <li>Audience: Ruby developers new to rule-based systems</li> </ul>"},{"location":"DOCUMENTATION_STATUS/#quality-standards","title":"\u2728 Quality Standards","text":"<ul> <li>\u2705 Every code example must be syntactically correct</li> <li>\u2705 Every link must point to existing files</li> <li>\u2705 Every SVG must have alt text/caption</li> <li>\u2705 Every technical term explained on first use</li> <li>\u2705 Implementation file references with line numbers</li> <li>\u2705 No orphan pages (all linked from somewhere)</li> </ul> <p>Last Updated: {{ date }} Documentation Lead: Claude Code Status: In Progress (26% complete)</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Ruby: 2.7 or higher</li> <li>SQLite3: For persistent blackboard memory (optional)</li> <li>Redis: For high-performance persistence (optional)</li> </ul>"},{"location":"installation/#installing-the-gem","title":"Installing the Gem","text":""},{"location":"installation/#from-rubygems","title":"From RubyGems","text":"<pre><code>gem install kbs\n</code></pre>"},{"location":"installation/#using-bundler","title":"Using Bundler","text":"<p>Add to your <code>Gemfile</code>:</p> <pre><code>gem 'kbs'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/madbomber/kbs.git\ncd kbs\nbundle install\nrake install\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"installation/#sqlite3-default-blackboard-backend","title":"SQLite3 (Default Blackboard Backend)","text":"<pre><code>gem install sqlite3\n</code></pre> <p>Or in your <code>Gemfile</code>:</p> <pre><code>gem 'sqlite3'\n</code></pre>"},{"location":"installation/#redis-high-performance-backend","title":"Redis (High-Performance Backend)","text":"<p>Install Redis server:</p> <pre><code># macOS\nbrew install redis\nbrew services start redis\n\n# Ubuntu/Debian\nsudo apt-get install redis-server\nsudo systemctl start redis\n\n# Docker\ndocker run -d -p 6379:6379 redis:latest\n</code></pre> <p>Install Ruby Redis gem:</p> <pre><code>gem install redis\n</code></pre> <p>Or in your <code>Gemfile</code>:</p> <pre><code>gem 'redis'\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify the installation:</p> <pre><code>require 'kbs'\n\nputs \"KBS version: #{KBS::VERSION}\"\n# =&gt; KBS version: 0.1.0\n\n# Test basic functionality\nengine = KBS::Engine.new\nengine.add_fact(:test, value: 42)\nputs \"\u2713 KBS is working!\"\n</code></pre>"},{"location":"installation/#development-setup","title":"Development Setup","text":"<p>For contributing or running tests:</p> <pre><code>git clone https://github.com/madbomber/kbs.git\ncd kbs\nbundle install\n\n# Run tests\nbundle exec rake test\n\n# Run examples\nbundle exec ruby examples/working_demo.rb\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#sqlite3-installation-issues","title":"SQLite3 Installation Issues","text":"<p>On macOS with M1/M2:</p> <pre><code>gem install sqlite3 -- --with-sqlite3-include=/opt/homebrew/opt/sqlite/include \\\n  --with-sqlite3-lib=/opt/homebrew/opt/sqlite/lib\n</code></pre> <p>On Ubuntu/Debian:</p> <pre><code>sudo apt-get install libsqlite3-dev\ngem install sqlite3\n</code></pre>"},{"location":"installation/#redis-connection-issues","title":"Redis Connection Issues","text":"<p>Check Redis is running:</p> <pre><code>redis-cli ping\n# =&gt; PONG\n</code></pre> <p>Test connection from Ruby:</p> <pre><code>require 'redis'\nredis = Redis.new(url: 'redis://localhost:6379/0')\nredis.ping\n# =&gt; \"PONG\"\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first rule-based system</li> <li>RETE Algorithm - Understand the engine</li> <li>Writing Rules - Master the DSL</li> <li>Examples - See real-world applications</li> </ul>"},{"location":"quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with KBS in 5 minutes.</p>"},{"location":"quick-start/#your-first-rule-based-system","title":"Your First Rule-Based System","text":"<p>Let's build a simple temperature monitoring system that alerts when readings are abnormal.</p>"},{"location":"quick-start/#step-1-create-the-engine","title":"Step 1: Create the Engine","text":"<pre><code>require 'kbs'\n\n# Create a RETE engine\nengine = KBS::Engine.new\n</code></pre>"},{"location":"quick-start/#step-2-define-rules","title":"Step 2: Define Rules","text":"<pre><code># Rule 1: Alert on high temperature\nhigh_temp_rule = KBS::Rule.new(\"high_temperature_alert\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { id: :?id, temp: :?temp })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:?temp] &gt; 75\n      puts \"\u26a0\ufe0f  HIGH TEMP Alert: Sensor #{bindings[:?id]} at #{bindings[:?temp]}\u00b0F\"\n    end\n  end\nend\n\nengine.add_rule(high_temp_rule)\n\n# Rule 2: Alert when cooling system is offline AND temp is high\ncritical_rule = KBS::Rule.new(\"critical_condition\", priority: 10) do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor, { id: :?id, temp: :?temp }),\n    KBS::Condition.new(:cooling, { id: :?id, status: \"offline\" })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:?temp] &gt; 75\n      puts \"\ud83d\udea8 CRITICAL: Sensor #{bindings[:?id]} at #{bindings[:?temp]}\u00b0F with cooling OFFLINE!\"\n    end\n  end\nend\n\nengine.add_rule(critical_rule)\n</code></pre>"},{"location":"quick-start/#step-3-add-facts","title":"Step 3: Add Facts","text":"<pre><code># Add sensor readings\nengine.add_fact(:sensor, id: \"room_101\", temp: 72)\nengine.add_fact(:sensor, id: \"server_rack\", temp: 82)\nengine.add_fact(:sensor, id: \"storage\", temp: 65)\n\n# Add cooling system status\nengine.add_fact(:cooling, id: \"server_rack\", status: \"offline\")\n</code></pre>"},{"location":"quick-start/#step-4-run-rules","title":"Step 4: Run Rules","text":"<pre><code>engine.run\n# Output:\n# =&gt; \u26a0\ufe0f  HIGH TEMP Alert: Sensor server_rack at 82\u00b0F\n# =&gt; \ud83d\udea8 CRITICAL: Sensor server_rack at 82\u00b0F with cooling OFFLINE!\n</code></pre>"},{"location":"quick-start/#understanding-what-happened","title":"Understanding What Happened","text":"<ol> <li>Engine Creation: <code>Engine.new</code> builds an empty RETE network</li> <li>Rule Addition: Rules are compiled into the discrimination network</li> <li>Fact Assertion: Facts propagate through the network, creating partial matches</li> <li>Rule Firing: <code>engine.run()</code> executes actions for all complete matches</li> </ol> <p>The critical rule fires because: - Sensor \"server_rack\" temp (82\u00b0F) &gt; 75 - Cooling system for \"server_rack\" is offline - Both conditions are joined on the same <code>:?id</code> variable</p>"},{"location":"quick-start/#using-negation","title":"Using Negation","text":"<p>Rules can match on the absence of facts:</p> <pre><code># Alert when sensor has NO recent reading\nstale_sensor_rule = KBS::Rule.new(\"stale_sensor\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:sensor_registered, { id: :?id }),\n    # No recent reading exists (negation!)\n    KBS::Condition.new(:sensor, { id: :?id }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    puts \"\u26a0\ufe0f  No reading from sensor #{bindings[:?id]}\"\n  end\nend\n\nengine.add_rule(stale_sensor_rule)\n\n# Register sensors\nengine.add_fact(:sensor_registered, id: \"room_101\")\nengine.add_fact(:sensor_registered, id: \"room_102\")\n\n# Only add reading for room_101\nengine.add_fact(:sensor, id: \"room_101\", temp: 70)\n\nengine.run\n# =&gt; \u26a0\ufe0f  No reading from sensor room_102\n</code></pre>"},{"location":"quick-start/#persistent-blackboard-memory","title":"Persistent Blackboard Memory","text":"<p>For production systems, use persistent storage:</p> <pre><code>require 'kbs/blackboard'\n\n# SQLite backend (default)\nengine = KBS::Blackboard::Engine.new(db_path: 'monitoring.db')\n\n# Facts survive restarts\nengine.add_fact(:sensor, id: \"room_101\", temp: 72)\n\n# Query historical data\nmemory = engine.working_memory\naudit = memory.audit_log.recent_changes(limit: 10)\n</code></pre>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":""},{"location":"quick-start/#learn-the-fundamentals","title":"Learn the Fundamentals","text":"<ul> <li>Writing Rules - Master rule syntax and patterns</li> <li>Pattern Matching - Understand how facts match conditions</li> <li>Variable Binding - Use variables to join conditions</li> <li>Negation - Express \"absence\" conditions</li> </ul>"},{"location":"quick-start/#explore-examples","title":"Explore Examples","text":"<ul> <li>Stock Trading - Build a trading signal system</li> <li>Expert Systems - Diagnostic and decision support</li> <li>Multi-Agent Systems - Collaborative problem-solving</li> </ul>"},{"location":"quick-start/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Blackboard Memory - Persistent storage and audit trails</li> <li>Performance Tuning - Optimize for production workloads</li> <li>Debugging - Trace rule execution and network state</li> </ul>"},{"location":"quick-start/#understand-the-engine","title":"Understand the Engine","text":"<ul> <li>RETE Algorithm - Deep dive into pattern matching</li> <li>Network Structure - How rules are compiled</li> <li>API Reference - Complete class documentation</li> </ul>"},{"location":"quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"quick-start/#time-based-rules","title":"Time-Based Rules","text":"<pre><code>rule = KBS::Rule.new(\"recent_spike\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:reading, {\n      sensor: :?id,\n      temp: :?temp,\n      timestamp: -&gt;(ts) { Time.now - ts &lt; 300 }  # Within 5 minutes\n    })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    puts \"Recent spike: #{bindings[:?temp]}\u00b0F\"\n  end\nend\n</code></pre>"},{"location":"quick-start/#threshold-comparison","title":"Threshold Comparison","text":"<pre><code>rule = KBS::Rule.new(\"above_threshold\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:reading, { sensor: :?id, value: :?val }),\n    KBS::Condition.new(:threshold, { sensor: :?id, max: :?max })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:?val] &gt; bindings[:?max]\n      puts \"Threshold exceeded!\"\n    end\n  end\nend\n</code></pre>"},{"location":"quick-start/#state-machine","title":"State Machine","text":"<pre><code># Transition from \"init\" to \"ready\"\ntransition_rule = KBS::Rule.new(\"init_to_ready\") do |r|\n  r.conditions = [\n    KBS::Condition.new(:state, { current: \"init\" }),\n    KBS::Condition.new(:sensor, { initialized: true }),\n    # No \"ready\" state exists yet\n    KBS::Condition.new(:state, { current: \"ready\" }, negated: true)\n  ]\n\n  r.action = lambda do |facts|\n    # Remove old state\n    engine.remove_fact(facts[0])\n    # Add new state\n    engine.add_fact(:state, current: \"ready\")\n  end\nend\n</code></pre>"},{"location":"quick-start/#tips","title":"Tips","text":"<ol> <li>Use descriptive rule names: Makes debugging easier</li> <li>Set priorities: Higher priority rules fire first</li> <li>Call <code>run()</code> explicitly: Rules don't fire automatically</li> <li>Leverage negation: Express \"when X is absent\" naturally</li> <li>Profile performance: Use <code>advanced/debugging.md</code> techniques</li> </ol> <p>Ready to dive deeper? Check out the Writing Rules Guide!</p>"},{"location":"advanced/","title":"Advanced Topics","text":"<p>techniques and optimizations.</p> <ul> <li>Performance Tuning - Optimize for production</li> <li>Custom Persistence - Build your own backend</li> <li>Debugging - Network inspection and tracing</li> <li>Testing Rules - Test strategies for rule-based systems</li> </ul>"},{"location":"advanced/custom-persistence/","title":"Custom Persistence","text":"<p>Coming soon: Building custom storage backends.</p>"},{"location":"advanced/custom-persistence/#topics","title":"Topics","text":"<ul> <li>Store interface</li> <li>Implementation guide</li> <li>Testing strategies</li> <li>Performance considerations</li> </ul>"},{"location":"advanced/debugging/","title":"Debugging","text":"<p>Coming soon: Network inspection and tracing techniques.</p>"},{"location":"advanced/debugging/#topics","title":"Topics","text":"<ul> <li>Network visualization</li> <li>Token tracing</li> <li>Fact inspection</li> <li>Rule execution logging</li> </ul>"},{"location":"advanced/performance/","title":"Performance Tuning","text":"<p>Coming soon: Profiling and optimization guide.</p>"},{"location":"advanced/performance/#topics","title":"Topics","text":"<ul> <li>Benchmarking</li> <li>Condition ordering</li> <li>Network sharing</li> <li>Backend selection</li> <li>Profiling tools</li> </ul>"},{"location":"advanced/testing/","title":"Testing Rules","text":"<p>Coming soon: Testing strategies for rule-based systems.</p>"},{"location":"advanced/testing/#topics","title":"Topics","text":"<ul> <li>Unit testing rules</li> <li>Integration testing</li> <li>Test fixtures</li> <li>Coverage strategies</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete class documentation for KBS.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":"<ul> <li>Engine - Main RETE engine</li> <li>Facts &amp; Conditions - Pattern matching</li> <li>Rules - Production rules</li> <li>Blackboard - Persistent memory</li> </ul>"},{"location":"api/#architecture","title":"Architecture","text":"<p>See Architecture Overview for system design.</p>"},{"location":"api/blackboard/","title":"Blackboard API","text":"<p>Coming soon: Blackboard classes reference.</p> <p>See: - <code>lib/kbs/blackboard/engine.rb</code> - <code>lib/kbs/blackboard/memory.rb</code> - <code>lib/kbs/blackboard/persistence/</code></p>"},{"location":"api/engine/","title":"Engine API","text":"<p>Coming soon: Complete Engine class reference.</p> <p>See <code>lib/kbs/engine.rb</code> for implementation.</p>"},{"location":"api/engine/#main-methods","title":"Main Methods","text":"<ul> <li><code>initialize</code></li> <li><code>add_rule(rule)</code></li> <li><code>add_fact(type, attributes)</code></li> <li><code>remove_fact(fact)</code></li> <li><code>run</code></li> </ul>"},{"location":"api/facts/","title":"Facts &amp; Conditions API","text":"<p>Coming soon: Fact and Condition class reference.</p> <p>See: - <code>lib/kbs/fact.rb</code> - <code>lib/kbs/condition.rb</code></p>"},{"location":"api/rules/","title":"Rule API","text":"<p>Coming soon: Rule class reference.</p> <p>See <code>lib/kbs/rule.rb</code> for implementation.</p>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>KBS is built on a layered architecture that separates concerns while maintaining high performance.</p>"},{"location":"architecture/#system-layers","title":"System Layers","text":"<p>KBS uses a layered architecture where facts flow from your application through the DSL, RETE engine, and working memory to one of two storage backends.</p>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#1-rete-engine","title":"1. RETE Engine","text":"<p>The heart of KBS. Implements Charles Forgy's RETE algorithm with modern optimizations.</p> <p>Key Files: - <code>lib/kbs/rete_engine.rb</code> - Main engine coordinator - <code>lib/kbs/alpha_memory.rb</code> - Pattern-level fact storage - <code>lib/kbs/beta_memory.rb</code> - Token (partial match) storage - <code>lib/kbs/join_node.rb</code> - Inter-condition joins - <code>lib/kbs/negation_node.rb</code> - Negated condition handling - <code>lib/kbs/production_node.rb</code> - Rule firing coordination</p> <p>Responsibilities: - Compile rules into discrimination networks - Propagate fact changes through the network - Maintain partial matches (tokens) - Fire rules when all conditions are satisfied</p> <p>Learn more: RETE Algorithm Details</p>"},{"location":"architecture/#2-working-memory","title":"2. Working Memory","text":"<p>Stores facts and notifies the RETE engine of changes using the Observer pattern.</p> <p>Variants: - <code>WorkingMemory</code>: Transient in-memory storage - <code>Blackboard::Memory</code>: Persistent storage with audit trails</p> <p>Responsibilities: - Store facts - Notify observers when facts are added/removed - Support queries and bulk operations</p> <p>Learn more: Blackboard Architecture</p>"},{"location":"architecture/#3-dsl-layer","title":"3. DSL Layer","text":"<p>Provides a Ruby-native interface for defining rules, conditions, and patterns.</p> <p>Key Classes: - <code>Rule</code> - Production rule with conditions and actions - <code>Condition</code> - Pattern specification for fact matching - <code>Fact</code> - Knowledge representation unit</p> <p>Example: <pre><code>Rule.new(\"alert\") do |r|\n  r.conditions = [\n    Condition.new(:sensor, { temp: :?t }),\n    Condition.new(:threshold, { max: :?max })\n  ]\n\n  r.action = lambda { |facts, bindings|\n    puts \"Alert!\" if bindings[:?t] &gt; bindings[:?max]\n  }\nend\n</code></pre></p>"},{"location":"architecture/#4-blackboard-system","title":"4. Blackboard System","text":"<p>Multi-agent collaboration framework with persistent shared memory.</p> <p>Components: - Memory - Central workspace for facts - MessageQueue - Priority-based agent communication - AuditLog - Complete history of changes - Persistence - Pluggable storage backends (SQLite, Redis, Hybrid)</p> <p>Use Cases: - Multi-agent problem solving - Audit requirements - Long-running systems - Distributed reasoning</p> <p>Learn more: Blackboard System Details</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#adding-a-fact","title":"Adding a Fact","text":"<pre><code>User Code\n   \u2502\n   \u251c\u2500\u2192 engine.add_fact(:stock, price: 150)\n   \u2502\n   \u25bc\nWorkingMemory.add_fact(fact)\n   \u2502\n   \u251c\u2500\u2192 @facts &lt;&lt; fact\n   \u2514\u2500\u2192 notify_observers(:add, fact)\n          \u2502\n          \u25bc\n       Engine.update(:add, fact)\n          \u2502\n          \u2514\u2500\u2192 For each AlphaMemory:\n                 if fact.matches?(pattern)\n                    \u2502\n                    \u25bc\n                 AlphaMemory.activate(fact)\n                    \u2502\n                    \u2514\u2500\u2192 JoinNode.right_activate(fact)\n                           \u2502\n                           \u2514\u2500\u2192 Create tokens, propagate...\n                                  \u2502\n                                  \u25bc\n                               ProductionNode\n</code></pre>"},{"location":"architecture/#firing-rules","title":"Firing Rules","text":"<pre><code>User Code\n   \u2502\n   \u251c\u2500\u2192 engine.run()\n   \u2502\n   \u25bc\nFor each ProductionNode:\n   \u2502\n   \u251c\u2500\u2192 For each token:\n   \u2502      \u2502\n   \u2502      \u2514\u2500\u2192 rule.fire(token.facts)\n   \u2502             \u2502\n   \u2502             \u2514\u2500\u2192 Extract bindings\n   \u2502                    \u2502\n   \u2502                    \u2514\u2500\u2192 Execute action lambda\n   \u2502                           \u2502\n   \u2502                           \u2514\u2500\u2192 User code in action\n   \u2502\n   \u2514\u2500\u2192 Mark tokens as fired\n</code></pre>"},{"location":"architecture/#network-compilation","title":"Network Compilation","text":"<p>When you add a rule, KBS compiles it into a discrimination network:</p> <pre><code>rule = Rule.new(\"example\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :?sym }),\n    Condition.new(:alert, { symbol: :?sym }, negated: true)\n  ]\n  r.action = -&gt;(facts, bindings) { puts bindings[:?sym] }\nend\n\nengine.add_rule(rule)\n</code></pre> <p>Compiled Network:</p> <p></p> <p>The rule compiles into a network with alpha memories for each condition type, join nodes to combine matches, a negation node for the NOT condition, and a production node that fires when all conditions are satisfied.</p> <p>Learn more: Network Structure</p>"},{"location":"architecture/#performance-characteristics","title":"Performance Characteristics","text":"Operation Complexity Notes Add rule O(C \u00d7 F) C = conditions, F = existing facts Add fact O(N) N = activated nodes (typically &lt;&lt; total) Remove fact O(T) T = tokens containing fact Fire rules O(M) M = complete matches Network sharing O(1) Same pattern \u2192 same alpha memory"},{"location":"architecture/#design-principles","title":"Design Principles","text":""},{"location":"architecture/#1-algorithm-fidelity","title":"1. Algorithm Fidelity","text":"<p>Maintain RETE correctness per Forgy's specifications. No shortcuts that break semantics.</p>"},{"location":"architecture/#2-separation-of-concerns","title":"2. Separation of Concerns","text":"<ul> <li>Engine: Pattern matching</li> <li>Memory: Storage</li> <li>DSL: User interface</li> <li>Blackboard: Collaboration</li> </ul> <p>Each component is independently testable and swappable.</p>"},{"location":"architecture/#3-performance-through-clarity","title":"3. Performance Through Clarity","text":"<p>Optimize algorithm first (unlinking, network sharing), then profile before micro-optimizations.</p>"},{"location":"architecture/#4-testability","title":"4. Testability","text":"<p>Every method testable in isolation. Dependency injection for external services.</p>"},{"location":"architecture/#5-graceful-degradation","title":"5. Graceful Degradation","text":"<p>Optional features (Redis, AI) don't block core functionality. Fallback to SQLite or in-memory.</p>"},{"location":"architecture/#6-auditability","title":"6. Auditability","text":"<p>Complete audit trails for production systems. Know why a rule fired.</p>"},{"location":"architecture/#extension-points","title":"Extension Points","text":""},{"location":"architecture/#custom-persistence","title":"Custom Persistence","text":"<p>Implement <code>KBS::Blackboard::Persistence::Store</code>:</p> <pre><code>class MyStore\n  def save_fact(fact) ... end\n  def load_facts(type) ... end\n  def delete_fact(id) ... end\n  # ...\nend\n\nengine = KBS::Blackboard::Engine.new(store: MyStore.new)\n</code></pre>"},{"location":"architecture/#custom-pattern-matching","title":"Custom Pattern Matching","text":"<p>Override <code>Fact#matches?</code>:</p> <pre><code>class MyFact &lt; KBS::Fact\n  def matches?(pattern)\n    # Custom matching logic\n  end\nend\n</code></pre>"},{"location":"architecture/#custom-rule-actions","title":"Custom Rule Actions","text":"<p>Actions are lambdas - inject any Ruby code:</p> <pre><code>r.action = lambda do |facts, bindings|\n  send_email(bindings[:?alert])\n  log_to_database(facts)\n  trigger_api_call(bindings)\nend\n</code></pre>"},{"location":"architecture/#file-organization","title":"File Organization","text":"<pre><code>lib/kbs/\n\u251c\u2500\u2500 rete_engine.rb         # Main engine\n\u251c\u2500\u2500 working_memory.rb      # Fact storage\n\u251c\u2500\u2500 fact.rb                # Fact representation\n\u251c\u2500\u2500 rule.rb                # Rule definition\n\u251c\u2500\u2500 condition.rb           # Pattern specification\n\u251c\u2500\u2500 token.rb               # Partial match\n\u251c\u2500\u2500 alpha_memory.rb        # Pattern-level cache\n\u251c\u2500\u2500 beta_memory.rb         # Token storage\n\u251c\u2500\u2500 join_node.rb           # Inter-condition joins\n\u251c\u2500\u2500 negation_node.rb       # Negated conditions\n\u251c\u2500\u2500 production_node.rb     # Rule firing\n\u2514\u2500\u2500 blackboard/            # Persistent memory\n    \u251c\u2500\u2500 engine.rb          # Blackboard-aware RETE\n    \u251c\u2500\u2500 memory.rb          # Central workspace\n    \u251c\u2500\u2500 fact.rb            # Persisted fact\n    \u251c\u2500\u2500 message_queue.rb   # Agent communication\n    \u251c\u2500\u2500 audit_log.rb       # Change history\n    \u2514\u2500\u2500 persistence/       # Storage backends\n        \u251c\u2500\u2500 store.rb       # Abstract interface\n        \u251c\u2500\u2500 sqlite_store.rb\n        \u251c\u2500\u2500 redis_store.rb\n        \u2514\u2500\u2500 hybrid_store.rb\n</code></pre>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<ul> <li>RETE Algorithm - Deep dive into pattern matching</li> <li>Blackboard System - Persistent memory architecture</li> <li>Network Structure - How rules compile into networks</li> <li>API Reference - Complete class documentation</li> </ul>"},{"location":"architecture/blackboard/","title":"Blackboard Architecture","text":"<p>The Blackboard pattern is a powerful approach to multi-agent problem-solving where independent knowledge sources collaborate through a shared workspace.</p>"},{"location":"architecture/blackboard/#overview","title":"Overview","text":"<p>Blackboard system with multiple agents reading and writing to shared persistent memory with pluggable storage backends.</p>"},{"location":"architecture/blackboard/#core-concept","title":"Core Concept","text":"<p>The blackboard architecture consists of three main components:</p> <ol> <li>Blackboard (Memory): Central shared workspace for facts</li> <li>Knowledge Sources (Agents): Independent experts that read and write facts</li> <li>Control Component: Coordinates agent execution (often via rules)</li> </ol> <p>Agents operate asynchronously, triggered by changes to the blackboard state. Each agent: - Reads relevant facts from the blackboard - Performs reasoning or computation - Writes conclusions back to the blackboard - Triggers other agents via fact changes</p>"},{"location":"architecture/blackboard/#kbs-implementation","title":"KBS Implementation","text":""},{"location":"architecture/blackboard/#blackboardmemory","title":"Blackboard::Memory","text":"<p>The central workspace that replaces <code>WorkingMemory</code> with persistence:</p> <pre><code>require 'kbs/blackboard'\n\n# Create blackboard with SQLite backend\nmemory = KBS::Blackboard::Memory.new(db_path: 'knowledge_base.db')\n\n# Add facts (persisted automatically)\nfact = memory.add_fact(:stock, {\n  symbol: \"AAPL\",\n  price: 150.50,\n  timestamp: Time.now\n})\n# =&gt; #&lt;KBS::Blackboard::Fact uuid=\"abc-123\" ...&gt;\n\n# Query facts\nstocks = memory.facts_of_type(:stock)\n# =&gt; [#&lt;KBS::Blackboard::Fact ...&gt;, ...]\n\n# Facts survive process restart\nmemory2 = KBS::Blackboard::Memory.new(db_path: 'knowledge_base.db')\nmemory2.facts_of_type(:stock)\n# =&gt; Still there!\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/memory.rb</code></p>"},{"location":"architecture/blackboard/#blackboardengine","title":"Blackboard::Engine","text":"<p>RETE engine with persistent blackboard memory:</p> <pre><code># Create engine with blackboard\nengine = KBS::Blackboard::Engine.new(db_path: 'trading.db')\n\n# Define rules (persisted in the database)\nengine.add_rule(Rule.new(\"buy_signal\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :?sym, price: :?price }),\n    Condition.new(:threshold, { symbol: :?sym, max: :?max })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:?price] &lt; bindings[:?max]\n      # Write new fact to blackboard\n      engine.add_fact(:order, {\n        symbol: bindings[:?sym],\n        action: \"BUY\",\n        price: bindings[:?price]\n      })\n    end\n  end\nend)\n\n# Facts trigger rules, which create new facts\nengine.add_fact(:stock, symbol: \"AAPL\", price: 145.0)\nengine.add_fact(:threshold, symbol: \"AAPL\", max: 150.0)\nengine.run\n# =&gt; Creates :order fact in blackboard\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/engine.rb</code></p>"},{"location":"architecture/blackboard/#message-queue","title":"Message Queue","text":"<p>Priority-based communication between agents:</p> <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'system.db')\nqueue = memory.message_queue\n\n# Agent 1: Post high-priority message\nqueue.post(\"risk_analysis\", {\n  alert: \"High volatility detected\",\n  severity: \"critical\"\n}, priority: 10)\n\n# Agent 2: Read and process messages\nmessages = queue.read(\"risk_analysis\", limit: 5)\nmessages.each do |msg|\n  puts \"Processing: #{msg[:data][:alert]}\"\n  queue.acknowledge(msg[:id])\nend\n\n# Unacknowledged messages remain in queue\npending = queue.pending(\"risk_analysis\")\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/message_queue.rb</code></p>"},{"location":"architecture/blackboard/#audit-log","title":"Audit Log","text":"<p>Complete history of all changes for compliance and debugging:</p> <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'audit.db')\naudit = memory.audit_log\n\n# All fact changes are logged automatically\nfact = memory.add_fact(:stock, symbol: \"AAPL\", price: 150)\nmemory.update_fact(fact.id, price: 155)\nmemory.remove_fact(fact)\n\n# Query audit trail\nhistory = audit.fact_history(fact.id)\n# =&gt; [\n#   { action: \"created\", timestamp: ..., data: {price: 150} },\n#   { action: \"updated\", timestamp: ..., data: {price: 155} },\n#   { action: \"deleted\", timestamp: ... }\n# ]\n\n# See what rules fired\nrule_log = audit.rules_fired(limit: 10)\n# =&gt; [\n#   { rule_name: \"buy_signal\", timestamp: ..., facts: [...] },\n#   ...\n# ]\n\n# Recent changes across all facts\nrecent = audit.recent_changes(limit: 20)\n</code></pre> <p>Implementation: <code>lib/kbs/blackboard/audit_log.rb</code></p>"},{"location":"architecture/blackboard/#persistence-backends","title":"Persistence Backends","text":""},{"location":"architecture/blackboard/#sqlite-store-default","title":"SQLite Store (Default)","text":"<p>Best for: Single-process applications, development, small-to-medium data.</p> <pre><code>engine = KBS::Blackboard::Engine.new(db_path: 'kb.db')\n</code></pre> <p>Pros: - \u2705 Zero configuration (no server needed) - \u2705 ACID transactions - \u2705 Durable across restarts - \u2705 Simple backup (copy .db file) - \u2705 Full-text search capabilities</p> <p>Cons: - \u26a0\ufe0f Slower than Redis (still fast for most use cases) - \u26a0\ufe0f Single-writer limitation - \u26a0\ufe0f Not distributed</p> <p>Schema: <pre><code>CREATE TABLE facts (\n  id TEXT PRIMARY KEY,\n  fact_type TEXT NOT NULL,\n  attributes TEXT NOT NULL, -- JSON\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE audit_log (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  fact_id TEXT,\n  action TEXT NOT NULL,\n  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n  data TEXT -- JSON\n);\n\nCREATE TABLE messages (\n  id TEXT PRIMARY KEY,\n  topic TEXT NOT NULL,\n  priority INTEGER DEFAULT 0,\n  data TEXT NOT NULL, -- JSON\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n  acknowledged BOOLEAN DEFAULT 0\n);\n</code></pre></p> <p>Implementation: <code>lib/kbs/blackboard/persistence/sqlite_store.rb</code></p>"},{"location":"architecture/blackboard/#redis-store","title":"Redis Store","text":"<p>Best for: High-throughput applications, distributed systems, real-time trading.</p> <pre><code>store = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0'\n)\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>Pros: - \u2705 100x faster than SQLite for reads/writes - \u2705 Supports distributed agents (multiple processes, machines) - \u2705 Built-in pub/sub for real-time notifications - \u2705 Atomic operations - \u2705 TTL support for ephemeral facts</p> <p>Cons: - \u26a0\ufe0f Requires Redis server - \u26a0\ufe0f Volatile by default (enable RDB/AOF for durability) - \u26a0\ufe0f More complex deployment</p> <p>Data Structures: <pre><code># Facts stored as Redis hashes\nfact:{uuid} \u2192 { type: \"stock\", symbol: \"AAPL\", price: 150 }\n\n# Indexes for efficient queries\nfacts:type:stock \u2192 Set of fact UUIDs\nfacts:active \u2192 Set of all active fact UUIDs\n\n# Messages as sorted sets (by priority)\nmessages:risk_alerts \u2192 ZSet[(msg1, priority), (msg2, priority), ...]\n\n# Audit as lists\nfact_history:{uuid} \u2192 List of change records\nrules_fired:all \u2192 List of rule executions\n</code></pre></p> <p>Implementation: <code>lib/kbs/blackboard/persistence/redis_store.rb</code></p>"},{"location":"architecture/blackboard/#hybrid-store","title":"Hybrid Store","text":"<p>Best for: Production systems needing speed + durability + audit.</p> <pre><code>store = KBS::Blackboard::Persistence::HybridStore.new(\n  redis_url: 'redis://localhost:6379/0',\n  db_path: 'audit.db'\n)\nengine = KBS::Blackboard::Engine.new(store: store)\n</code></pre> <p>Strategy: - Redis: Facts and messages (fast access) - SQLite: Audit log (durable history)</p> <p>Pros: - \u2705 Fast fact operations (Redis) - \u2705 Durable audit trail (SQLite) - \u2705 Best of both worlds</p> <p>Cons: - \u26a0\ufe0f Requires both Redis and SQLite - \u26a0\ufe0f Slightly more complex</p> <p>Implementation: <code>lib/kbs/blackboard/persistence/hybrid_store.rb</code></p>"},{"location":"architecture/blackboard/#multi-agent-example","title":"Multi-Agent Example","text":"<p>Trading system with four specialized agents:</p> <pre><code># Shared blackboard\nblackboard = KBS::Blackboard::Engine.new(db_path: 'trading.db')\n\n# Agent 1: Market Data Collector\ndata_agent = KBS::Rule.new(\"collect_data\", priority: 5) do |r|\n  r.conditions = [\n    Condition.new(:market_open, { status: true }),\n    Condition.new(:stock_data, { symbol: :?sym }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    price = fetch_current_price(bindings[:?sym])\n    blackboard.add_fact(:stock_data, {\n      symbol: bindings[:?sym],\n      price: price,\n      timestamp: Time.now\n    })\n  end\nend\n\n# Agent 2: Signal Generator\nsignal_agent = KBS::Rule.new(\"generate_signals\", priority: 10) do |r|\n  r.conditions = [\n    Condition.new(:stock_data, { symbol: :?sym, price: :?price }),\n    Condition.new(:sma_data, { symbol: :?sym, sma: :?sma })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:?price] &gt; bindings[:?sma]\n      blackboard.add_fact(:signal, {\n        symbol: bindings[:?sym],\n        direction: \"BUY\",\n        strength: (bindings[:?price] / bindings[:?sma]) - 1.0\n      })\n    end\n  end\nend\n\n# Agent 3: Risk Manager\nrisk_agent = KBS::Rule.new(\"check_risk\", priority: 20) do |r|\n  r.conditions = [\n    Condition.new(:signal, { symbol: :?sym, direction: :?dir }),\n    Condition.new(:portfolio, { symbol: :?sym, position: :?pos })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:?pos] &gt; 1000 &amp;&amp; bindings[:?dir] == \"BUY\"\n      blackboard.add_fact(:risk_alert, {\n        symbol: bindings[:?sym],\n        reason: \"Position limit exceeded\"\n      })\n    else\n      blackboard.add_fact(:approved_signal, {\n        symbol: bindings[:?sym],\n        direction: bindings[:?dir]\n      })\n    end\n  end\nend\n\n# Agent 4: Order Executor\nexec_agent = KBS::Rule.new(\"execute_orders\", priority: 30) do |r|\n  r.conditions = [\n    Condition.new(:approved_signal, { symbol: :?sym, direction: :?dir }),\n    Condition.new(:risk_alert, { symbol: :?sym }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    execute_trade(bindings[:?sym], bindings[:?dir])\n    blackboard.add_fact(:execution, {\n      symbol: bindings[:?sym],\n      direction: bindings[:?dir],\n      timestamp: Time.now\n    })\n  end\nend\n\n# Register all agents\n[data_agent, signal_agent, risk_agent, exec_agent].each do |agent|\n  blackboard.add_rule(agent)\nend\n\n# Trigger the system\nblackboard.add_fact(:market_open, status: true)\nblackboard.add_fact(:portfolio, symbol: \"AAPL\", position: 500)\n\n# Agents collaborate through blackboard\nblackboard.run\n</code></pre>"},{"location":"architecture/blackboard/#transactions","title":"Transactions","text":"<p>Ensure atomic multi-fact updates:</p> <pre><code>memory = KBS::Blackboard::Memory.new(db_path: 'trades.db')\n\nmemory.transaction do\n  # All or nothing\n  order = memory.add_fact(:order, {\n    symbol: \"AAPL\",\n    action: \"BUY\",\n    quantity: 100\n  })\n\n  execution = memory.add_fact(:execution, {\n    order_id: order.id,\n    price: 150.50,\n    timestamp: Time.now\n  })\n\n  memory.update_fact(order.id, status: \"filled\")\n\n  # If any operation fails, entire transaction rolls back\nend\n</code></pre> <p>Nested transactions are supported via reference counting.</p>"},{"location":"architecture/blackboard/#best-practices","title":"Best Practices","text":""},{"location":"architecture/blackboard/#1-agent-specialization","title":"1. Agent Specialization","text":"<p>Each agent should focus on one aspect of the problem: - \u2705 Data collection - \u2705 Signal generation - \u2705 Risk assessment - \u2705 Execution</p>"},{"location":"architecture/blackboard/#2-priority-based-execution","title":"2. Priority-Based Execution","text":"<p>Use rule priorities to ensure correct agent ordering: <pre><code>data_collector:  priority: 5\nsignal_generator: priority: 10\nrisk_manager:     priority: 20\nexecutor:         priority: 30\n</code></pre></p>"},{"location":"architecture/blackboard/#3-fact-versioning","title":"3. Fact Versioning","text":"<p>Include timestamps for temporal reasoning: <pre><code>engine.add_fact(:price, {\n  symbol: \"AAPL\",\n  value: 150,\n  timestamp: Time.now,\n  source: \"market_data_feed\"\n})\n</code></pre></p>"},{"location":"architecture/blackboard/#4-message-acknowledgment","title":"4. Message Acknowledgment","text":"<p>Always acknowledge processed messages: <pre><code>messages = queue.read(\"alerts\", limit: 10)\nmessages.each do |msg|\n  process_alert(msg[:data])\n  queue.acknowledge(msg[:id])  # Important!\nend\n</code></pre></p>"},{"location":"architecture/blackboard/#5-audit-everything","title":"5. Audit Everything","text":"<p>Use audit log for debugging and compliance: <pre><code># When something goes wrong, trace back\naudit = memory.audit_log\nchanges = audit.recent_changes(limit: 100)\nchanges.each do |change|\n  puts \"#{change[:timestamp]}: #{change[:action]} on #{change[:fact_type]}\"\nend\n</code></pre></p>"},{"location":"architecture/blackboard/#performance-tuning","title":"Performance Tuning","text":""},{"location":"architecture/blackboard/#choose-the-right-backend","title":"Choose the Right Backend","text":"Backend Use Case Performance Durability SQLite Development, single-process Good Excellent Redis High-frequency trading, distributed Excellent Good (with AOF) Hybrid Production systems Excellent Excellent"},{"location":"architecture/blackboard/#batch-operations","title":"Batch Operations","text":"<pre><code># Bad: Individual adds (slow)\n1000.times do |i|\n  memory.add_fact(:reading, sensor: i, value: rand)\nend\n\n# Good: Transaction batch (fast)\nmemory.transaction do\n  1000.times do |i|\n    memory.add_fact(:reading, sensor: i, value: rand)\n  end\nend\n</code></pre>"},{"location":"architecture/blackboard/#index-strategy-sqlite","title":"Index Strategy (SQLite)","text":"<pre><code>-- Add indexes for frequent queries\nCREATE INDEX idx_facts_type ON facts(fact_type);\nCREATE INDEX idx_facts_created ON facts(created_at);\nCREATE INDEX idx_messages_topic ON messages(topic, priority);\n</code></pre>"},{"location":"architecture/blackboard/#redis-memory-management","title":"Redis Memory Management","text":"<pre><code># Set TTL for ephemeral facts\nstore = KBS::Blackboard::Persistence::RedisStore.new(\n  url: 'redis://localhost:6379/0',\n  ttl: 3600  # Facts expire after 1 hour\n)\n</code></pre>"},{"location":"architecture/blackboard/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"architecture/blackboard/#opportunistic-triggering","title":"Opportunistic Triggering","text":"<p>Agents activate when their preconditions are met:</p> <pre><code># Trigger fires only when specific fact exists\ntrigger_rule = Rule.new(\"on_critical_alert\") do |r|\n  r.conditions = [\n    Condition.new(:alert, { severity: \"critical\" })\n  ]\n\n  r.action = lambda { |facts|\n    notify_team(facts[0])\n  end\nend\n</code></pre>"},{"location":"architecture/blackboard/#blackboard-focus","title":"Blackboard Focus","text":"<p>Limit agent attention to relevant facts:</p> <pre><code># Agent only sees recent stock data\nrecent_data_rule = Rule.new(\"analyze_recent\") do |r|\n  r.conditions = [\n    Condition.new(:stock_data, {\n      symbol: :?sym,\n      timestamp: -&gt;(ts) { Time.now - ts &lt; 300 }  # Last 5 minutes\n    })\n  ]\n\n  r.action = lambda { |facts, bindings|\n    # Process recent data only\n  }\nend\n</code></pre>"},{"location":"architecture/blackboard/#conflict-resolution","title":"Conflict Resolution","text":"<p>When multiple agents could act, use priorities:</p> <pre><code># High priority: Stop-loss overrides everything\nstop_loss = Rule.new(\"stop_loss\", priority: 100)\n\n# Medium priority: Risk management\nrisk_check = Rule.new(\"risk_check\", priority: 50)\n\n# Low priority: Normal trading signals\nbuy_signal = Rule.new(\"buy\", priority: 10)\n</code></pre>"},{"location":"architecture/blackboard/#next-steps","title":"Next Steps","text":"<ul> <li>Network Structure - How blackboard integrates with RETE</li> <li>Persistence Guide - Choosing and configuring backends</li> <li>Multi-Agent Example - Complete working system</li> <li>Custom Persistence - Build your own backend</li> </ul>"},{"location":"architecture/network-structure/","title":"Network Structure","text":"<p>How RETE compiles rules into an efficient discrimination network.</p>"},{"location":"architecture/network-structure/#overview","title":"Overview","text":"<p>When you add a rule to the engine, KBS compiles it into a discrimination network\u2014a directed acyclic graph (DAG) of nodes that efficiently matches patterns against facts. This document explains the compilation process, node types, and optimization strategies.</p>"},{"location":"architecture/network-structure/#network-compilation-process","title":"Network Compilation Process","text":""},{"location":"architecture/network-structure/#step-1-parse-rule-conditions","title":"Step 1: Parse Rule Conditions","text":"<pre><code>rule = Rule.new(\"example\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :?sym, price: :?price }),\n    Condition.new(:threshold, { symbol: :?sym, max: :?max })\n  ]\n  r.action = lambda { |facts, bindings| ... }\nend\n</code></pre> <p>The engine extracts: - Condition types (<code>:stock</code>, <code>:threshold</code>) - Patterns (attribute constraints) - Variable bindings (<code>:?sym</code>, <code>:?price</code>, <code>:?max</code>) - Join tests (<code>:?sym</code> appears in both conditions)</p>"},{"location":"architecture/network-structure/#step-2-create-or-reuse-alpha-memories","title":"Step 2: Create or Reuse Alpha Memories","text":"<p>For each condition, the engine creates or reuses an <code>AlphaMemory</code> node:</p> <pre><code># Pattern for first condition\npattern1 = { type: :stock, symbol: :?sym, price: :?price }\nalpha1 = get_or_create_alpha_memory(pattern1)\n\n# Pattern for second condition\npattern2 = { type: :threshold, symbol: :?sym, max: :?max }\nalpha2 = get_or_create_alpha_memory(pattern2)\n</code></pre> <p>Network Sharing: If another rule has the same pattern, they share the same alpha memory node.</p>"},{"location":"architecture/network-structure/#step-3-build-join-network","title":"Step 3: Build Join Network","text":"<p>Connect conditions through join nodes:</p> <pre><code># Start with root beta memory (contains dummy token)\ncurrent_beta = @root_beta_memory\n\n# For each condition\nrule.conditions.each do |condition|\n  alpha_memory = get_or_create_alpha_memory(condition.pattern)\n\n  # Build join tests for variable consistency\n  tests = extract_join_tests(condition)\n\n  # Create join or negation node\n  if condition.negated\n    node = NegationNode.new(alpha_memory, current_beta, tests)\n  else\n    node = JoinNode.new(alpha_memory, current_beta, tests)\n  end\n\n  # Create beta memory to store results\n  new_beta = BetaMemory.new\n  node.successors &lt;&lt; new_beta\n  current_beta = new_beta\nend\n</code></pre>"},{"location":"architecture/network-structure/#step-4-attach-production-node","title":"Step 4: Attach Production Node","text":"<pre><code>production_node = ProductionNode.new(rule)\ncurrent_beta.successors &lt;&lt; production_node\n@production_nodes[rule.name] = production_node\n</code></pre>"},{"location":"architecture/network-structure/#node-types","title":"Node Types","text":""},{"location":"architecture/network-structure/#alpha-memory-nodes","title":"Alpha Memory Nodes","text":"<p>Purpose: Store facts matching a specific pattern</p> <p>Structure: <pre><code>class AlphaMemory\n  attr_accessor :items      # Facts that match pattern\n  attr_accessor :successors # Join nodes using this alpha\n  attr_accessor :pattern    # Pattern to match\n  attr_reader :linked       # Unlinking state\nend\n</code></pre></p> <p>Example: <pre><code>AlphaMemory(stock, symbol: \"AAPL\")\n  items: [stock(symbol: \"AAPL\", price: 150), ...]\n  successors: [JoinNode1, JoinNode2, ...]\n</code></pre></p>"},{"location":"architecture/network-structure/#beta-memory-nodes","title":"Beta Memory Nodes","text":"<p>Purpose: Store partial matches (tokens) as they propagate</p> <p>Structure: <pre><code>class BetaMemory\n  attr_accessor :tokens     # Partial matches\n  attr_accessor :successors # Next nodes in network\n  attr_reader :linked       # Unlinking state\nend\n</code></pre></p> <p>Example: <pre><code>BetaMemory\n  tokens: [\n    Token(parent: root, fact: stock(...)),\n    Token(parent: root, fact: stock(...))\n  ]\n  successors: [JoinNode2]\n</code></pre></p>"},{"location":"architecture/network-structure/#join-nodes","title":"Join Nodes","text":"<p>Purpose: Combine facts from alpha memory with tokens from beta memory</p> <p>Structure: <pre><code>class JoinNode\n  attr_accessor :alpha_memory  # Right input\n  attr_accessor :beta_memory   # Left input\n  attr_accessor :tests         # Join tests to perform\n  attr_accessor :successors    # Beta memory nodes\nend\n</code></pre></p> <p>Join Tests: <pre><code>{\n  token_field_index: 0,    # Check first fact in token\n  token_field: :symbol,    # Get its :symbol attribute\n  fact_field: :symbol,     # Compare with new fact's :symbol\n  operation: :eq           # Must be equal\n}\n</code></pre></p>"},{"location":"architecture/network-structure/#negation-nodes","title":"Negation Nodes","text":"<p>Purpose: Implement negated conditions (match when pattern is absent)</p> <p>Structure: <pre><code>class NegationNode\n  attr_accessor :alpha_memory       # Pattern to check\n  attr_accessor :beta_memory        # Tokens to test\n  attr_accessor :tests              # Join tests\n  attr_accessor :tokens_with_matches # Track inhibiting facts\nend\n</code></pre></p> <p>Behavior: - Token arrives \u2192 check alpha memory for matches - No matches found \u2192 propagate token (condition satisfied) - Matches found \u2192 block token (condition not satisfied) - Match removed \u2192 unblock token</p>"},{"location":"architecture/network-structure/#production-nodes","title":"Production Nodes","text":"<p>Purpose: Fire rule actions when all conditions match</p> <p>Structure: <pre><code>class ProductionNode\n  attr_accessor :rule   # Rule to fire\n  attr_accessor :tokens # Complete matches ready to fire\nend\n</code></pre></p>"},{"location":"architecture/network-structure/#complete-example","title":"Complete Example","text":""},{"location":"architecture/network-structure/#rule-definition","title":"Rule Definition","text":"<pre><code>rule = Rule.new(\"trading_signal\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :?sym, price: :?price }),\n    Condition.new(:threshold, { symbol: :?sym, buy_below: :?threshold }),\n    Condition.new(:order, { symbol: :?sym }, negated: true)\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:?price] &lt; bindings[:?threshold]\n      puts \"BUY #{bindings[:?sym]}\"\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/network-structure/#compiled-network","title":"Compiled Network","text":"<p>The trading signal rule compiles into a network with three join points. The first two join nodes combine stock and threshold facts based on matching symbols. The negation node ensures no existing order for that symbol. Tokens propagate through beta memories, carrying partial matches until reaching the production node.</p>"},{"location":"architecture/network-structure/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"architecture/network-structure/#network-sharing","title":"Network Sharing","text":"<p>Multiple rules with common patterns share alpha memory nodes:</p> <pre><code># Rule 1\nCondition.new(:stock, { symbol: \"AAPL\" })\n\n# Rule 2\nCondition.new(:stock, { symbol: \"AAPL\" })\n\n# Both use the same AlphaMemory node\n# Only one pattern match, one fact storage\n</code></pre>"},{"location":"architecture/network-structure/#unlinking","title":"Unlinking","text":"<p>Empty nodes automatically disconnect to avoid wasted computation:</p> <pre><code># BetaMemory becomes empty\nbeta_memory.remove_token(last_token)\n# =&gt; Calls unlink!\n\n# Downstream nodes stop processing\njoin_node.left_activate(token)  # Returns early if !@left_linked\n</code></pre>"},{"location":"architecture/network-structure/#condition-ordering","title":"Condition Ordering","text":"<p>Place selective conditions first to minimize beta memory size:</p> <pre><code># Good: Specific condition first\nconditions = [\n  Condition.new(:critical_alert, { severity: \"critical\" }),  # Few matches\n  Condition.new(:stock, { symbol: :?sym })                   # Many matches\n]\n\n# Bad: General condition first\nconditions = [\n  Condition.new(:stock, { symbol: :?sym }),                  # Many matches\n  Condition.new(:critical_alert, { severity: \"critical\" })   # Few matches\n]\n</code></pre>"},{"location":"architecture/network-structure/#variable-binding-extraction","title":"Variable Binding Extraction","text":"<p>Variables create join tests automatically:</p> <pre><code># Rule with :?sym in two conditions\ntests = [\n  {\n    token_field_index: 0,     # First fact in token (stock)\n    token_field: :symbol,\n    fact_field: :symbol,      # New fact (threshold)\n    operation: :eq\n  }\n]\n</code></pre>"},{"location":"architecture/network-structure/#network-inspection","title":"Network Inspection","text":""},{"location":"architecture/network-structure/#debugging-network-structure","title":"Debugging Network Structure","text":"<pre><code># See all alpha memories\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern: #{pattern}\"\n  puts \"  Facts: #{memory.items.size}\"\n  puts \"  Linked: #{memory.linked}\"\n  puts \"  Successors: #{memory.successors.size}\"\nend\n\n# See production nodes\nengine.production_nodes.each do |name, node|\n  puts \"Rule: #{name}\"\n  puts \"  Tokens: #{node.tokens.size}\"\nend\n</code></pre>"},{"location":"architecture/network-structure/#visualizing-token-flow","title":"Visualizing Token Flow","text":"<p>Enable tracing in actions:</p> <pre><code>r.action = lambda do |facts, bindings|\n  puts \"Rule '#{rule.name}' fired\"\n  puts \"  Facts: #{facts.map(&amp;:to_s).join(', ')}\"\n  puts \"  Bindings: #{bindings.inspect}\"\nend\n</code></pre>"},{"location":"architecture/network-structure/#performance-implications","title":"Performance Implications","text":""},{"location":"architecture/network-structure/#time-complexity","title":"Time Complexity","text":"Operation Complexity Notes Add rule O(C \u00d7 F) C = conditions, F = facts Network sharing lookup O(1) Hash-based pattern cache Join test O(T) T = number of tests Token propagation O(S) S = successors"},{"location":"architecture/network-structure/#space-complexity","title":"Space Complexity","text":"Structure Space Notes Alpha memories O(P) P = unique patterns across all rules Beta memories O(R \u00d7 C) R = rules, C = avg conditions Tokens O(M \u00d7 C) M = complete matches Join nodes O(R \u00d7 C) One per condition"},{"location":"architecture/network-structure/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Maximize network sharing: Design rules to reuse common patterns</li> <li>Order conditions by selectivity: Specific first, general last</li> <li>Minimize negations: Expensive to maintain</li> <li>Use predicates sparingly: Can't be shared across rules</li> <li>Profile your rules: Use debugging to identify bottlenecks</li> </ol>"},{"location":"architecture/network-structure/#next-steps","title":"Next Steps","text":"<ul> <li>RETE Algorithm - Understand the full execution cycle</li> <li>Blackboard System - Persistent network state</li> <li>Performance Tuning - Optimize for production</li> <li>Debugging Guide - Inspect network state</li> </ul> <p>This document describes implementation details in <code>lib/kbs/rete_engine.rb:58</code> (network compilation) and related node classes.</p>"},{"location":"architecture/rete-algorithm/","title":"The RETE Algorithm in KBS","text":""},{"location":"architecture/rete-algorithm/#overview","title":"Overview","text":"<p>The RETE algorithm is a pattern matching algorithm for implementing production rule systems. Developed by Charles Forgy in 1979, RETE (Latin for \"network\") creates a discrimination network that efficiently matches rules against a working memory of facts. KBS implements the RETE algorithm with the critical unlinking optimization for improved performance.</p>"},{"location":"architecture/rete-algorithm/#why-rete","title":"Why RETE?","text":"<p>Traditional rule engines evaluate all rules against all facts on every cycle, resulting in O(R \u00d7 F) complexity where R is the number of rules and F is the number of facts. RETE achieves near-constant time per working memory change by:</p> <ol> <li>Sharing common patterns across rules in a compiled network</li> <li>Maintaining state between cycles (incremental matching)</li> <li>Processing only changes rather than re-evaluating everything</li> <li>Unlinking empty nodes to skip unnecessary computation (RETE optimization)</li> </ol>"},{"location":"architecture/rete-algorithm/#core-concepts","title":"Core Concepts","text":""},{"location":"architecture/rete-algorithm/#facts","title":"Facts","text":"<p>Facts are the fundamental units of knowledge in the system. Each fact has:</p> <ul> <li>Type: A symbol identifying the kind of fact (e.g., <code>:stock</code>, <code>:alert</code>, <code>:order</code>)</li> <li>Attributes: Key-value pairs containing the fact's data</li> <li>ID: A unique identifier (object_id for transient facts, UUID for persisted facts)</li> </ul> <pre><code># Creating a fact\nfact = engine.add_fact(:stock, symbol: \"AAPL\", price: 150.0, volume: 1000000)\n\n# Fact structure\n# =&gt; stock(symbol: AAPL, price: 150.0, volume: 1000000)\n</code></pre> <p>Implementation: <code>lib/kbs/fact.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#working-memory","title":"Working Memory","text":"<p>Working memory is the collection of all facts currently known to the system. It implements the Observer pattern to notify the RETE network when facts are added or removed.</p> <pre><code>class WorkingMemory\n  def add_fact(fact)\n    @facts &lt;&lt; fact\n    notify_observers(:add, fact)  # Triggers RETE propagation\n  end\n\n  def remove_fact(fact)\n    @facts.delete(fact)\n    notify_observers(:remove, fact)  # Triggers retraction\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/working_memory.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#conditions-and-patterns","title":"Conditions and Patterns","text":"<p>A condition specifies a pattern that facts must match. Patterns can include:</p> <ul> <li>Type matching: <code>{ type: :stock }</code></li> <li>Literal values: <code>{ symbol: \"AAPL\" }</code></li> <li>Variable bindings: <code>{ price: :?price }</code> (variables start with <code>?</code>)</li> <li>Predicates: <code>{ price: -&gt;(p) { p &gt; 100 } }</code></li> <li>Negation: <code>negated: true</code> (match when pattern is absent)</li> </ul> <pre><code># Match any stock with symbol \"AAPL\"\nCondition.new(:stock, { symbol: \"AAPL\" })\n\n# Match stock and bind price to ?price variable\nCondition.new(:stock, { symbol: \"AAPL\", price: :?price })\n\n# Match when there is NO alert for \"AAPL\"\nCondition.new(:alert, { symbol: \"AAPL\" }, negated: true)\n</code></pre> <p>Implementation: <code>lib/kbs/condition.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#rules","title":"Rules","text":"<p>Rules are production rules consisting of:</p> <ul> <li>Conditions (IF part): Patterns to match in working memory</li> <li>Action (THEN part): Code to execute when all conditions match</li> <li>Priority: Optional integer for conflict resolution (higher fires first)</li> </ul> <pre><code>rule = Rule.new(\"high_price_alert\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: :?symbol, price: :?price }),\n    Condition.new(:threshold, { symbol: :?symbol, max: :?max })\n  ]\n\n  r.action = lambda do |facts, bindings|\n    if bindings[:?price] &gt; bindings[:?max]\n      puts \"Alert: #{bindings[:?symbol]} at #{bindings[:?price]}\"\n    end\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/rule.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#tokens","title":"Tokens","text":"<p>Tokens represent partial matches as they flow through the RETE network. A token is a linked list of facts that have matched conditions so far.</p> <pre><code>class Token\n  attr_accessor :parent, :fact, :node, :children\n\n  # Reconstruct the full chain of matched facts\n  def facts\n    facts = []\n    token = self\n    while token\n      facts.unshift(token.fact) if token.fact\n      token = token.parent\n    end\n    facts\n  end\nend\n</code></pre> <p>Key insights: - The root token has <code>parent = nil</code>, <code>fact = nil</code> and represents \"no conditions matched yet\" - Each join creates a new token linking to its parent token plus a new fact - Tokens form a tree structure via the <code>children</code> array, enabling efficient retraction</p> <p>Implementation: <code>lib/kbs/token.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#network-architecture","title":"Network Architecture","text":"<p>The RETE network is a directed acyclic graph (DAG) consisting of three layers:</p> <p></p> <p>The three-layer RETE network architecture showing alpha memories (pattern matching), beta network (join processing), and production nodes (rule firing).</p>"},{"location":"architecture/rete-algorithm/#layer-1-alpha-network","title":"Layer 1: Alpha Network","text":"<p>The alpha network performs intra-condition tests - matching individual facts against patterns. Each <code>AlphaMemory</code> node:</p> <ul> <li>Stores facts matching a specific pattern</li> <li>Is shared across all rules using the same pattern (network sharing)</li> <li>Propagates matches to successor join nodes</li> </ul> <pre><code>class AlphaMemory\n  attr_accessor :items, :successors, :pattern\n\n  def activate(fact)\n    return unless @linked\n    @items &lt;&lt; fact\n    @successors.each { |s| s.right_activate(fact) }\n  end\nend\n</code></pre> <p>Example: If three rules all match <code>stock(symbol: \"AAPL\")</code>, they share one <code>AlphaMemory</code> node for that pattern.</p> <p>Implementation: <code>lib/kbs/alpha_memory.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#layer-2-beta-network","title":"Layer 2: Beta Network","text":"<p>The beta network performs inter-condition tests - joining facts from different conditions. It consists of:</p>"},{"location":"architecture/rete-algorithm/#join-nodes","title":"Join Nodes","text":"<p><code>JoinNode</code> combines tokens from beta memory (left input) with facts from alpha memory (right input):</p> <pre><code>class JoinNode\n  def left_activate(token)\n    return unless @left_linked &amp;&amp; @right_linked\n\n    @alpha_memory.items.each do |fact|\n      if perform_join_tests(token, fact)\n        new_token = Token.new(token, fact, self)\n        @successors.each { |s| s.activate(new_token) }\n      end\n    end\n  end\n\n  def right_activate(fact)\n    return unless @left_linked &amp;&amp; @right_linked\n\n    @beta_memory.tokens.each do |token|\n      if perform_join_tests(token, fact)\n        new_token = Token.new(token, fact, self)\n        @successors.each { |s| s.activate(new_token) }\n      end\n    end\n  end\nend\n</code></pre> <p>Join tests verify: - Variable consistency (e.g., both conditions match same <code>:?symbol</code>) - Cross-condition predicates (e.g., price1 &gt; price2)</p> <p>Implementation: <code>lib/kbs/join_node.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#beta-memory","title":"Beta Memory","text":"<p><code>BetaMemory</code> stores tokens (partial matches) and implements the unlinking optimization:</p> <pre><code>class BetaMemory\n  def add_token(token)\n    @tokens &lt;&lt; token\n    unlink! if @tokens.empty?     # Unlink when empty\n    relink! if @tokens.size == 1  # Relink when first token arrives\n  end\n\n  def remove_token(token)\n    @tokens.delete(token)\n    unlink! if @tokens.empty?     # Unlink when last token removed\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/beta_memory.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#negation-nodes","title":"Negation Nodes","text":"<p><code>NegationNode</code> implements negated conditions (e.g., \"when there is NO matching fact\"):</p> <pre><code>class NegationNode\n  def left_activate(token)\n    matches = @alpha_memory.items.select { |fact| perform_join_tests(token, fact) }\n\n    if matches.empty?\n      # No inhibiting facts found - propagate the token\n      new_token = Token.new(token, nil, self)\n      @successors.each { |s| s.activate(new_token) }\n    else\n      # Found inhibiting facts - block propagation\n      @tokens_with_matches[token] = matches\n    end\n  end\n\n  def right_deactivate(fact)\n    # When an inhibiting fact is removed, check if we can now propagate\n    @beta_memory.tokens.each do |token|\n      if @tokens_with_matches[token].include?(fact)\n        @tokens_with_matches[token].delete(fact)\n\n        if @tokens_with_matches[token].empty?\n          new_token = Token.new(token, nil, self)\n          @successors.each { |s| s.activate(new_token) }\n        end\n      end\n    end\n  end\nend\n</code></pre> <p>Key insight: Negation nodes propagate tokens with <code>fact = nil</code> since there's no actual fact to include.</p> <p>Implementation: <code>lib/kbs/negation_node.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#layer-3-production-nodes","title":"Layer 3: Production Nodes","text":"<p><code>ProductionNode</code> is the terminal node for each rule. When a token reaches a production node, all rule conditions have been satisfied:</p> <pre><code>class ProductionNode\n  def activate(token)\n    @tokens &lt;&lt; token\n    # Don't fire immediately - wait for engine.run()\n  end\n\n  def fire_rule(token)\n    return if token.fired?\n    @rule.fire(token.facts)\n    token.mark_fired!\n  end\nend\n</code></pre> <p>Why delay firing? Negation nodes may need to deactivate tokens after they're created but before they fire. The two-phase approach (collect tokens, then fire) ensures correctness.</p> <p>Implementation: <code>lib/kbs/production_node.rb:4</code></p>"},{"location":"architecture/rete-algorithm/#the-rete-cycle","title":"The RETE Cycle","text":""},{"location":"architecture/rete-algorithm/#1-network-construction","title":"1. Network Construction","text":"<p>When a rule is added via <code>engine.add_rule(rule)</code>, the network is built:</p> <pre><code>def build_network_for_rule(rule)\n  current_beta = @root_beta_memory\n\n  rule.conditions.each_with_index do |condition, index|\n    # Create or reuse alpha memory\n    pattern = condition.pattern.merge(type: condition.type)\n    alpha_memory = get_or_create_alpha_memory(pattern)\n\n    # Build join tests for variable consistency\n    tests = build_join_tests(condition, index)\n\n    # Create join or negation node\n    if condition.negated\n      negation_node = NegationNode.new(alpha_memory, current_beta, tests)\n      new_beta = BetaMemory.new\n      negation_node.successors &lt;&lt; new_beta\n      current_beta = new_beta\n    else\n      join_node = JoinNode.new(alpha_memory, current_beta, tests)\n      new_beta = BetaMemory.new\n      join_node.successors &lt;&lt; new_beta\n      current_beta = new_beta\n    end\n  end\n\n  # Terminal production node\n  production_node = ProductionNode.new(rule)\n  current_beta.successors &lt;&lt; production_node\n  @production_nodes[rule.name] = production_node\nend\n</code></pre> <p>Implementation: <code>lib/kbs/rete_engine.rb:58</code></p>"},{"location":"architecture/rete-algorithm/#2-fact-assertion","title":"2. Fact Assertion","text":"<p>When <code>engine.add_fact(:stock, symbol: \"AAPL\", price: 150)</code> is called:</p> <p></p> <p>Step-by-step flow showing how a fact propagates through the RETE network from working memory to production nodes.</p>"},{"location":"architecture/rete-algorithm/#3-pattern-matching-flow","title":"3. Pattern Matching Flow","text":"<p>Let's trace a fact through the network for this rule:</p> <pre><code># Rule: Alert when AAPL stock exists but no alert exists\nrule = Rule.new(\"no_alert\") do |r|\n  r.conditions = [\n    Condition.new(:stock, { symbol: \"AAPL\" }),\n    Condition.new(:alert, { symbol: \"AAPL\" }, negated: true)\n  ]\n  r.action = -&gt;(facts) { puts \"No alert for AAPL!\" }\nend\n</code></pre> <p></p> <p>Complete trace showing how negation works: adding a stock fact fires the rule, adding an alert inhibits it, and removing the alert reactivates the rule.</p>"},{"location":"architecture/rete-algorithm/#4-rule-execution","title":"4. Rule Execution","text":"<p>The final phase is <code>engine.run()</code>:</p> <pre><code>def run\n  @production_nodes.values.each do |node|\n    node.tokens.each do |token|\n      node.fire_rule(token)\n    end\n  end\nend\n</code></pre> <p>Each production node fires its accumulated tokens. The <code>fired?</code> flag prevents duplicate firing.</p> <p>Implementation: <code>lib/kbs/rete_engine.rb:48</code></p>"},{"location":"architecture/rete-algorithm/#rete-optimization-unlinking","title":"RETE Optimization: Unlinking","text":""},{"location":"architecture/rete-algorithm/#the-problem","title":"The Problem","text":"<p>In basic RETE, join nodes always process activations even when one input is empty:</p> <pre><code>BetaMemory (0 tokens) \u2500\u2500\u2510\n                        \u251c\u2500\u2500\u2192 JoinNode \u2500\u2500\u2192 (does useless work!)\nAlphaMemory (100 facts) \u2518\n</code></pre> <p>If beta memory is empty, the join will produce zero results, wasting CPU cycles.</p>"},{"location":"architecture/rete-algorithm/#the-solution","title":"The Solution","text":"<p>RETE introduces dynamic unlinking: nodes automatically disconnect from the network when empty and reconnect when non-empty.</p> <pre><code>class BetaMemory\n  def add_token(token)\n    @tokens &lt;&lt; token\n    relink! if @tokens.size == 1  # Reconnect when first token arrives\n  end\n\n  def remove_token(token)\n    @tokens.delete(token)\n    unlink! if @tokens.empty?     # Disconnect when empty\n  end\n\n  def relink!\n    @linked = true\n    @successors.each { |s| s.left_relink! }\n  end\n\n  def unlink!\n    @linked = false\n    @successors.each { |s| s.left_unlink! }\n  end\nend\n</code></pre> <p>Join node respects linking state:</p> <pre><code>class JoinNode\n  def left_activate(token)\n    return unless @left_linked &amp;&amp; @right_linked  # Skip if unlinked!\n    # ... perform join ...\n  end\n\n  def right_activate(fact)\n    return unless @left_linked &amp;&amp; @right_linked  # Skip if unlinked!\n    # ... perform join ...\n  end\nend\n</code></pre>"},{"location":"architecture/rete-algorithm/#performance-impact","title":"Performance Impact","text":"<p>For rules with many conditions, unlinking can reduce RETE network activations by 90%+:</p> <ul> <li>Empty alpha memories don't trigger join operations</li> <li>Empty beta memories don't process fact assertions</li> <li>Network \"lights up\" only the relevant paths</li> </ul> <p>This is especially critical for: - Negated conditions (often have empty alpha memories) - Rare patterns (e.g., \"critical alert\" facts) - Complex rules (many conditions = more opportunities for empty nodes)</p>"},{"location":"architecture/rete-algorithm/#variable-binding","title":"Variable Binding","text":"<p>Variables (symbols starting with <code>?</code>) enable cross-condition constraints and action parameterization:</p>"},{"location":"architecture/rete-algorithm/#extraction-during-network-build","title":"Extraction During Network Build","text":"<pre><code>class Condition\n  def extract_variables(pattern)\n    vars = {}\n    pattern.each do |key, value|\n      if value.is_a?(Symbol) &amp;&amp; value.to_s.start_with?('?')\n        vars[value] = key  # { :?symbol =&gt; :symbol, :?price =&gt; :price }\n      end\n    end\n    vars\n  end\nend\n</code></pre> <p>Implementation: <code>lib/kbs/condition.rb:16</code></p>"},{"location":"architecture/rete-algorithm/#join-test-generation","title":"Join Test Generation","text":"<p>Variables create join tests to ensure consistency:</p> <pre><code># Rule with shared ?symbol variable\nconditions = [\n  Condition.new(:stock, { symbol: :?symbol, price: :?price }),\n  Condition.new(:order, { symbol: :?symbol, quantity: 100 })\n]\n\n# Generates join test:\n{\n  token_field_index: 0,      # Check first fact in token (stock)\n  token_field: :symbol,       # Get its :symbol attribute\n  fact_field: :symbol,        # Compare with order's :symbol attribute\n  operation: :eq              # Must be equal\n}\n</code></pre> <p>Implementation: <code>lib/kbs/join_node.rb:89</code></p>"},{"location":"architecture/rete-algorithm/#action-binding","title":"Action Binding","text":"<p>When a rule fires, bindings are extracted for the action:</p> <pre><code>def fire(facts)\n  bindings = extract_bindings(facts)\n  # bindings = { :?symbol =&gt; \"AAPL\", :?price =&gt; 150.0 }\n\n  @action.call(facts, bindings)\nend\n\ndef extract_bindings(facts)\n  bindings = {}\n  @conditions.each_with_index do |condition, index|\n    next if condition.negated  # Negated conditions have no fact\n    fact = facts[index]\n    condition.variable_bindings.each do |var, field|\n      bindings[var] = fact.attributes[field]\n    end\n  end\n  bindings\nend\n</code></pre> <p>Implementation: <code>lib/kbs/rule.rb:34</code></p>"},{"location":"architecture/rete-algorithm/#advanced-topics","title":"Advanced Topics","text":""},{"location":"architecture/rete-algorithm/#conflict-resolution","title":"Conflict Resolution","text":"<p>When multiple rules are activated simultaneously, KBS uses priority (higher values fire first):</p> <pre><code>rule1 = Rule.new(\"urgent\", priority: 10) { ... }\nrule2 = Rule.new(\"normal\", priority: 0) { ... }\n\n# rule1 fires before rule2\n</code></pre> <p>For same-priority rules, firing order is deterministic but unspecified (depends on hash ordering).</p>"},{"location":"architecture/rete-algorithm/#fact-retraction","title":"Fact Retraction","text":"<p>Removing facts triggers recursive token deletion:</p> <pre><code>class JoinNode\n  def right_deactivate(fact)\n    tokens_to_remove = []\n\n    @beta_memory.tokens.each do |token|\n      # Find child tokens containing this fact\n      token.children.select { |child| child.fact == fact }.each do |child|\n        tokens_to_remove &lt;&lt; child\n        @successors.each { |s| s.deactivate(child) }  # Recursive!\n      end\n    end\n\n    tokens_to_remove.each { |token| token.parent.children.delete(token) }\n  end\nend\n</code></pre> <p>This ensures truth maintenance: when a premise is removed, all derived conclusions are also removed.</p> <p>Implementation: <code>lib/kbs/join_node.rb:72</code></p>"},{"location":"architecture/rete-algorithm/#network-sharing","title":"Network Sharing","text":"<p>Alpha memories are shared across rules using pattern as the hash key:</p> <pre><code>def get_or_create_alpha_memory(pattern)\n  @alpha_memories[pattern] ||= AlphaMemory.new(pattern)\nend\n</code></pre> <p>If 10 rules all match <code>stock(symbol: \"AAPL\")</code>, they share one <code>AlphaMemory</code> node, reducing: - Memory usage (one fact store instead of 10) - Computation (one pattern match instead of 10)</p> <p>Implementation: <code>lib/kbs/rete_engine.rb:104</code></p>"},{"location":"architecture/rete-algorithm/#incremental-matching","title":"Incremental Matching","text":"<p>RETE is incremental: after the initial network build, only changes are processed. Adding a fact activates a small subgraph, not the entire network.</p> <p>Complexity: - Initial build: O(R \u00d7 F) where R = rules, F = facts - Per-fact addition: O(N) where N = activated nodes (typically &lt;&lt; R \u00d7 F) - Per-fact removal: O(T) where T = tokens to remove</p> <p>In practice, RETE can handle millions of facts with sub-millisecond updates.</p>"},{"location":"architecture/rete-algorithm/#debugging-rete-networks","title":"Debugging RETE Networks","text":""},{"location":"architecture/rete-algorithm/#visualizing-token-flow","title":"Visualizing Token Flow","text":"<p>Enable token tracing:</p> <pre><code>class Token\n  def to_s\n    \"Token(#{facts.map(&amp;:to_s).join(', ')})\"\n  end\nend\n\n# In your rule action:\nr.action = lambda do |facts, bindings|\n  puts \"Fired with facts: #{facts.map(&amp;:to_s).join(', ')}\"\n  puts \"Bindings: #{bindings.inspect}\"\nend\n</code></pre>"},{"location":"architecture/rete-algorithm/#inspecting-network-state","title":"Inspecting Network State","text":"<p>Check what's in memories:</p> <pre><code># Alpha memory contents\nengine.alpha_memories.each do |pattern, memory|\n  puts \"Pattern #{pattern}: #{memory.items.size} facts\"\n  memory.items.each { |f| puts \"  - #{f}\" }\nend\n\n# Beta memory contents (requires introspection)\ndef walk_beta_network(beta)\n  puts \"Beta memory: #{beta.tokens.size} tokens\"\n  beta.tokens.each { |t| puts \"  - #{t}\" }\n  beta.successors.each do |node|\n    if node.is_a?(BetaMemory)\n      walk_beta_network(node)\n    end\n  end\nend\n</code></pre>"},{"location":"architecture/rete-algorithm/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Forgetting to call <code>engine.run()</code>: Tokens accumulate but rules don't fire</li> <li>Pattern mismatches: <code>{ type: :stock }</code> vs <code>Condition.new(:stock, {})</code> - the latter doesn't filter by type!</li> <li>Variable binding errors: Using <code>?symbol</code> (string) instead of <code>:?symbol</code> (symbol)</li> <li>Negation timing: Negated conditions only fire when facts are absent, not after they're removed (use <code>engine.run()</code> to re-evaluate)</li> </ol>"},{"location":"architecture/rete-algorithm/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/rete-algorithm/#time-complexity","title":"Time Complexity","text":"Operation Complexity Notes Add rule O(C \u00d7 F) C = conditions, F = existing facts Add fact O(N) N = activated nodes (avg &lt;&lt; total nodes) Remove fact O(T) T = tokens containing fact Run rules O(M) M = matched tokens in production nodes"},{"location":"architecture/rete-algorithm/#space-complexity","title":"Space Complexity","text":"Structure Space Notes Alpha memories O(F \u00d7 P) F = facts, P = unique patterns Beta memories O(T) T = partial match tokens Tokens O(C \u00d7 M) C = conditions, M = complete matches Network nodes O(R \u00d7 C) R = rules, C = avg conditions per rule"},{"location":"architecture/rete-algorithm/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Pattern specificity: Put most selective conditions first to reduce beta memory size</li> <li>Negation placement: Place negated conditions last (they don't add facts to tokens)</li> <li>Shared patterns: Design rules to share common patterns</li> <li>Fact pruning: Remove obsolete facts to trigger unlinking</li> <li>Priority tuning: Use priority to fire expensive rules last</li> </ol>"},{"location":"architecture/rete-algorithm/#comparison-with-other-algorithms","title":"Comparison with Other Algorithms","text":""},{"location":"architecture/rete-algorithm/#naive-match-all","title":"Naive Match-All","text":"<pre><code># O(R \u00d7 F) on every cycle\ndef naive_fire_rules\n  rules.each do |rule|\n    facts.each do |fact|\n      if rule.matches?(fact)\n        rule.fire(fact)\n      end\n    end\n  end\nend\n</code></pre> <p>Problem: Re-evaluates everything, no state preservation.</p>"},{"location":"architecture/rete-algorithm/#treat","title":"TREAT","text":"<p>TREAT eliminates alpha/beta network in favor of lazy evaluation: - Pros: Simpler implementation, lower memory - Cons: Slower for rules that fire frequently (no memoization)</p> <p>RETE is better when rules fire often; TREAT is better for sparse firing.</p>"},{"location":"architecture/rete-algorithm/#basic-rete-vs-rete-with-unlinking","title":"Basic RETE vs RETE with Unlinking","text":"<p>Early RETE implementations lacked unlinking: - Without unlinking: All nodes always active, many wasted join operations - With unlinking: Nodes disconnect when empty, up to 10\u00d7 faster</p> <p>KBS implements RETE with unlinking optimization.</p>"},{"location":"architecture/rete-algorithm/#implementation-files","title":"Implementation Files","text":"Component File Lines Core engine <code>lib/kbs/rete_engine.rb</code> ~110 Working memory <code>lib/kbs/working_memory.rb</code> ~35 Facts <code>lib/kbs/fact.rb</code> ~45 Tokens <code>lib/kbs/token.rb</code> ~40 Alpha memory <code>lib/kbs/alpha_memory.rb</code> ~40 Beta memory <code>lib/kbs/beta_memory.rb</code> ~60 Join nodes <code>lib/kbs/join_node.rb</code> ~120 Negation nodes <code>lib/kbs/negation_node.rb</code> ~90 Production nodes <code>lib/kbs/production_node.rb</code> ~30 Conditions <code>lib/kbs/condition.rb</code> ~30 Rules <code>lib/kbs/rule.rb</code> ~50 <p>Total: ~650 lines of core RETE implementation.</p>"},{"location":"architecture/rete-algorithm/#further-reading","title":"Further Reading","text":""},{"location":"architecture/rete-algorithm/#academic-papers","title":"Academic Papers","text":"<ul> <li>Forgy, C. (1982). \"Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem\". Artificial Intelligence, 19(1), 17-37.</li> <li>Forgy, C. (1989). \"Rete: A Fast Match Algorithm\". AI Expert, 4(1), 34-40.</li> </ul>"},{"location":"architecture/rete-algorithm/#textbooks","title":"Textbooks","text":"<ul> <li>Giarratano, J., &amp; Riley, G. (2004). Expert Systems: Principles and Programming (4<sup>th</sup> ed.). Course Technology.</li> <li>Russell, S., &amp; Norvig, P. (2020). Artificial Intelligence: A Modern Approach (4<sup>th</sup> ed.). Pearson. (Chapter on Rule-Based Systems)</li> </ul>"},{"location":"architecture/rete-algorithm/#online-resources","title":"Online Resources","text":"<ul> <li>RETE Algorithm Visualization - Jess documentation</li> <li>Production Systems - Wikipedia</li> <li>Rule-Based Expert Systems - University of Toronto</li> </ul>"},{"location":"architecture/rete-algorithm/#next-steps","title":"Next Steps","text":"<ul> <li>DSL Guide: Learn how to write rules using KBS's Ruby DSL</li> <li>Blackboard Architecture: Understand persistent memory and multi-agent systems</li> <li>Examples: See RETE in action with stock trading and expert systems</li> <li>Performance Tuning: Optimize your rule-based system</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Real-world applications of KBS.</p> <ul> <li>Stock Trading - Algorithmic trading system</li> <li>Expert Systems - Diagnostic and decision support</li> <li>Multi-Agent Systems - Collaborative problem-solving</li> </ul> <p>See also: Quick Start Guide</p>"},{"location":"examples/expert-systems/","title":"Expert Systems Example","text":"<p>Coming soon: Diagnostic expert system.</p>"},{"location":"examples/expert-systems/#system-overview","title":"System Overview","text":"<ul> <li>Knowledge representation</li> <li>Inference engine</li> <li>Explanation facility</li> <li>Confidence factors</li> </ul>"},{"location":"examples/multi-agent/","title":"Multi-Agent Systems Example","text":"<p>Coming soon: Collaborative agents with blackboard.</p>"},{"location":"examples/multi-agent/#system-overview","title":"System Overview","text":"<ul> <li>Agent architecture</li> <li>Message passing</li> <li>Coordination strategies</li> <li>Conflict resolution</li> </ul>"},{"location":"examples/stock-trading/","title":"Stock Trading Example","text":"<p>Coming soon: Complete algorithmic trading system.</p>"},{"location":"examples/stock-trading/#system-overview","title":"System Overview","text":"<ul> <li>Market data collection</li> <li>Signal generation</li> <li>Risk management</li> <li>Order execution</li> </ul> <p>See <code>examples/stock_trading_advanced.rb</code> in the repository.</p>"},{"location":"guides/","title":"Guides","text":"<p>Practical guides for using KBS effectively.</p>"},{"location":"guides/#getting-started","title":"Getting Started","text":"<ul> <li>Getting Started - Your first rule-based system</li> <li>Writing Rules - Rule authoring best practices</li> <li>DSL Reference - Complete syntax guide</li> </ul>"},{"location":"guides/#core-concepts","title":"Core Concepts","text":"<ul> <li>Facts - Working with facts and queries</li> <li>Pattern Matching - Pattern syntax and operators</li> <li>Variable Binding - Using variables in rules</li> <li>Negation - Matching absent patterns</li> </ul>"},{"location":"guides/#persistence","title":"Persistence","text":"<ul> <li>Blackboard Memory - Persistent shared memory</li> <li>Persistence Options - SQLite, Redis, and Hybrid backends</li> </ul>"},{"location":"guides/#next-steps","title":"Next Steps","text":"<ul> <li>Examples - See KBS in action</li> <li>Advanced Topics - Production optimization</li> <li>API Reference - Complete class documentation</li> </ul>"},{"location":"guides/blackboard-memory/","title":"Blackboard Memory","text":"<p>Coming soon: Guide to persistent shared memory.</p> <p>See Blackboard Architecture for details.</p>"},{"location":"guides/dsl/","title":"DSL Reference","text":"<p>Coming soon: Complete syntax guide for the KBS DSL.</p>"},{"location":"guides/dsl/#topics","title":"Topics","text":"<ul> <li>Condition keywords</li> <li>Pattern syntax</li> <li>Variable binding</li> <li>Negation operators</li> <li>Helper functions</li> </ul>"},{"location":"guides/facts/","title":"Working with Facts","text":"<p>Coming soon: Fact lifecycle, queries, and management.</p>"},{"location":"guides/facts/#topics","title":"Topics","text":"<ul> <li>Creating facts</li> <li>Querying facts</li> <li>Updating facts</li> <li>Removing facts</li> <li>Fact types</li> </ul>"},{"location":"guides/getting-started/","title":"Getting Started","text":"<p>Coming soon: Expanded tutorial for building your first knowledge-based system.</p> <p>See Quick Start for now.</p>"},{"location":"guides/negation/","title":"Negation","text":"<p>Coming soon: Understanding negated conditions.</p>"},{"location":"guides/negation/#topics","title":"Topics","text":"<ul> <li>Negation semantics</li> <li>Use cases</li> <li>Performance implications</li> <li>Common pitfalls</li> </ul>"},{"location":"guides/pattern-matching/","title":"Pattern Matching","text":"<p>Coming soon: Advanced pattern matching techniques.</p>"},{"location":"guides/pattern-matching/#topics","title":"Topics","text":"<ul> <li>Literal values</li> <li>Variables</li> <li>Predicates</li> <li>Type matching</li> <li>Operators</li> </ul>"},{"location":"guides/persistence/","title":"Persistence Options","text":"<p>Coming soon: Choosing and configuring storage backends.</p> <p>See Blackboard Architecture for backend details.</p>"},{"location":"guides/variable-binding/","title":"Variable Binding","text":"<p>Coming soon: Using variables to connect conditions.</p>"},{"location":"guides/variable-binding/#topics","title":"Topics","text":"<ul> <li>Variable syntax</li> <li>Join tests</li> <li>Binding extraction</li> <li>Cross-condition constraints</li> </ul>"},{"location":"guides/writing-rules/","title":"Writing Rules","text":"<p>Coming soon: Best practices for authoring  rules.</p>"},{"location":"guides/writing-rules/#topics","title":"Topics","text":"<ul> <li>Rule structure and naming</li> <li>Condition ordering</li> <li>Action design</li> <li>Priority management</li> <li>Testing strategies</li> </ul>"}]}